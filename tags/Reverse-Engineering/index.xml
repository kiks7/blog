<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Reverse Engineering on</title><link>https://1day.dev/tags/Reverse-Engineering/</link><description>Recent content in Reverse Engineering on</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 07 Dec 2024 00:00:00 +0100</lastBuildDate><atom:link href="https://1day.dev/tags/Reverse-Engineering/index.xml" rel="self" type="application/rss+xml"/><item><title>Not All Roads Lead to PWN2OWN - Firmware Reverse Engineering (Part 2)</title><link>https://1day.dev/notes/Not-All-Roads-Lead-to-PWN2OWN-Firmware-Reverse-Engineering-Part-2/</link><pubDate>Sat, 07 Dec 2024 00:00:00 +0100</pubDate><guid>https://1day.dev/notes/Not-All-Roads-Lead-to-PWN2OWN-Firmware-Reverse-Engineering-Part-2/</guid><description>Introduction In the previous blog post, we have dissected the Lorex 2K IP Camera from an hardware perspective. The main objectives were to obtain an an interactive shell and extract the firmware for further analysis.</description></item><item><title>Not All Roads Lead to PWN2OWN: Hardware Hacking (Part 1)</title><link>https://1day.dev/notes/Not-All-Roads-Lead-to-PWN2OWN-Hardware-Hacking-Part-1/</link><pubDate>Sun, 01 Dec 2024 00:00:00 +0100</pubDate><guid>https://1day.dev/notes/Not-All-Roads-Lead-to-PWN2OWN-Hardware-Hacking-Part-1/</guid><description>I have not personally written this blog post but it was the result of a collaboration done in Hacktive Security.</description></item><item><title>A Reverse Engineering Journey Walkthrough</title><link>https://1day.dev/notes/A-Reverse-Engineering-Journey-Walkthrough/</link><pubDate>Mon, 04 Nov 2024 00:00:00 +0100</pubDate><guid>https://1day.dev/notes/A-Reverse-Engineering-Journey-Walkthrough/</guid><description>Introduction This blog post is about a manually Reverse Engineered challenge I have written for this year NoHat24 security conference. The conference was a blast and we also did (as Hacktive Security) our best to contribute also with a worskhop on Linux Kernel Fuzzing.</description></item><item><title>TODO</title><link>https://1day.dev/notes/ZZTEmplate/</link><pubDate>Mon, 04 Nov 2024 00:00:00 +0100</pubDate><guid>https://1day.dev/notes/ZZTEmplate/</guid><description/></item><item><title>Android Deserialization Deep Dive</title><link>https://1day.dev/notes/Android-Deserialization-Deep-Dive/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://1day.dev/notes/Android-Deserialization-Deep-Dive/</guid><description>Introduction Serialization and deserialization mechanisms are always risky operations from a security point of view. In most languages and frameworks, if an attacker is able to deserialize arbitrary input (or just corrupt it as we have demonstrated years ago with the Rusty Joomla RCE) the impact is usually the most critical: Remote Code Execution.</description></item></channel></rss>