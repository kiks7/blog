<!doctype html><html lang=en><head><meta charset=utf-8><meta name=description content="Introduction In the past few weeks, I worked with @LukeGix (checkout his blog post on the same vulnerability here) to exploit the CVE-2022-2602, a very interesting bug from multiple perspectives without a public exploit, that impacts the io_uring subsystem with an Use-After-Free vulnerability handling registered file descriptors."><title>Linux Kernel DirtyCred File Exploitation applied on an io_uring UAF - CVE-2022-2602</title><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" type=image/png href=https://1day.dev//icon.png><link href=https://1day.dev/styles.7153093e4d1bbb584a28469cadfa3f88.min.css rel=stylesheet><link href=https://1day.dev/styles/_light_syntax.86a48a52faebeaaf42158b72922b1c90.min.css rel=stylesheet id=theme-link><script src=https://1day.dev/js/darkmode.e6934a61ff52b65bd16cdf94b370f112.min.js></script>
<script src=https://1day.dev/js/util.9825137f5e7825e8553c68ce39ac9e44.min.js></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css integrity=sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js integrity=sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/copy-tex.min.js integrity=sha384-ww/583aHhxWkz5DEVn6OKtNiIaLi2iBRNZXfJRiY1Ai7tnJ9UXpEsyvOITVpTl4A crossorigin=anonymous></script>
<script src=https://unpkg.com/@floating-ui/core@0.7.3></script>
<script src=https://unpkg.com/@floating-ui/dom@0.5.4></script>
<script src=https://1day.dev/js/popover.53ad9a087e3feeaaa12b63bfd02d923b.min.js></script>
<script src=https://1day.dev/js/code-title.b35124ad8db0ba37162b886afb711cbc.min.js></script>
<script src=https://1day.dev/js/clipboard.c20857734e53a3fb733b7443879efa61.min.js></script>
<script src=https://1day.dev/js/callouts.7723cac461d613d118ee8bb8216b9838.min.js></script>
<script>const BASE_URL="https://1day.dev/",fetchData=Promise.all([fetch("https://1day.dev/indices/linkIndex.c68285995b445e8bf050f004a7b693d7.min.json").then(e=>e.json()).then(e=>({index:e.index,links:e.links})),fetch("https://1day.dev/indices/contentIndex.4f898951d8f48d6af7d68ae0b05aa5e8.min.json").then(e=>e.json())]).then(([{index:e,links:t},n])=>({index:e,links:t,content:n})),render=()=>{const e=new URL(BASE_URL),t=e.pathname,n=window.location.pathname,s=t==n;addCopyButtons(),addTitleToCodeBlocks(),addCollapsibleCallouts(),initPopover("https://1day.dev",!1,!0)},init=(e=document)=>{addCopyButtons(),addTitleToCodeBlocks(),renderMathInElement(e.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],macros:{'â€™':"'"},throwOnError:!1})}</script><script type=module>
    import { attachSPARouting } from "https:\/\/1day.dev\/js\/router.9d4974281069e9ebb189f642ae1e3ca2.min.js"
    attachSPARouting(init, render)
  </script></head><script async src="https://www.googletagmanager.com/gtag/js?id=G-BZ6HJYMG3K"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-BZ6HJYMG3K",{anonymize_ip:!1})}</script><body><div id=search-container><div id=search-space><input autocomplete=off id=search-bar name=search type=text aria-label=Search placeholder="Search for something..."><div id=results-container></div></div></div><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.21/dist/flexsearch.bundle.js integrity="sha256-i3A0NZGkhsKjVMzFxv3ksk0DZh3aXqu0l49Bbh0MdjE=" crossorigin=anonymous defer></script>
<script defer src=https://1day.dev/js/full-text-search.24827f874defbbc6d529926cbfcfb493.min.js></script><div class=singlePage><header><h1 id=page-title><a href=https://1day.dev/>ðŸ‘¾ @kiks</a></h1><div class=spacer></div><div id=search-icon><p>Search</p><svg tabindex="0" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search Icon</title><desc id="desc">Icon to open search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"/><circle cx="8" cy="8" r="7"/></g></svg></div><div class=darkmode><input class=toggle id=darkmode-toggle type=checkbox tabindex=-1>
<label id=toggle-label-light for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="dayIcon" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35"><title>Light Mode</title><path d="M6 17.5C6 16.672 5.328 16 4.5 16h-3C.672 16 0 16.672.0 17.5S.672 19 1.5 19h3C5.328 19 6 18.328 6 17.5zM7.5 26c-.414.0-.789.168-1.061.439l-2 2C4.168 28.711 4 29.086 4 29.5 4 30.328 4.671 31 5.5 31c.414.0.789-.168 1.06-.44l2-2C8.832 28.289 9 27.914 9 27.5 9 26.672 8.329 26 7.5 26zm10-20C18.329 6 19 5.328 19 4.5v-3C19 .672 18.329.0 17.5.0S16 .672 16 1.5v3C16 5.328 16.671 6 17.5 6zm10 3c.414.0.789-.168 1.06-.439l2-2C30.832 6.289 31 5.914 31 5.5 31 4.672 30.329 4 29.5 4c-.414.0-.789.168-1.061.44l-2 2C26.168 6.711 26 7.086 26 7.5 26 8.328 26.671 9 27.5 9zM6.439 8.561C6.711 8.832 7.086 9 7.5 9 8.328 9 9 8.328 9 7.5c0-.414-.168-.789-.439-1.061l-2-2C6.289 4.168 5.914 4 5.5 4 4.672 4 4 4.672 4 5.5c0 .414.168.789.439 1.06l2 2.001zM33.5 16h-3c-.828.0-1.5.672-1.5 1.5s.672 1.5 1.5 1.5h3c.828.0 1.5-.672 1.5-1.5S34.328 16 33.5 16zM28.561 26.439C28.289 26.168 27.914 26 27.5 26c-.828.0-1.5.672-1.5 1.5.0.414.168.789.439 1.06l2 2C28.711 30.832 29.086 31 29.5 31c.828.0 1.5-.672 1.5-1.5.0-.414-.168-.789-.439-1.061l-2-2zM17.5 29c-.829.0-1.5.672-1.5 1.5v3c0 .828.671 1.5 1.5 1.5s1.5-.672 1.5-1.5v-3C19 29.672 18.329 29 17.5 29zm0-22C11.71 7 7 11.71 7 17.5S11.71 28 17.5 28 28 23.29 28 17.5 23.29 7 17.5 7zm0 18c-4.136.0-7.5-3.364-7.5-7.5s3.364-7.5 7.5-7.5 7.5 3.364 7.5 7.5S21.636 25 17.5 25z"/></svg></label><label id=toggle-label-dark for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="nightIcon" viewBox="0 0 100 100" style="enable-background='new 0 0 100 100'"><title>Dark Mode</title><path d="M96.76 66.458c-.853-.852-2.15-1.064-3.23-.534-6.063 2.991-12.858 4.571-19.655 4.571C62.022 70.495 50.88 65.88 42.5 57.5 29.043 44.043 25.658 23.536 34.076 6.47c.532-1.08.318-2.379-.534-3.23-.851-.852-2.15-1.064-3.23-.534-4.918 2.427-9.375 5.619-13.246 9.491-9.447 9.447-14.65 22.008-14.65 35.369.0 13.36 5.203 25.921 14.65 35.368s22.008 14.65 35.368 14.65c13.361.0 25.921-5.203 35.369-14.65 3.872-3.871 7.064-8.328 9.491-13.246C97.826 68.608 97.611 67.309 96.76 66.458z"/></svg></label></div></header><article><h1>Linux Kernel DirtyCred File Exploitation applied on an io_uring UAF - CVE-2022-2602</h1><p class=meta>Last updated
Dec 20, 2022</p><ul class=tags><li><a href=https://1day.dev/tags/Exploitation/>Exploitation</a></li><li><a href=https://1day.dev/tags/Linux/>Linux</a></li><li><a href=https://1day.dev/tags/Kernel/>Kernel</a></li></ul><aside class=mainTOC><details><summary>Table of Contents</summary><nav id=TableOfContents><ol><li><a href=#introduction>Introduction</a></li><li><a href=#tldr>TL;DR</a></li><li><a href=#vulnerability>Vulnerability</a><ol><li><a href=#root-cause>Root cause</a></li><li><a href=#fix>Fix</a></li></ol></li><li><a href=#exploitation>Exploitation</a><ol><li><a href=#exploitation-strategies>Exploitation strategies</a></li><li><a href=#dirtycred-file-exploitation>DirtyCred: File Exploitation</a></li><li><a href=#file-locking-slow-write>File locking (Slow Write)</a></li><li><a href=#exploitation-walkthrough>Exploitation Walkthrough</a></li></ol></li><li><a href=#extra-new-krwx-feature>Extra: new KRWX feature</a></li><li><a href=#conclusions>Conclusions</a></li><li><a href=#references>References</a></li></ol></nav></details></aside><a href=#introduction><h2 id=introduction><span class=hanchor arialabel=Anchor># </span>Introduction</h2></a><p>In the past few weeks, I worked with
<a href=https://exploiter.dev rel=noopener>@LukeGix</a> (checkout his blog post on the same vulnerability
<a href=https://exploiter.dev/blog/2022/CVE-2022-2602.html rel=noopener>here</a>) to exploit the CVE-2022-2602, a very interesting bug from multiple perspectives without a public exploit, that impacts the io_uring subsystem with an Use-After-Free vulnerability handling registered file descriptors.
We used a Data-Only attack against kernel version 5.15.74 (the latest before the patch) taking inspiration from the DirtyCred technique recently presented at
<a href=https://zplin.me/papers/DirtyCred.pdf rel=noopener>BlackHat USA</a>.</p><a href=#tldr><h2 id=tldr><span class=hanchor arialabel=Anchor># </span>TL;DR</h2></a><p>The vulnerability is an Use-After-Free that impacts the registered file descriptor functionality in the io_uring subsystem. It&rsquo;s possible to register a file in the io_uring context, free it from the Unix Garbage Collector and re-use it with the requested io_uring operation (for example, a <code>writev</code> operation). To exploit the bug, it was a matter of replace the freed file structure with a read-only file (e.g. /etc/passwd), in order to write into it, and achieve a good timing with a small race window.</p><a href=#vulnerability><h2 id=vulnerability><span class=hanchor arialabel=Anchor># </span>Vulnerability</h2></a><a href=#root-cause><h3 id=root-cause><span class=hanchor arialabel=Anchor># </span>Root cause</h3></a><p>The vulnerability is an Use-After-Free in the io_uring subsystem while handling registered files. The
<a href=https://manpages.debian.org/unstable/liburing-dev/io_uring_register.2.en.html#IORING_REGISTER_FILES rel=noopener>IORING_REGISTER_FILES</a> functionality permits to register file descriptors in the io_uring context so that the consumer (the user-land application) do not have to keep them open. It works by passing the list of file descriptors using the
<a href=https://manpages.debian.org/unstable/liburing-dev/io_uring_register.2.en.html rel=noopener>io_uring_register</a> syscall. However, the Unix Garbage collector (well explained in
<a href=https://googleprojectzero.blogspot.com/2022/08/the-quantum-state-of-linux-kernel.html rel=noopener>this project zero blog post</a>), which its entrypoint is the
<a href=https://elixir.bootlin.com/linux/v5.15.74/source/net/unix/garbage.c#L205 rel=noopener>unix_gc</a> function and its responsability is to de-allocate in-flight sockets, can free these registered files while io_uring is using them, causing an Use-After-Free vulnerability.</p><p>The vulnerability has been
<a href="https://seclists.org/oss-sec/2022/q4/57?utm_source=dlvr.it&utm_medium=twitter" rel=noopener>discovered and described</a> from &ldquo;Thadeu Lima de Souza Cascardo&rdquo; as following:</p><blockquote><p>The vulnerability is a use-after-free that happens when an io_uring request is being processed on a registered file and the Unix GC runs and frees the io_uring fd and all the registered fds. The order at which the Unix GC processes the inflight fds may lead to registered fds be freed before the io_uring is released and has the chance to unregister and wait for such requests to finish.</p></blockquote><p>Putting simple, in order to trigger the vulnerability, we have to register a file descriptor that can be used in an io_uring operation (like a <code>writev</code>) using
<a href=https://unixism.net/loti/tutorial/sq_poll.html rel=noopener>SQPOLL</a> and block the write operation using userfault (as demonstrated in the public POC, however we will use something else in our exploit) that will block the kernel thread. Now, close the io_uring context from user-land, triggers <code>unix_gc</code> function in some way (that will free the allocated registered file) and resumes the faulted kernel thread by releasing the userfault. In that way, the UAF should be triggered (with KASAN enabled, you can see a bug report).</p><a href=#fix><h3 id=fix><span class=hanchor arialabel=Anchor># </span>Fix</h3></a><p>The
<a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=0091bfc81741b8d3aeb3b7ab8636f911b2de6e80" rel=noopener>fix</a> commit idea is pretty simple: Leave io_uring alone and let it handle these resources by itself
<a href=https://elixir.bootlin.com/linux/latest/source/net/unix/garbage.c#L301 rel=noopener>ignoring its registered files</a>.
Simple and effective.</p><a href=#exploitation><h2 id=exploitation><span class=hanchor arialabel=Anchor># </span>Exploitation</h2></a><a href=#exploitation-strategies><h3 id=exploitation-strategies><span class=hanchor arialabel=Anchor># </span>Exploitation strategies</h3></a><p>The vulnerability can be approached using different techniques. Since the targeted
<a href=https://elixir.bootlin.com/linux/v5.15.75/source/include/linux/fs.h#L966 rel=noopener>struct file</a> is in a dedicated cache (<code>filp</code>) a cross cache attack can be a viable approach, since the targeted object has a lot of interesting pointers and behaviours. However, we considered this possibility initially but we thought it would be a lot more reliabale to go with a data only technique. Replace the file struct with one in our control, perform some spray, and it could be possible (since the object is freed). Well, the idea was interesting, but we messed with a lot of things and, also if the exploit turned out quite simple, we put a lot of effort on it.</p><a href=#dirtycred-file-exploitation><h3 id=dirtycred-file-exploitation><span class=hanchor arialabel=Anchor># </span>DirtyCred: File Exploitation</h3></a><p>The DirtyCred attack is a technique presented this year at
<a href=https://i.blackhat.com/USA-22/Thursday/US-22-Lin-Cautious-A-New-Exploitation-Method.pdf rel=noopener>Black Hat 2022</a>. We are not going to further re-explain it since it has been already documented
<a href=https://zplin.me/papers/DirtyCred.pdf rel=noopener>in its original paper</a>, but what is in our intereset is the &ldquo;File Exploitation&rdquo; part:
<img src="/notes/images/cve-2022-2602 bh.png" width=800> - <em>Image from
<a href=https://i.blackhat.com/USA-22/Thursday/US-22-Lin-Cautious-A-New-Exploitation-Method.pdf rel=noopener>BH slides</a></em></p><p>The idea is pretty simple: If you replace a freed R/W file (while a kernel thread is writing into it) with a read-only file, you can write into that read-only file.
But, why and how? Let&rsquo;s start with the why. File permissions are
<a href=https://elixir.bootlin.com/linux/latest/source/fs/read_write.c#L568 rel=noopener>checked once</a> before writing with the <code>write</code> syscall, once it starts writing (<code>file->f_op->write</code>) no more permissions checks are performed. So, if you are able to replace the <code>struct file</code> (retrieved from the <code>fd</code> integer number installed for that specific context) with an arbitrary one (e.g. a read-only file) <strong>after</strong> permissions are granted and <strong>before</strong> its write operation, you can write into arbitrary files bypassing permission validations.
Well, but how? Mainly suspending the kernel execution thread when it starts writing, using
<a href=https://1day.dev/notes/Linux-Kernel-n-day-exploit-development-CVE-2020-27786 rel=noopener>userfault</a>,
<a href=https://exploiter.dev/blog/2022/FUSE-exploit.html rel=noopener>FUSE</a> or abusing file locking (Slow Write).</p><p>We choose to go with the file locking methodology in order to write an universal exploit that does not depend on specific configurations (also FUSE could be a good alternative, since unprivilged userfault has become a standard mitigation).</p><p>I would like to tell some observations on this slow write technique, so let&rsquo;s see it from the kernel perspective.</p><a href=#file-locking-slow-write><h3 id=file-locking-slow-write><span class=hanchor arialabel=Anchor># </span>File locking (Slow Write)</h3></a><p>The file locking mechanism is a must feature for a kernel: If two concurrency processes are writing into the same file, the kernel must be able to account that and deal with it without loss of integrity. How the kernel does that? Using file locks.
<a href=https://en.wikipedia.org/wiki/Lock_%28computer_science%29 rel=noopener>Locking</a> is a synchronization primitive that permits to handle access to the same resource in a multi-thread environment.
<a href=https://elixir.bootlin.com/linux/v5.15.75/source/fs/ext4/file.c#L253 rel=noopener>ext4_buffered_write_iter</a> is the function responsible to acquire this lock when a vectored write is requested (as in our case with io_uring), in a <code>ext4</code> file-sysytem, using the
<a href=https://elixir.bootlin.com/linux/v5.15.75/source/fs/ext4/file.c#L263 rel=noopener>inode_lock</a> (and later release it with
<a href=https://elixir.bootlin.com/linux/v5.15.75/source/fs/ext4/file.c#L273 rel=noopener>inode_unlock</a>), where the <code>inode</code> is our target file inode representation. If another thread is already writing into that node, the kernel thread is paused until the lock from the the other thread is released. When the other thread releases the file lock (calling <code>inode_unlock</code>), the sleeping kernel thread can resumes its execution acquiring the lock and starting to write into the file. But what if, during the sleep time, the <code>struct file</code> is replaced? Since permissions checks have been already done, the write action will be performed also if the re-allocated file has O_RDONLY permissions!
If you look closely in the
<a href=https://elixir.bootlin.com/linux/v5.15.75/source/fs/ext4/file.c#L253 rel=noopener>ext4_buffered_write_iter</a>, you can see that the pointer to the struct file is retrieved from
<a href=https://elixir.bootlin.com/linux/v5.15.75/source/include/linux/fs.h#L327 rel=noopener>iocb->ki_filp</a>, and the following calls will use that pointer to perform the write operation (
<a href=https://elixir.bootlin.com/linux/v5.15.75/C/ident/generic_perform_write rel=noopener>generic_perform_write</a>).
We used this technique to &ldquo;stays&rdquo; the object in the kernel and extend the race window, without using &ldquo;userfault&rdquo;.</p><a href=#fatal_signal_pending><h4 id=fatal_signal_pending><span class=hanchor arialabel=Anchor># </span>fatal_signal_pending</h4></a><p>An issue we encountered while developing the exploit was the
<a href=https://elixir.bootlin.com/linux/v5.15.75/C/ident/fatal_signal_pending rel=noopener>fatal_signal_pending</a> call from
<a href=https://elixir.bootlin.com/linux/v5.15.75/C/ident/generic_perform_write rel=noopener>generic_perform_write</a>. This check ensures that the <code>current</code> context does not have fatal signals hanging, for example by avoiding the write operation if the process has been already closed. This was one of the issues we had to overcome that took us quite some time, since debugging these kinds of operations leads to non truthful behaviours. By the way, the resolution was just to wait until io_uring has finished its operation by monitoring our target file size:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>	<span class=cm>/* .. */</span>
</span></span><span class=line><span class=cl>	<span class=n>stat</span><span class=p>(</span><span class=s>&#34;/etc/passwd&#34;</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>st</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=n>original_passwd_size</span> <span class=o>=</span> <span class=n>st</span><span class=p>.</span><span class=n>st_size</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=cm>/* .. */</span>
</span></span><span class=line><span class=cl>	<span class=k>while</span><span class=p>(</span><span class=n>original_passwd_size</span> <span class=o>==</span> <span class=n>st</span><span class=p>.</span><span class=n>st_size</span><span class=p>){</span>
</span></span><span class=line><span class=cl>		<span class=n>stat</span><span class=p>(</span><span class=s>&#34;/etc/passwd&#34;</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>st</span><span class=p>);</span>
</span></span><span class=line><span class=cl>		<span class=n>size</span> <span class=o>=</span> <span class=n>st</span><span class=p>.</span><span class=n>st_size</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=n>sleep</span><span class=p>(</span><span class=mi>2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=cm>/* .. */</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><a href=#exploitation-walkthrough><h3 id=exploitation-walkthrough><span class=hanchor arialabel=Anchor># </span>Exploitation Walkthrough</h3></a><p>We went a little bit inside the File Exploitation technique, now let&rsquo;s see how we abused it in order to write our exploit.
We have already seen how we can trigger the UAF in the &ldquo;Root Cause&rdquo; section, let&rsquo;s see in details how we developed the exploit.</p><a href=#setup><h4 id=setup><span class=hanchor arialabel=Anchor># </span>Setup</h4></a><p>First, setup the io_uring context to work with the
<a href=https://unixism.net/loti/tutorial/sq_poll.html rel=noopener>Submission Queue Polling</a> mechanism and register a dummy file using the <code>io_uring_register</code> syscall.</p><a href=#starting-slow_write><h4 id=starting-slow_write><span class=hanchor arialabel=Anchor># </span>Starting slow_write</h4></a><p>Since we want to replace the userfault technique in the published POC with another one, we choose to go with the Slow Write technique. As described before, we can pause a write operation abusing the file locking mechanism. Before letting io_uring write into the registered &ldquo;dummy file&rdquo;, we want to &ldquo;slow write&rdquo; on that file (that means, write a lot of data that will take time and lock the file inode) in a way that the kernel thread responsible to perform the write operation in behalf of io_uring, will be waiting at the
<a href=https://elixir.bootlin.com/linux/v5.15.75/source/fs/ext4/file.c#L263 rel=noopener>inode_lock</a> call. In order to perform this slow write operation, we have been inspired from
<a href=https://github.com/Markakd/CVE-2022-2588/blob/master/exp_file_credential.c#L558 rel=noopener>this CVE-2022-2588 exploit</a> function.
Now that the write operation is paused, is the perfect time to trigger the UAF !</p><a href=#free-the-registered-file-trigger-the-uaf><h4 id=free-the-registered-file-trigger-the-uaf><span class=hanchor arialabel=Anchor># </span>Free the registered file (trigger the UAF)</h4></a><p>In order to trigger the UAF, we have to trigger the Unix Garbager Collector (
<a href=https://elixir.bootlin.com/linux/v5.15.74/source/net/unix/garbage.c#L205 rel=noopener>unix_gc</a>) function in some way. That was not a big deal. First, because the POC already had a source line that did exactly that. Second, because every <code>unix_*</code> file operation calls it in its release function (example with
<a href=https://elixir.bootlin.com/linux/v5.15.75/source/net/unix/af_unix.c#L744 rel=noopener>unix_stream_ops</a>):
<a href=https://elixir.bootlin.com/linux/v5.15.75/source/net/unix/af_unix.c#L941 rel=noopener>unix_release</a> ->
<a href=https://elixir.bootlin.com/linux/v5.15.75/source/net/unix/af_unix.c#L534 rel=noopener>unix_release_sock</a> ->
<a href=https://elixir.bootlin.com/linux/v5.15.75/source/net/unix/af_unix.c#L606 rel=noopener>unix_gc call</a>.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=n>close</span><span class=p>(</span><span class=n>socket</span><span class=p>(</span><span class=n>AF_UNIX</span><span class=p>,</span> <span class=n>SOCK_DGRAM</span><span class=p>,</span> <span class=mi>0</span><span class=p>));</span>
</span></span></code></pre></td></tr></table></div></div><p>With this simple one-line, <code>unix_gc</code> is triggered and our target file chunk should be freed!</p><a href=#replace-the-target-chunk><h4 id=replace-the-target-chunk><span class=hanchor arialabel=Anchor># </span>Replace the target chunk</h4></a><p>Now, we have a freed chunk that can be re-used from another file allocation (since we are in a dedicated cache), and our objective is to re-allocate it with something in our control, like a sensitive file that we can open (the <code>open</code> syscall will allocate a <code>struct file</code> allocation in the <code>filp</code> cache) and let us perform a privileged operation by writing into it. Obviously, we went for &ldquo;/etc/passwd&rdquo; :}</p><p>As we described in the &ldquo;DirtyCred: File Exploitation&rdquo; section, since file permissions are checked once, we can easily re-allocate a read-only file, resumes the kernel thread we paused in the &ldquo;Starting slow_write&rdquo; section, and the write operation will be performed in that read-only file!</p><a href=#make-the-re-allocation-more-reliable><h5 id=make-the-re-allocation-more-reliable><span class=hanchor arialabel=Anchor># </span>Make the re-allocation more reliable</h5></a><p>Since the <code>filp</code> cache can be pretty busy (a lot of file operations and socket related stuff are inside this cache), a massive spray can be performed after the <code>unix_gc</code> is triggered, but it can be not enough. A good approach could also be to create some &ldquo;holes&rdquo; before triggering the targeted chunk re-allocation (to increase the FREELIST, but without releasing entire slabs), so that the following &ldquo;massive spray&rdquo; of &ldquo;/etc/passwd&rdquo; files would be more reliable.</p><a href=#release-the-slow_write-lock><h4 id=release-the-slow_write-lock><span class=hanchor arialabel=Anchor># </span>Release the slow_write lock</h4></a><p>Now that we have replaced the victim chunk with a specific file, when the slow write operation finishes, the lock is released and the io_uring kernel thread acquires the lock and starts writing into our re-allocated file ("/etc/passwd"), also if it&rsquo;s allocated as read-only.</p><a href=#overwrite-etcpasswd><h4 id=overwrite-etcpasswd><span class=hanchor arialabel=Anchor># </span>Overwrite /etc/passwd</h4></a><p>First, in order to just append text into &ldquo;/etc/passwd&rdquo; and not overwrite it from scratch, our victim file (the one that we have used as the victim chunk in our Use-After-Free) has been opened with the <code>O_APPEND</code> flag, that append text at the end of the file.
What can we write into it? We can write a simple user using the following format, that will not require the password into &ldquo;"/etc/shadow&rdquo;:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>&lt;USER&gt;:&lt;HASH&gt;:0:0:/root:/root:/bin/sh
</span></span></code></pre></td></tr></table></div></div><a href=#poc--gtfo><h4 id=poc--gtfo><span class=hanchor arialabel=Anchor># </span>POC || GTFO</h4></a><p>You can find the full exploit here:
<a href=https://github.com/kiks7/CVE-2022-2602-Kernel-Exploit rel=noopener>https://github.com/kiks7/CVE-2022-2602-Kernel-Exploit</a>.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>/ $ uname -a
</span></span><span class=line><span class=cl>Linux <span class=o>(</span>none<span class=o>)</span> 5.15.74 <span class=c1>#20 SMP Sat Nov 19 14:01:51 CET 2022 x86_64 GNU/Linux</span>
</span></span><span class=line><span class=cl>/ $ cat /etc/passwd
</span></span><span class=line><span class=cl>root:x:0:0:root:/root:/bin/sh
</span></span><span class=line><span class=cl>user:x:1000:1000:kiks,,,:/home/user:/bin/sh
</span></span><span class=line><span class=cl>/ $ id
</span></span><span class=line><span class=cl><span class=nv>uid</span><span class=o>=</span>1000<span class=o>(</span>user<span class=o>)</span> <span class=nv>gid</span><span class=o>=</span><span class=m>1000</span> <span class=nv>groups</span><span class=o>=</span><span class=m>1000</span>
</span></span><span class=line><span class=cl>/ $ /poc
</span></span><span class=line><span class=cl><span class=o>[</span>P<span class=o>]</span> P1
</span></span><span class=line><span class=cl><span class=o>[</span>P<span class=o>]</span> P2
</span></span><span class=line><span class=cl><span class=o>[</span>*<span class=o>]</span> Creating thread <span class=k>for</span> slow write on /tmp/rwA
</span></span><span class=line><span class=cl><span class=o>[</span>*<span class=o>]</span> Sleeping <span class=k>while</span> waiting that slow_write starts ..
</span></span><span class=line><span class=cl><span class=o>[</span>*<span class=o>][</span>T1<span class=o>]</span> Starting slow write ..
</span></span><span class=line><span class=cl><span class=o>[</span>*<span class=o>][</span>T1<span class=o>]</span> Slowing write...
</span></span><span class=line><span class=cl><span class=o>[</span>P<span class=o>]</span> P3/P4
</span></span><span class=line><span class=cl><span class=o>[</span>P<span class=o>]</span> P5
</span></span><span class=line><span class=cl><span class=o>[</span>*<span class=o>]</span> Triggering unix_gc and freeing the registered fd
</span></span><span class=line><span class=cl><span class=o>[</span>*<span class=o>]</span> unix_gc finished !
</span></span><span class=line><span class=cl><span class=o>[</span>P<span class=o>]</span> P6
</span></span><span class=line><span class=cl><span class=o>[</span>*<span class=o>]</span> Spraying target files ..
</span></span><span class=line><span class=cl><span class=o>[</span>*<span class=o>]</span> Wait that slow_write finishes ..
</span></span><span class=line><span class=cl><span class=o>[</span>P<span class=o>]</span> P7/P8/P9
</span></span><span class=line><span class=cl><span class=o>[</span>+<span class=o>][</span>T1<span class=o>]</span> slow_write finished
</span></span><span class=line><span class=cl><span class=o>[</span>+<span class=o>]</span> Slow write finished .. closing io_uring fd
</span></span><span class=line><span class=cl><span class=o>[</span>*<span class=o>]</span> Waits that the io_uring thread continues the writev operation <span class=k>while</span> the process is still alive
</span></span><span class=line><span class=cl><span class=o>[</span>+<span class=o>]</span> Everything <span class=k>done</span> !
</span></span><span class=line><span class=cl>Password:
</span></span><span class=line><span class=cl><span class=nv>uid</span><span class=o>=</span>0<span class=o>(</span>root<span class=o>)</span> <span class=nv>gid</span><span class=o>=</span><span class=m>0</span> <span class=nv>groups</span><span class=o>=</span><span class=m>0</span>
</span></span><span class=line><span class=cl><span class=o>[</span>+<span class=o>]</span> DONE
</span></span><span class=line><span class=cl>/ $ cat /etc/passwd
</span></span><span class=line><span class=cl>root:x:0:0:root:/root:/bin/sh
</span></span><span class=line><span class=cl>user:x:1000:1000:kiks,,,:/home/user:/bin/sh
</span></span><span class=line><span class=cl>pwn:<span class=nv>$6$pwn$5</span>m1zBfEzD3xCg.wOtCtlKePwQL3Y5UiVAQBEAIv67Ir9JfZjmjO7XwzMzk0IcRoPjtWg.k2ytbimpKp1s/RB2/:0:0:/root:/root:/bin/sh
</span></span><span class=line><span class=cl>/ $
</span></span></code></pre></td></tr></table></div></div><a href=#extra-new-krwx-feature><h2 id=extra-new-krwx-feature><span class=hanchor arialabel=Anchor># </span>Extra: new KRWX feature</h2></a><p><a href=https://github.com/kiks7/KRWX rel=noopener>KRWX</a> is a tool I developed to deepen kernel internals and to assists kernel exploitation. Since in this case it was necessary to deal with a specific special cache (<code>filp</code>) and this feature wasn&rsquo;t implemented, I added it. Now it&rsquo;s possible to retrieve the address of a specific <code>kmem_cache</code> using <code>kmem_cache_get(char* name)</code>, like the following:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;lib/krwx.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=kt>int</span> <span class=nf>main</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>	<span class=cm>/* .. */</span>
</span></span><span class=line><span class=cl>	<span class=n>kmem_cache_get</span><span class=p>(</span><span class=s>&#34;filp&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=cm>/* .. */</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>It will return the kernel address of the cache that can be used to allocate objects into it using the already present user-land <code>kmem_cache_alloc()</code> (with some internal changes to accomodate the implementation). You can find the
<a href=https://github.com/kiks7/KRWX/blob/main/client/example/kmem_cache_get.c rel=noopener>full example here</a>, but this is an extract:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;lib/krwx.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=kt>int</span> <span class=nf>main</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>	<span class=cm>/* .. */</span>
</span></span><span class=line><span class=cl>	<span class=n>filp</span> <span class=o>=</span> <span class=n>kmem_cache_get</span><span class=p>(</span><span class=s>&#34;filp&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>chunk</span> <span class=o>=</span> <span class=n>kmem_cache_alloc</span><span class=p>(</span><span class=n>filp</span><span class=p>,</span> <span class=n>GFP_KERNEL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>kmem_cache_free</span><span class=p>(</span><span class=n>filp</span><span class=p>,</span> <span class=n>chunk</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=cm>/* .. *
</span></span></span><span class=line><span class=cl><span class=cm>}
</span></span></span></code></pre></td></tr></table></div></div><p>If you are interested, you can find the project on
<a href=https://github.com/kiks7/KRWX rel=noopener>github</a>.</p><a href=#conclusions><h2 id=conclusions><span class=hanchor arialabel=Anchor># </span>Conclusions</h2></a><p>This is how we managed to exploit the CVE-2022-2602 using the inode locking technique. It was a really fun (and sometimes pain) adventure and it was a pleasure to have worked on it with Luca (
<a href=https://exploiter.dev rel=noopener>@LukeGix</a>). You can take a look at
<a href=https://exploiter.dev/blog/2022/CVE-2022-2602.html rel=noopener>his blog post</a> to see how it&rsquo;s possible to exploit the same vulnerability with userfaultd and FUSE techniques!</p><p>Stay tuned for more!</p><a href=#references><h2 id=references><span class=hanchor arialabel=Anchor># </span>References</h2></a><ul><li><a href=https://exploiter.dev/blog/2022/CVE-2022-2602.html rel=noopener>https://exploiter.dev/blog/2022/CVE-2022-2602.html</a></li><li><a href=https://github.com/kiks7/CVE-2022-2602-Kernel-Exploit rel=noopener>https://github.com/kiks7/CVE-2022-2602-Kernel-Exploit</a></li><li><a href=https://github.com/kiks7/KRWX rel=noopener>https://github.com/kiks7/KRWX</a></li><li><a href=https://googleprojectzero.blogspot.com/2022/08/the-quantum-state-of-linux-kernel.html rel=noopener>https://googleprojectzero.blogspot.com/2022/08/the-quantum-state-of-linux-kernel.html</a></li><li><a href=https://github.com/Markakd/CVE-2022-2588/ rel=noopener>https://github.com/Markakd/CVE-2022-2588/</a></li><li><a href=https://zplin.me/papers/DirtyCred.pdf rel=noopener>https://zplin.me/papers/DirtyCred.pdf</a></li><li><a href=https://i.blackhat.com/USA-22/Thursday/US-22-Lin-Cautious-A-New-Exploitation-Method.pdf rel=noopener>https://i.blackhat.com/USA-22/Thursday/US-22-Lin-Cautious-A-New-Exploitation-Method.pdf</a></li><li><a href=https://blog.hacktivesecurity.com/index.php/2022/06/13/linux-kernel-exploit-development-1day-case-study/ rel=noopener>https://blog.hacktivesecurity.com/index.php/2022/06/13/linux-kernel-exploit-development-1day-case-study/</a></li><li><a href=https://exploiter.dev/blog/2022/FUSE-exploit.html rel=noopener>https://exploiter.dev/blog/2022/FUSE-exploit.html</a></li><li><a href=https://en.wikipedia.org/wiki/Lock_%28computer_science%29 rel=noopener>https://en.wikipedia.org/wiki/Lock_(computer_science)</a></li><li><a href="https://seclists.org/oss-sec/2022/q4/57?utm_source=dlvr.it&utm_medium=twitter" rel=noopener>https://seclists.org/oss-sec/2022/q4/57?utm_source=dlvr.it&utm_medium=twitter</a></li><li><a href=https://ruia-ruia.github.io/2022/08/05/CVE-2022-29582-io-uring/ rel=noopener>https://ruia-ruia.github.io/2022/08/05/CVE-2022-29582-io-uring/</a></li></ul></article><hr><div id=contact_buttons><footer><p>Powered by <a href=https://github.com/jackyzha0/quartz>Quartz</a>, Â© 2025</p><ul><li><a href=https://1day.dev/>Home</a></li><li><a href=https://twitter.com/kiks7_7>Twitter</a></li><li><a href=https://github.com/kiks7>Github</a></li><li><a href=https://linkedin.com/in/alessandro-groppo-1a0429146>Linkedin</a></li></ul></footer></div></div></body></html>